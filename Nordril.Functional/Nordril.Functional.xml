<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nordril.Functional</name>
    </assembly>
    <members>
        <member name="T:Nordril.Functional.Algebra.IContainsFirst`1">
            <summary>
            A product which contains a first grouplike structure.
            </summary>
            <typeparam name="T">The type of the grouplike.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IContainsFirst`1.First">
            <summary>
            Gets the first grouplike.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IContainsSecond`1">
            <summary>
            A product which contains a second grouplike structure.
            </summary>
            <typeparam name="T">The type of the grouplike.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IContainsSecond`1.Second">
            <summary>
            Gets the second grouplike.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IContainsRinglike`1">
            <summary>
            A product which contains a ringlike structure.
            </summary>
            <typeparam name="T">The type of the ringlike.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IContainsRinglike`1.Ringlike">
            <summary>
            Gets the second grouplike.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IContainsOrder`1">
            <summary>
            A product which contains an ordering like <see cref="T:Nordril.Functional.Algebra.ITotalOrder`1"/>.
            </summary>
            <typeparam name="T">The type of the ordering.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IContainsOrder`1.Order">
            <summary>
            Gets the order.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasMagma`1">
            <summary>
            An algebraic structure supporting a binary operation with no further guaranteed properties.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasAssociativity`1">
            <summary>
            A magma whose binary operation is associative.
            The binary operation must fulfill the following for all X and Y:
            <code>
                X.Op(Y).Op(Z) == X.Op(Y.Op(Z)) (associativity)
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasCommutativity`1">
            <summary>
            A magma whose binary operation is commutative.
            The binary operation must fulfill the following for all X and Y:
            <code>
                X.Op(Y) == Y.Op(X) (commutativity)
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasNeutralElement`1">
            <summary>
            A magma whose binary operation has a neutral element.
            The binary operation must fulfill the following for all X and Y:
            <code>
                X.Neutral().Op(Y) == Y (left-neutrality)
                X.Op(Y.Neutral()) == X (right-neutrality)
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasSemigroup`1">
            <summary>
            A semigroup whose binary operation is associative.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasMonoid`1">
            <summary>
            A semigroup which has a neutral element with respect to the binary operation.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasGroup`1">
            <summary>
            A monoid which supports a unary inversion operator with respect to the associative binary operation.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasCommutativeGroup`1">
            <summary>
            A monoid which supports a unary inversion operator with respect to the associative binary operation.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasSemilattice`1">
            <summary>
            A semi-lattice, which is commutative, associative, and idempotent.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IMagma`1">
            <summary>
            An algebraic structure supporting a binary operation with no further guaranteed properties.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)">
            <summary>
            The binary operation.
            This operation should not change either operand.
            </summary>
            <param name="x">The first operand.</param>
            <param name="y">The second operand.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IAssociative`1">
            <summary>
            A magma whose binary operation is associative.
            The binary operation must fulfill the following for all X and Y:
            <code>
                m.Op(m.Op(X,Y),Z) == m.Op(X, m.Op(Y,Z)) (associativity)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ICommutative`1">
            <summary>
            A magma whose binary operation is commutative.
            The binary operation must fulfill the following for all X and Y:
            <code>
                m.(X, Y) == m.Op(Y, X) (commutativity)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.INeutralElement`1">
            <summary>
            A magma whose binary operation has a neutral element.
            The binary operation must fulfill the following for all X and Y:
            <code>
                m.Op(m.Neutral, X) == Y (left-neutrality)
                m.Op(X, m.Neutral) == X (right-neutrality)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral">
            <summary>
            Returns the neutral element.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IInverse`1">
            <summary>
            A monoid which supports a unary inversion operator with respect to the associative binary operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IInverse`1.Inverse(`0)">
            <summary>
            Returns the inverse of the object. The inverse must fulfill the following for all X:
            <code>
                m.Op(X.Inverse, X) == m.Neutral (left-inverse)
                m.Op(X, X.Inverse) == m.Neutral (right-inverse)
            </code>
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IIdempotent`1">
            <summary>
            A magma where performing the binary operation <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> on an element <c>X</c> with itself results in that initial element, i.e.
            <code>
                m.Op(X, X) == X (idempotence)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISemigroup`1">
            <summary>
            A semigroup whose binary operation is associative.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IMonoid`1">
            <summary>
            A semigroup which has a neutral element with respect to the binary operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ICommutativeMonoid`1">
            <summary>
            A commutative monoid.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IGroup`1">
            <summary>
            A monoid which supports a unary inversion operator with respect to the associative binary operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ICommutativeGroup`1">
            <summary>
            A commutative group.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISemilattice`1">
            <summary>
            A semi-lattice, which is commutative, associative, and idempotent.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.StructuresExtensions">
            <summary>
            Extension methods for algebraic structures.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.StructuresExtensions.Op``1(``0,``0)">
            <summary>
            Applies the <see cref="T:Nordril.Functional.Algebra.IMagma`1"/>'s binary operation to this object and a second operand.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <param name="x">The first operand.</param>
            <param name="y">The second operand.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.StructuresExtensions.Inverse``1(``0)">
            <summary>
            Applies the <see cref="M:Nordril.Functional.Algebra.IInverse`1.Inverse(`0)"/> to itself.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <param name="x">The operand.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Magma`1">
            <summary>
            A value-level monoid.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Algebra.Magma`1.op">
            <summary>
            The binary operation.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Magma`1.#ctor(System.Func{`0,`0,`0})">
            <summary>
            Creates a new magma.
            </summary>
            <param name="op">The binary operation.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Magma`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.ContainsGrouplike`1">
            <summary>
            A covariant product-wrapper around a grouplike structure.
            </summary>
            <typeparam name="T">The type of the contained grouplike.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.ContainsGrouplike`1.First">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.ContainsGrouplike`1.#ctor(`0)">
            <summary>
            Creates a new instance. See also <see cref="M:Nordril.Functional.Algebra.Magma.AsProduct``2(``1)"/>.
            </summary>
            <param name="first">The contained grouplike.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Magma">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.IMagma`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Magma.ToRelation``1(Nordril.Functional.Algebra.IMagma{``0})">
            <summary>
            Turns an <see cref="T:Nordril.Functional.Algebra.IMagma`1"/> into a binary relation which has a tuple of inputs on the left and an output on the right.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
            <param name="m">The magma.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Magma.AsProduct``2(``1)">
            <summary>
            Wraps a grouplike structure in a single-element product so that it can be used in functions which expect products like <see cref="M:Nordril.Functional.Algebra.Ringlike.Zero``2(Nordril.Functional.Algebra.IContainsFirst{``1})"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TGrouplike">The type of the grouplike to wrap.</typeparam>
            <param name="m">The grouplike to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Semigroup`1">
            <summary>
            A value-level semigroup.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Algebra.Semigroup`1.op">
            <summary>
            The binary operation.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup`1.#ctor(System.Func{`0,`0,`0})">
            <summary>
            Creates a new semigroup.
            </summary>
            <param name="op">The binary operation.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Semigroup">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.Semigroup`1"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Semigroup.BoolXor">
            <summary>
            The (^) semigroup for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup.First``1">
            <summary>
            The semigroup whose operation always returns the first element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup.Last``1">
            <summary>
            The semigroup whose operation always returns the last element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup.LiftSemigroupWithInfinity``1(Nordril.Functional.Algebra.Semigroup{``0})">
            <summary>
            Lifts a <see cref="T:Nordril.Functional.Algebra.Semigroup`1"/> into one which has positive infinity (<see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>) as a special element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <param name="m">The monoid to lift.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid`1">
            <summary>
            A value-level monoid.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid`1.Neutral">
            <summary>
            The neutral element of the binary operation.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid`1.op">
            <summary>
            The binary operation.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid`1.#ctor(`0,System.Func{`0,`0,`0})">
            <summary>
            Creates a new monoid.
            </summary>
            <param name="neutral">The neutral element.</param>
            <param name="op">The binary operation.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.Monoid`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.NeutralUnsafe``2">
            <summary>
            Returns <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> of an <typeparamref name="TNeutralElement"/>. The type in question does not have to possess a parameterless constructor; instead, a call to <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> with the this-pointer being null is forced. If <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> of <typeparamref name="TNeutralElement"/> uses the this-pointer, a <see cref="T:System.NullReferenceException"/> will be thrown.
            </summary>
            <typeparam name="T">The type of the neutral element.</typeparam>
            <typeparam name="TNeutralElement">The type of the <see cref="T:Nordril.Functional.Algebra.INeutralElement`1"/>.</typeparam>
            <exception cref="T:System.NullReferenceException">If <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> of <typeparamref name="TNeutralElement"/> uses the this-pointer.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.GetNeutralUnsafe``2">
            <summary>
            Returns a function which, if called, returns <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> of an <typeparamref name="TNeutralElement"/>. The type in question does not have to possess a parameterless constructor; instead, a call to <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> with the this-pointer being null is forced. If <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> of <typeparamref name="TNeutralElement"/> uses the this-pointer, a <see cref="T:System.NullReferenceException"/> will be thrown.
            </summary>
            <typeparam name="T">The type of the neutral element.</typeparam>
            <typeparam name="TNeutralElement">The type of the <see cref="T:Nordril.Functional.Algebra.INeutralElement`1"/>.</typeparam>
            <exception cref="T:System.NullReferenceException">If <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/> of <typeparamref name="TNeutralElement"/> uses the this-pointer.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.OpUnsafe``2">
            <summary>
            Calls <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> of of an <typeparamref name="TMagma"/>. The type in question does not have to possess a parameterless constructor; instead, a call to <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> with the this-pointer being null is forced. If <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> of <typeparamref name="TMagma"/> uses the this-pointer, a <see cref="T:System.NullReferenceException"/> will be thrown.
            </summary>
            <typeparam name="T">The type of the neutral element.</typeparam>
            <typeparam name="TMagma">The type of the <see cref="T:Nordril.Functional.Algebra.IMagma`1"/>.</typeparam>
            <exception cref="T:System.NullReferenceException">If <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> of <typeparamref name="TMagma"/> uses the this-pointer.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.Msum``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Sums a list of monoid elements using the monoid operation. If the list is empty, the neutral element is returned. 
            </summary>
            <typeparam name="T">The monoid type.</typeparam>
            <param name="xs">The list of elements to sum.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.LiftMonoidWithInfinity``1(Nordril.Functional.Algebra.IMonoid{``0})">
            <summary>
            Lifts an <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> into one which has positive infinity (<see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>) as a special element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <param name="m">The monoid to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.Msum``1(System.Collections.Generic.IEnumerable{``0},Nordril.Functional.Algebra.IMonoid{``0})">
            <summary>
            Sums a list of elements using a monoid instance. If the list is empty, the neutral element is returned.
            </summary>
            <typeparam name="T">The type of elements to sum.</typeparam>
            <param name="xs">The list of elements to sum.</param>
            <param name="m">The monoid instance.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.ListAppend``1">
            <summary>
            The mutating ([],++) monoid for lists. The binary operation mutates the first list.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.ImmutableListAppend``1">
            <summary>
            The non-mutating ([],++) monoid for lists, meaning that the inputs of <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)" /> aren't changed.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.StringAppend">
            <summary>
            The ("",+) monoid for <see cref="T:System.String"/>.
            BEWARE THAT THIS HAS VERY POOR PERFORMANCE.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.StringBuilderAppend">
            <summary>
            The ("",Append) monoid for <see cref="T:System.Text.StringBuilder"/>. Appending mutates the first argument.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.BoolAnd">
            <summary>
            The (true,&amp;&amp;) monoid for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.BoolOr">
            <summary>
            The (false,||) monoid for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.IntMult">
            <summary>
            The (1,*) monoid for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.FirstOrDefault``1(``0)">
            <summary>
            The monoid whose operation always returns the first element and which has a default-value.
            </summary>
            <param name="default">The neutral element of the monoid.</param>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.LastOrDefault``1(``0)">
            <summary>
            The monoid whose operation always returns the last element.
            </summary>
            <param name="default">The neutral element of the monoid.</param>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.First``1">
            <summary>
            The monoid whose neutral element is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and which always returns the first non-<see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> operand.
            </summary>
            <typeparam name="T">The type of the elements.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.Endo``1">
            <summary>
            The monoid of function composition, for <c>Func&lt;T,T&gt;</c>
            </summary>
            <typeparam name="T">The type of the input/output elements.</typeparam>
            <returns></returns>
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.ListAppendMonoid`1">
            <summary>
            The mutating ([],++) monoid for lists. The binary operation mutates the first list.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.ListAppendMonoid`1.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.ListAppendMonoid`1.Op(System.Collections.Generic.List{`0},System.Collections.Generic.List{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.ListAppendImmutableMonoid`1">
            <summary>
            The non-mutating ([],++) monoid for lists, meaning that the inputs of <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)" /> aren't changed.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.ListAppendImmutableMonoid`1.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.ListAppendImmutableMonoid`1.Op(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.StringBuilderAppendMonoid">
            <summary>
            The ("",Append) monoid for <see cref="T:System.Text.StringBuilder"/>. Appending mutates the first argument.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.StringBuilderAppendMonoid.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.StringBuilderAppendMonoid.Op(System.Text.StringBuilder,System.Text.StringBuilder)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.BoolAndMonoid">
            <summary>
            The (true,&amp;&amp;) monoid for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.BoolAndMonoid.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.BoolAndMonoid.Op(System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.BoolOrMonoid">
            <summary>
            The (false,||) monoid for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.BoolOrMonoid.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.BoolOrMonoid.Op(System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.IntMultMonoid">
            <summary>
            The (1,*) monoid for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.IntMultMonoid.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.IntMultMonoid.Op(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.FirstOrDefaultMonoid`1">
            <summary>
            The monoid whose operation always returns the first element and which has a default-value.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.FirstOrDefaultMonoid`1.#ctor(`0)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="default">The neutral element of the monoid.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.FirstOrDefaultMonoid`1.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.FirstOrDefaultMonoid`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.LastOrDefaultMonoid`1">
            <summary>
            The monoid whose operation always returns the last element and which has a default-value.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.LastOrDefaultMonoid`1.#ctor(`0)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="default">The neutral element of the monoid.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.LastOrDefaultMonoid`1.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.LastOrDefaultMonoid`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.FirstMonoid`1">
            <summary>
            The (Nothing, Alt)-monoid.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.FirstMonoid`1.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.FirstMonoid`1.Op(Nordril.Functional.Data.Maybe{`0},Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid.EndoMonoid`1">
            <summary>
            The (id, (.))-monoid.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid.EndoMonoid`1.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.EndoMonoid`1.Op(System.Func{`0,`0},System.Func{`0,`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group`1">
            <summary>
            A value-level group.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group`1.Neutral">
            <summary>
            The neutral element of the binary operation.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group`1.op">
            <summary>
            The binary operation.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group`1.inverse">
            <summary>
            The inversion function.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Group`1.#ctor(`0,System.Func{`0,`0,`0},System.Func{`0,`0})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="neutral">The neutral element.</param>
            <param name="op">The binary operation.</param>
            <param name="inverse">The inversion function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Group`1.Inverse(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.Monoid`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.FromGroupInstance``1">
            <summary>
            Reifies a type's <see cref="T:Nordril.Functional.Algebra.IHasGroup`1"/> instance into its own <see cref="T:Nordril.Functional.Algebra.Group`1"/>-object.
            </summary>
            <typeparam name="T">The type that implements <see cref="T:Nordril.Functional.Algebra.IHasGroup`1"/>.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.BoolXor">
            <summary>
            The (0,XOR,id) group for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.IntAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.LongAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.FloatAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DoubleAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DecimalAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.FloatMult">
            <summary>
            The (1,*,x =&gt; 1/x) group for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DoubleMult">
            <summary>
            The (1,*,x =&gt; 1/x) group for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DecimalMult">
            <summary>
            The (1,*,x =&gt; 1/x) group for <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.BoolXorGroup">
            <summary>
            The (0,XOR,id) group for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.BoolXorGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.BoolXorGroup.Inverse(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.BoolXorGroup.Op(System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.IntAddGroup">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.IntAddGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.IntAddGroup.Inverse(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.IntAddGroup.Op(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.LongAddGroup">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.LongAddGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.LongAddGroup.Inverse(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.LongAddGroup.Op(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.FloatAddGroup">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.FloatAddGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.FloatAddGroup.Inverse(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.FloatAddGroup.Op(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.DoubleAddGroup">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.DoubleAddGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DoubleAddGroup.Inverse(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DoubleAddGroup.Op(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.DecimalAddGroup">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.DecimalAddGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DecimalAddGroup.Inverse(System.Decimal)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DecimalAddGroup.Op(System.Decimal,System.Decimal)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.FloatMultGroup">
            <summary>
            The (1,*,x =&gt; 1/x) group for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.FloatMultGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.FloatMultGroup.Inverse(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.FloatMultGroup.Op(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.DoubleMultGroup">
            <summary>
            The (1,*,x =&gt; 1/x) group for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.DoubleMultGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DoubleMultGroup.Inverse(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DoubleMultGroup.Op(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Group.DecimalMultGroup">
            <summary>
            The (1,*,x =&gt; 1/x) group for <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group.DecimalMultGroup.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DecimalMultGroup.Inverse(System.Decimal)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.DecimalMultGroup.Op(System.Decimal,System.Decimal)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Semilattice`1">
            <summary>
            A value-level group.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Algebra.Semilattice`1.op">
            <summary>
            The binary operation.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semilattice`1.#ctor(System.Func{`0,`0,`0})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="op">The binary operation.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semilattice`1.Op(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Semilattice">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.ISemilattice`1"/>s.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.Semilattice.SetMeetSemilattice`1">
            <summary>
            A meet-semilattice whose operation creates the union of two sets.
            </summary>
            <typeparam name="T">The type of the elements of the set.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semilattice.SetMeetSemilattice`1.Op(System.Collections.Generic.ISet{`0},System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Semilattice.SetJoinSemilattice`1">
            <summary>
            A join-semilattice whose operation creates the intersection of two sets.
            </summary>
            <typeparam name="T">The type of the elements of the set.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semilattice.SetJoinSemilattice`1.Op(System.Collections.Generic.ISet{`0},System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.KeyAlreadyPresentException">
            <summary>
            Indicates that a string-key was already present when an attempt was made to
            insert it into a collection.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.KeyAlreadyPresentException.Key">
            <summary>
            The key or its string-form.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.KeyAlreadyPresentException.#ctor(System.String)">
            <summary>
            Creates a new exception.
            </summary>
            <param name="key">The value of the duplicate key.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.KeyAlreadyPresentException.#ctor">
            <summary>
            Creates a new exception.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.KeyAlreadyPresentException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IPartiallyOrderedGrouplike`3">
            <summary>
            A grouplike structure equipped with a partial order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TStructure">The type of the grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IPartiallyOrderedRinglike`5">
            <summary>
            A ringlike structure equipped with a partial order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ITotallyOrderedGrouplike`3">
            <summary>
            A rouplike structure equipped with a total order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TStructure">The type of the grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ITotallyOrderedRinglike`5">
            <summary>
            A ringlike structure equipped with a total order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.Ordered">
            <summary>
            Extension methods for ordered sets.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.WithPartialOrder``3(``1,``2)">
            <summary>
            Equips a grouplike structure with a partial order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TStructure">The type of the structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="structure">The structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.WithPartialOrder``5(``1,``4)">
            <summary>
            Equips a ringlike structure with a partial order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="structure">The ringlike structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.WithTotalOrder``3(``1,``2)">
            <summary>
            Equips a grouplike structure with a total order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TStructure">The type of the structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="structure">The structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.WithTotalOrder``5(``1,``4)">
            <summary>
            Equips a ringlike structure with a total order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="structure">The ringlike structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.Abs``3(``0,``2)">
            <summary>
            Returns the absolute value of an element <paramref name="x"/>, as defined via the piecewise function:
            <code>
            abs(x) = if x &lt; 0 then negate(x) else x
            </code>
            Where <c>&lt;</c> is defined by the total order, <c>0</c> is the neutral element of the first grouplike structure, and <c>negate</c> is the inverse-function of the first grouplike structure.
            </summary>
            <typeparam name="TStructure">The ringlike structure.</typeparam>
            <typeparam name="TFirst">The first grouplike structure.</typeparam>
            <typeparam name="T">The type of the elements.</typeparam>
            <param name="st">The structure to use.</param>
            <param name="x">The element whose absolute value to get.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.Abs``3(``1,Nordril.Functional.Algebra.ITotalOrder{``0},``0)">
            <summary>
            Returns the absolute value of an element <paramref name="x"/>, as defined via the piecewise function:
            <code>
            abs(x) = if x &lt; 0 then negate(x) else x
            </code>
            Where <c>&lt;</c> is defined by the total order, <c>0</c> is the neutral element of the first grouplike structure, and <c>negate</c> is the inverse-function of the first grouplike structure.
            </summary>
            <typeparam name="TStructure">The ringlike structure.</typeparam>
            <typeparam name="TFirst">The first grouplike structure.</typeparam>
            <typeparam name="T">The type of the elements.</typeparam>
            <param name="st">The structure to use.</param>
            <param name="order">The total order.</param>
            <param name="x">The element whose absolute value to get.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.Signum``3(``1,``0)">
            <summary>
            Returns the sign (-1 for negative values, 0 for 0, 1 for positive values) of an element <paramref name="x"/>.
            </summary>
            <typeparam name="TStructure">The type of the algebraic structure to use.</typeparam>
            <typeparam name="TFirst">The first grouplike structure.</typeparam>
            <typeparam name="T">The type of the elements.</typeparam>
            <param name="st">The algebraic structure to use</param>
            <param name="x">The element whose sign to get.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ordered.Signum``2(``0,Nordril.Functional.Algebra.ITotalOrder{``1},``1)">
            <summary>
            Returns the sign (-1 for negative values, 0 for 0, 1 for positive values) of an element <paramref name="x"/>.
            </summary>
            <typeparam name="TStructure">The type of the algebraic structure to use.</typeparam>
            <typeparam name="T">The type of the elements.</typeparam>
            <param name="st">The algebraic structure to use</param>
            <param name="order">The total order.</param>
            <param name="x">The element whose sign to get.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.PartiallyOrderedGrouplike`3">
            <summary>
            A grouplike structure equipped with a partial order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TStructure">The type of the grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartiallyOrderedGrouplike`3.#ctor(`1,`2)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="structure">The structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.PartiallyOrderedGrouplike`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.PartiallyOrderedGrouplike`3.Order">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.PartiallyOrderedRinglike`5">
            <summary>
            A ringlike structure equipped with a partial order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartiallyOrderedRinglike`5.#ctor(`1,`4)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="ringlike">The ringlike structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.PartiallyOrderedRinglike`5.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.PartiallyOrderedRinglike`5.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.PartiallyOrderedRinglike`5.Order">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.PartiallyOrderedRinglike`5.Ringlike">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.TotallyOrderedGrouplike`3">
            <summary>
            A grouplike structure equipped with a total order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TStructure">The type of the grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotallyOrderedGrouplike`3.#ctor(`1,`2)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="structure">The structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.TotallyOrderedGrouplike`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.TotallyOrderedGrouplike`3.Order">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.TotallyOrderedRinglike`5">
            <summary>
            A ringlike structure equipped with a total order.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotallyOrderedRinglike`5.#ctor(`1,`4)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="ringlike">The ringlike structure.</param>
            <param name="order">The order.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.TotallyOrderedRinglike`5.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.TotallyOrderedRinglike`5.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.TotallyOrderedRinglike`5.Order">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.TotallyOrderedRinglike`5.Ringlike">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.IBinaryRelation`2">
            <summary>
            A binary relation that can decide whether it contains a pair of elements.
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IBinaryRelation`2.Contains(`0,`1)">
            <summary>
            Returns true iff two elements occur as a pair in the relation.
            </summary>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IExtensionalBinaryRelation`2">
            <summary>
            An extensible binary relation that can enumerate the pairs it contains.
            Iff a a pair <c>(x,y)</c> occurs in the enumeration, then <c>r.Contains(x,y)</c> is true.
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IExtensionalBinaryRelation`2.Elements">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, listing the relation's elements.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IReflexiveRelation`1">
            <summary>
            A reflexive relation, for which the following holds:
            <code>
                r.Contains(X,X) == true (reflexivity)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISymmetricRelation`1">
            <summary>
            A symmetric relation, for which the following holds:
            <code>
                r.Contains(X,Y) == r.Contains(Y,X) (symmetric)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IAntisymmetricRelation`1">
            <summary>
            An antisymmetric relation, for which the following holds:
            <code>
                if r.Contains(X,Y) and r.Contains(Y,X) then a = b (anti-symmetry)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ITransitiveRelation`1">
            <summary>
            A transitive relation, for which the following holds:
            <code>
                if r.Contains(X,Y) and r.Contains(Y,Z) then r.Contains(X,Z) (transitivity)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ITotalRelation`2">
            <summary>
            A total relation which is equivalent to the Cartesian product of <typeparamref name="T1"/> and <typeparamref name="T2"/>.
            <code>
                r.Contains
            </code>
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IInjectiveRelation`2">
            <summary>
            An injective relation, for which the following holds:
            <code>
                if r.Contains(X,Y) and r.Contains(X,Z), then X = Y (injectivity)
            </code>
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISurjectiveRelation`2">
            <summary>
            A surjective relation, for which the following holds:
            <code>
                for all Y, there exists an X such that r.Contains(X,Y) (surjectivity)
            </code>
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IFunctionalRelation`2">
            <summary>
            A functional relation, where, for all X in <typeparamref name="T1"/>
            <code>
                if r.Contains(X,Y) and r.Contains(X,Z) then Y == Z (functional)
            </code>
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IFunctionalRelation`2.MaybeResult(`0)">
            <summary>
            Returns the <typeparamref name="T2"/> associated with an <typeparamref name="T1"/>, if it exists.
            </summary>
            <param name="x">The <typeparamref name="T1"/>.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISerialRelation`2">
            <summary>
            A serial relation, where, for all X in <typeparamref name="T1"/>, there exists an Y in <typeparamref name="T2"/> such that
            <code>
                r.Contains(X,Y) (serial)
            </code>
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IConnexRelation`1">
            <summary>
            For all X and Y, the following holds:
            <code>
                r.Contains(X,Y) or r.Contains(Y,X) (connex)
            </code>
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IOneToOneRelation`2">
            <summary>
            A one-to-one mapping between some elements of <typeparamref name="T1"/> and some elements of <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IOneToOneRelation`2.GetMaybeLeft(`1)">
            <summary>
            Gets the unique left-key associated with a given right-key, if it exists.
            </summary>
            <param name="x">The right-key.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.IOneToOneRelation`2.GetMaybeRight(`0)">
            <summary>
            Gets the unique right-key associated with a given right-key, if it exists.
            </summary>
            <param name="x">The right-key.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IBijectiveRelation`2">
            <summary>
            A bijective-relation, which is a one-to-one mapping from all elements of <typeparamref name="T1"/> to all elements of <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IBijectiveRelation`2.GetLeft(`1)">
            <summary>
            Gets the unique left-key associated with a given right-key.
            </summary>
            <param name="x">The right-key.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.IBijectiveRelation`2.GetRight(`0)">
            <summary>
            Gets the unique right-key associated with a given left-key.
            </summary>
            <param name="x">The right-key.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IFunctionRelation`2">
            <summary>
            A relation which is equivalent to a total function.
            </summary>
            <typeparam name="T1">The type of the inputs.</typeparam>
            <typeparam name="T2">The type of the outputs.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IFunctionRelation`2.Result(`0)">
            <summary>
            Returns the output associated with the input <paramref name="x"/>.
            </summary>
            <param name="x">The input.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IDictionaryRelation`2">
            <summary>
            A relation that has the semantics of a read-only dictionary: functional and extensible.
            </summary>
            <typeparam name="T1">The type of the inputs.</typeparam>
            <typeparam name="T2">The type of the outputs.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IPartialOrder`1">
            <summary>
            A partial order, i.e. a reflexive, anti-symmetric, and transitive relationship.
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ITotalOrder`1">
            <summary>
            A total order, i.e. a partial order which is also total.
            A total allows us to compare every pair of elements.
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.ITotalOrder`1.Compare(`0,`0)">
            <summary>
            Compares two elements and returns a number smaller than 0 if <c>x &lt; y</c>, 0 if <c>x == y</c>, and a number greater than 0 if <c>x &gt; y</c>.
            </summary>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasReflexiveRelation`1">
            <summary>
            A reflexive relation, for which the following holds:
            <code>
                r.Contains(X,X) == true (reflexivity)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasSymmetricRelation`1">
            <summary>
            A symmetric relation, for which the following holds:
            <code>
                r.Contains(X,Y) == r.Contains(Y,X) (symmetric)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasAntisymmetricRelation`1">
            <summary>
            An antisymmetric relation, for which the following holds:
            <code>
                if r.Contains(X,Y) and r.Contains(Y,X) then a = b (anti-symmetry)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasTransitiveRelation`1">
            <summary>
            A transitive relation, for which the following holds:
            <code>
                if r.Contains(X,Y) and r.Contains(Y,Z) then r.Contains(X,Z) (transitivity)
            </code>
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasConnexRelation`1">
            <summary>
            For all X and Y, the following holds:
            <code>
                r.Contains(X,Y) or r.Contains(Y,X) (connex)
            </code>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasPartialOrder`1">
            <summary>
            A partial order, i.e. a reflexive, anti-symmetric, and transitive relationship.
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasTotalOrder`1">
            <summary>
            A total order, i.e. a partial order which is also total.
            A total allows us to compare every pair of elements.
            </summary>
            <typeparam name="T">The type of elements contained in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.BinaryRelation`2">
            <summary>
            A value-level binary relation.
            </summary>
            <typeparam name="T1">The type of first elements contained in the relation.</typeparam>
            <typeparam name="T2">The type of second elements contained in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.BinaryRelation`2.#ctor(System.Func{`0,`1,System.Boolean})">
            <summary>
            Creates a new binary relation.
            </summary>
            <param name="contains">The "contains"-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.BinaryRelation`2.Contains(`0,`1)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.PartialOrder`1">
            <summary>
            A value-level partial order.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder`1.#ctor(System.Func{`0,`0,Nordril.Functional.Data.Maybe{System.Boolean}})">
            <summary>
            Creates a new partial order from a partial "less than or equal to"-function.
            </summary>
            <param name="leqPartial">The partial "less than or equal to"-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder`1.Contains(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.TotalOrder`1">
            <summary>
            A value-level total order.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder`1.#ctor(System.Func{`0,`0,System.Int16})">
            <summary>
            Creates a new total order from a comparison-function.
            </summary>
            <param name="comparison">The comparison-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates a total order from a "less than or equal to"-function.
            </summary>
            <param name="leq">The "less than or equal to"-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder`1.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder`1.Contains(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.FunctionRelation`2">
            <summary>
            A value-level function-relation.
            </summary>
            <typeparam name="T1">The type of the inputs.</typeparam>
            <typeparam name="T2">The type of the outputs.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.FunctionRelation`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new relation.
            </summary>
            <param name="f">The underlying function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.FunctionRelation`2.Contains(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.FunctionRelation`2.MaybeResult(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.FunctionRelation`2.Result(`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.OneToOneRelation`2">
            <summary>
            A value-level, finite one-to-one relation (a partial bijection).
            </summary>
            <typeparam name="T1">The type of the inputs.</typeparam>
            <typeparam name="T2">The type of the outputs.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.OneToOneRelation`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new relation.
            </summary>
            <param name="pairs">The pairs.</param>
            <exception cref="T:Nordril.Functional.Algebra.KeyAlreadyPresentException">A left- or right-key occurred twice.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.OneToOneRelation`2.Contains(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.OneToOneRelation`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.OneToOneRelation`2.GetMaybeLeft(`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.OneToOneRelation`2.GetMaybeRight(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.OneToOneRelation`2.MaybeResult(`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.BijectiveRelation`2">
            <summary>
            A value-level (total) bijective relation.
            </summary>
            <typeparam name="T1">The type of the inputs.</typeparam>
            <typeparam name="T2">The type of the outputs.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.#ctor(System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Creates a new relation out of two functions.
            </summary>
            <param name="to">The function which converts from the codomain to the domain.</param>
            <param name="from">The function which converts from the domain to the codomain</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.Contains(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.GetLeft(`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.GetRight(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.MaybeResult(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.GetMaybeLeft(`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.BijectiveRelation`2.GetMaybeRight(`0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.DictionaryRelation`2">
            <summary>
            A value-level dictionary-relation.
            </summary>
            <typeparam name="T1">The type of the keys.</typeparam>
            <typeparam name="T2">The type of the values.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.DictionaryRelation`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.DictionaryRelation`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.DictionaryRelation`2.Values">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.DictionaryRelation`2.Count">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.DictionaryRelation`2.Contains(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.DictionaryRelation`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.DictionaryRelation`2.MaybeResult(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.DictionaryRelation`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.DictionaryRelation`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{T1,T2}}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.DictionaryRelation`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.DictionaryRelation`2.Elements">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.PartialOrder">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.IPartialOrder`1"/>s.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder.Make``1(System.Func{``0,``0,Nordril.Functional.Data.Maybe{System.Boolean}})">
            <summary>
            Creates a new partial order from a partial "less than or equal to"-function.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="leqPartial">The partial "less than or equal to"-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder.Leq``1(Nordril.Functional.Algebra.IPartialOrder{``0},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is smaller than or equal to <paramref name="y"/> in the partial order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="order">The partial  order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder.Leq``2(Nordril.Functional.Algebra.IContainsOrder{``1},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is smaller than or equal to <paramref name="y"/> in the partial order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="order">The structure which has a total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder.FromEquatable``1">
            <summary>
            Creates a partial order and an equivalence relation from an <see cref="T:System.IEquatable`1"/> type.
            The resultant partial order only captures the notion of equality, not "less than", so the following might occur:
            <code>
                X.CompareTo(Y) &lt; 0 != r.Leq(X,Y)
            </code>
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.TotalOrder">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.ITotalOrder`1"/>s.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Make``1(System.Func{``0,``0,System.Int16})">
            <summary>
            Creates a total order out of a comparison-function.
            </summary>
            <typeparam name="T">The type of elements to compare.</typeparam>
            <param name="comparison">The comparison-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Make``1(System.Func{``0,``0,System.Int32})">
            <summary>
            Creates a total order out of a comparison-function.
            </summary>
            <typeparam name="T">The type of elements to compare.</typeparam>
            <param name="comparison">The comparison-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Make``1(System.Func{``0,``0,System.Boolean})">
            <summary>
            Creates a total order out of a "less than or equal to"-function.
            </summary>
            <typeparam name="T">The type of elements to compare.</typeparam>
            <param name="leq">The "less then or equal to"-function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Le``1(Nordril.Functional.Algebra.ITotalOrder{``0},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is strictly smaller than <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Le``2(Nordril.Functional.Algebra.IContainsOrder{``1},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is strictly smaller than <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="order">The structure which has a total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Eq``1(Nordril.Functional.Algebra.ITotalOrder{``0},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is equal to <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Eq``2(Nordril.Functional.Algebra.IContainsOrder{``1},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is equal to <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="order">The structure which has a total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Neq``1(Nordril.Functional.Algebra.ITotalOrder{``0},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is strictly not equal to <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Neq``2(Nordril.Functional.Algebra.IContainsOrder{``1},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is not equal to <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="order">The structure which has a total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Geq``1(Nordril.Functional.Algebra.ITotalOrder{``0},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is greater than or equal to <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Geq``2(Nordril.Functional.Algebra.IContainsOrder{``1},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is greater than or equal to <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="order">The structure which has a total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Ge``1(Nordril.Functional.Algebra.ITotalOrder{``0},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is strictly greater than <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Ge``2(Nordril.Functional.Algebra.IContainsOrder{``1},``0,``0)">
            <summary>
            Returns true iff <paramref name="x"/> is stricle greater than <paramref name="y"/> in the total order <paramref name="order"/>.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
            <typeparam name="TOrder">The type of the order.</typeparam>
            <param name="order">The structure which has a total order.</param>
            <param name="x">The first element to compare.</param>
            <param name="y">The second element to compare.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.FromComparable``1">
            <summary>
            Creates a total order from an <see cref="T:System.IComparable`1"/> type.
            </summary>
            <typeparam name="T">The type of the elements in the relation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.LiftTotalOrderWithInfinity``1(Nordril.Functional.Algebra.ITotalOrder{``0})">
            <summary>
            Adds positive infinity, modeled via <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> to a total order.
            </summary>
            <typeparam name="T">The type of elements in the relation.</typeparam>
            <param name="order">The total order.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Relations">
            <summary>
            Extension methods for relations.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.Make``2(System.Func{``0,``1,System.Boolean})">
            <summary>
            Creates a new intensional binary relation with no further guaranteed properties.
            </summary>
            <typeparam name="T1">The type of the first elements.</typeparam>
            <typeparam name="T2">The type of the second elements.</typeparam>
            <param name="contains">The contains-predicate.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.AsRelation``2(System.Func{``0,``1})">
            <summary>
            Returns a total function as an <see cref="T:Nordril.Functional.Algebra.IFunctionRelation`2"/>.
            </summary>
            <typeparam name="T1">The type of the input.</typeparam>
            <typeparam name="T2">The type of the output.</typeparam>
            <param name="f">The function to transform into a relation.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.AsRelation``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns an <see cref="T:Nordril.Functional.Algebra.IDictionaryRelation`2"/> from an <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="T1">The type of the keys.</typeparam>
            <typeparam name="T2">The type of the values.</typeparam>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.FromRelation``2(Nordril.Functional.Algebra.IFunctionRelation{``0,``1})">
            <summary>
            Returns an <see cref="T:Nordril.Functional.Algebra.IFunctionRelation`2"/> as a total function.
            </summary>
            <typeparam name="T1">The type of the input.</typeparam>
            <typeparam name="T2">The type of the output.</typeparam>
            <param name="r">The relation to transform into a function.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.AsBijective``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            Creates a one-to-one relation (a bijective relation that is not total) from a list of key-value-pairs.
            </summary>
            <typeparam name="T1">The type of the left-keys.</typeparam>
            <typeparam name="T2">The type of the right-keys.</typeparam>
            <param name="pairs">The pairs of keys.</param>
            <exception cref="T:Nordril.Functional.Algebra.KeyAlreadyPresentException">A left- or right-key occurred twice.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.AsBijective``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates a one-to-one relation (a bijective relation that is not total) from a list of key-value-pairs.
            </summary>
            <typeparam name="T1">The type of the left-keys.</typeparam>
            <typeparam name="T2">The type of the right-keys.</typeparam>
            <param name="pairs">The pairs of keys.</param>
            <exception cref="T:Nordril.Functional.Algebra.KeyAlreadyPresentException">A left- or right-key occurred twice.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.Relations.AsBijective``2(System.Func{``0,``1},System.Func{``1,``0})">
            <summary>
            Creates a bijection from two functions. It is the responsibility of the caller to ensure that the two function actually induce a bijection.
            </summary>
            <typeparam name="T1">The type of the left-keys.</typeparam>
            <typeparam name="T2">The type of the right-keys.</typeparam>
            <param name="to">The function which converts from the codomain to the domain.</param>
            <param name="from">The function which converts from the domain to the codomain</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasLeftDistributive`3">
            <summary>
            Ringlike structures where the first operation left-distributes over the second, i.e.
            <code>
            X * (Y + Z) == (X * Y) + (X * Z)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasRightDistributive`3">
            <summary>
            Ringlike structures where the first operation right-distributes over the second, i.e.
            <code>
            (Y + Z) * X == (Y * X) + (Z * X)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasJacobi`3">
            <summary>
            Ringlike structures where which satisfy the Jacobi-identity, e.g.
            <code>
            X * (Y * Z) == (X * Y) * Z + Y * (X * Z)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasAnnihilation`3">
            <summary>
            Ringlike structures where the neutral element of the first operation annihiliates another element, if applied with the second operation, i.e.
            <code>
            0 * X = X * 0 = 0
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasRinglike`3">
            <summary>
            General algebraic structures with two operations. The two operations are grouplike and there may be addition relationships between them,
            e.g. the second operation may distribute over the first.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasSemiring`3">
            <summary>
            A semiring; a structure with two operations, where the first operation is a commutative monoid and the second operation is a monoid.
            In addition, the second operation, left- and right-distributes over the first and the neutral elemenent of the first operation is annihiliating in the second operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasNearRing`3">
            <summary>
            A near-ring; a structure with two operations, where the first operation is a group and the second operation is a semigroup.
            In addition, the second operation, right-distributes over the first and the neutral elemenent of the first operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasRing`3">
            <summary>
            A ring. Like a semiring, but the first operation forms a commutative group, i.e. subtraction is also defined.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasBooleanRing`3">
            <summary>
            A Boolean ring; a ring where the second operation is idempotent.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasCommutativeRing`3">
            <summary>
            A ring where the second operation is commutative.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasIntegralDomain`3">
            <summary>
            A domain in which the product of two non-zero elements is also non-zero.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasGcdDomain`3">
            <summary>
            A domain in which every two elements have a greatest common divisor or, equivalently, a least common multiple, through an efficient algorithm for finding them might not exist.
            See <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasUniqueFactorizationDomain`3">
            <summary>
            A domain in which every element can be uniquely factored into a product of prime elements.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasEuclideanDomain`3">
            <summary>
            A domain which has an Euclidean division-function (every two elements <c>X</c> and <c>Y</c> can be divided, resulting in <c>Divide(X,Y) = Q * Y + R</c>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasField`3">
            <summary>
            A domain in which both operations form commutative groups, i.e. addition, multiplication, subtraction, and division (except for zero-divisors) are defined.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasFiniteField`3">
            <summary>
            A field with finitely many elements.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasLattice`3">
            <summary>
            A lattice, having a meet- and join-operation, which are commutative, associative, idempotent, and connected via the absorption-law.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasBoundedLattice`3">
            <summary>
            A bounded lattice with a unique minimal and maximal element.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasDistributedLattice`3">
            <summary>
            A distributed latter where the join and meet distribute over each other.
            </summary>
            <remarks>
            We cannot specify that the first operation should also distribute over the second
            (in addition to the second distributing over the first) via inheriting from <see cref="T:Nordril.Functional.Algebra.ILeftDistributive`3"/> and <see cref="T:Nordril.Functional.Algebra.IRightDistributive`3"/> twice with <typeparamref name="TFirst"/> and <typeparamref name="TSecond"/>, since the C# forbids type parameter unification (<typeparamref name="TFirst"/> in the first instance of <see cref="T:Nordril.Functional.Algebra.ILeftDistributive`3"/> may be instantiated to the same type as <typeparamref name="TSecond"/> in the second instance of <see cref="T:Nordril.Functional.Algebra.ILeftDistributive`3"/>, etc.). One could work around this, but the workaround was considered clunky and inconvenient to users, so we consciously omit trying to model both distributive laws in favor of just one.
            </remarks>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ILeftDistributive`3">
            <summary>
            Ringlike structures where the first operation left-distributes over the second, i.e.
            <code>
            X * (Y + Z) == (X * Y) + (X * Z)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IRightDistributive`3">
            <summary>
            Ringlike structures where the first operation right-distributes over the second, i.e.
            <code>
            (Y + Z) * X == (Y * X) + (Z * X)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IJacobi`3">
            <summary>
            Ringlike structures where which satisfy the Jacobi-identity, e.g.
            <code>
            X * (Y * Z) == (X * Y) * Z + Y * (X * Z)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IAnnihilation`3">
            <summary>
            Ringlike structures where the neutral element of the first operation annihiliates another element, if applied with the second operation, i.e.
            <code>
            0 * X = X * 0 == 0
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IAbsorbption`3">
            <summary>
            Ringlike structures which obey the absorption law:
            <code>
                X * (X + Y) == X (absorption)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IRinglike`3">
            <summary>
            General algebraic structures with two operations. The two operations are grouplike and there may be addition relationships between them,
            e.g. the second operation may distribute over the first.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IRinglikeWrapper`3">
            <summary>
            A covariant wrapper around a ringlike structure.
            </summary>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISemiring`3">
            <summary>
            A semiring; a structure with two operations, where the first operation is a commutative monoid and the second operation is a monoid.
            In addition, the second operation, left- and right-distributes over the first and the neutral elemenent of the first operation is annihiliating in the second operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.INearRing`3">
            <summary>
            A near-ring; a structure with two operations, where the first operation is a group and the second operation is a semigroup.
            In addition, the second operation, right-distributes over the first and the neutral elemenent of the first operation.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IRing`3">
            <summary>
            A ring. Like a semiring, but the first operation forms a commutative group, i.e. subtraction is also defined.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IBooleanRing`3">
            <summary>
            A Boolean ring; a ring where the second operation is idempotent.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ICommutativeRing`3">
            <summary>
            A ring where the second operation is commutative.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IIntegralDomain`3">
            <summary>
            A domain in which the product of two non-zero elements is also non-zero.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IIntegralDomain`3.IsZero(`0)">
            <summary>
            Returns whether an element <c>X</c> is the neutral element of the first operation of the structure, i.e. whether it is "zero". This is a special case of the general equatability of two elements.
            </summary>
            <param name="x">The element to check.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IGcdDomain`3">
            <summary>
            A domain in which every two elements have a greatest common divisor or, equivalently, a least common multiple, through an efficient algorithm for finding them might not exist.
            See <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IUniqueFactorizationDomain`3">
            <summary>
            A domain in which every element can be uniquely factored into a product of prime elements.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IEuclideanDomain`3">
            <summary>
            A domain which has an Euclidean division-function (every two elements <c>X</c> and <c>Y</c> can be divided, resulting in <c>Divide(X,Y) = Q * Y + R</c>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IEuclideanDomain`3.EuclideanDivide(`0,`0)">
            <summary>
            Performs Euclidean division on two elements <paramref name="x"/> and <paramref name="y"/> and returns a quotient <c>q</c> and a remainder <c>r</c> such that the following holds:
            <code>
                var (q, r) = r.Divide(x,y);
                x = y * q + r
            </code>
            if <c>r.IsZero(y)</c> is false.
            </summary>
            <param name="x">The divident.</param>
            <param name="y">The divisor.</param>
            <example>
            In the field of integers
            <code>
                r.Divide(138, 16) = (8, 10)
            </code>
            </example>
        </member>
        <member name="T:Nordril.Functional.Algebra.IField`3">
            <summary>
            A domain in which both operations form commutative groups, i.e. addition, multiplication, subtraction, and division (except for zero-divisors) are defined.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IFiniteField`3">
            <summary>
            A field with finitely many elements.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IFiniteField`3.Elements">
            <summary>
            Enumerates the finitely many elements of the field.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.ILattice`3">
            <summary>
            A lattice, having a meet- and join-operation, which are commutative, associative, idempotent, and connected via the absorption-law.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IBoundedLattice`3">
            <summary>
            A bounded lattice with a unique minimal and maximal element.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IDistributedLattice`3">
            <summary>
            A distributed latter where the join and meet distribute over each other.
            </summary>
            <remarks>
            We cannot specify that the first operation should also distribute over the second
            (in addition to the second distributing over the first) via inheriting from <see cref="T:Nordril.Functional.Algebra.ILeftDistributive`3"/> and <see cref="T:Nordril.Functional.Algebra.IRightDistributive`3"/> twice with <typeparamref name="TFirst"/> and <typeparamref name="TSecond"/>, since the C# forbids type parameter unification (<typeparamref name="TFirst"/> in the first instance of <see cref="T:Nordril.Functional.Algebra.ILeftDistributive`3"/> may be instantiated to the same type as <typeparamref name="TSecond"/> in the second instance of <see cref="T:Nordril.Functional.Algebra.ILeftDistributive`3"/>, etc.). One could work around this, but the workaround was considered clunky and inconvenient to users, so we consciously omit trying to model both distributive laws in favor of just one.
            </remarks>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.Ringlike`3">
            <summary>
            A value-level ringlike structure.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike`3.#ctor(`1,`2)">
            <summary>
            Creates a new ringlike structure.
            </summary>
            <param name="first">The first grouplike structure.</param>
            <param name="second">The second grouplike structure.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.Ringlike`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.Ringlike`3.Second">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.ContainsRinglike`3">
            <summary>
            A covariant product-wrapper around a grouplike structure.
            </summary>
            <typeparam name="TRinglike">The type of the ringlike to wrap.</typeparam>
            <typeparam name="TFirst">The type of first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of second grouplike structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.ContainsRinglike`3.Ringlike">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.ContainsRinglike`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.ContainsRinglike`3.Second">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.ContainsRinglike`3.#ctor(`0)">
            <summary>
            Creates a new instance. See also <see cref="M:Nordril.Functional.Algebra.Magma.AsProduct``2(``1)"/>.
            </summary>
            <param name="ringlike">The contained ringlike.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Ringlike">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.IRinglike`3"/>s.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.AsProduct``4(``1)">
            <summary>
            Wraps a grouplike structure in a single-element product so that it can be used in functions which expect products like <see cref="M:Nordril.Functional.Algebra.Ringlike.Zero``2(Nordril.Functional.Algebra.IContainsFirst{``1})"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike to wrap.</typeparam>
            <typeparam name="TFirst">The type of first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of second grouplike structure.</typeparam>
            <param name="m">The grouplike to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Plus``2(Nordril.Functional.Algebra.IContainsFirst{``1},``0,``0)">
            <summary>
            Performs the operation of the first grouplike structure, commonly called "addition".
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Mult``2(Nordril.Functional.Algebra.IContainsSecond{``1},``0,``0)">
            <summary>
            Performs the operation of the second grouplike structure, commonly called "multiplication".
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Zero``3(Nordril.Functional.Algebra.IRinglike{``0,``1,``2})">
            <summary>
            Returns the neutral element of the first grouplike structure, commonly called "zero".
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Zero``2(Nordril.Functional.Algebra.IContainsFirst{``1})">
            <summary>
            Returns the neutral element of the first grouplike structure, commonly called "zero".
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.One``2(Nordril.Functional.Algebra.IContainsSecond{``1})">
            <summary>
            Returns the neutral element of the second grouplike structure, commonly called "zero".
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.One``3(Nordril.Functional.Algebra.IRinglike{``0,``1,``2})">
            <summary>
            Returns the neutral element of the second grouplike structure, commonly called "zero".
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first groupike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Negate``2(Nordril.Functional.Algebra.IContainsFirst{``1},``0)">
            <summary>
            Returns the inverse element with respect to the first grouplike structure, typically called the "negation" of the element (as in subtraction).
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The element whose inverse to return.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Minus``2(Nordril.Functional.Algebra.IContainsFirst{``1},``0,``0)">
            <summary>
            Applies <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> of the first grouplike structure to the first element <paramref name="x"/> and the inverse of the second element <paramref name="y"/>, equivalent to "subtraction" in the case of addition.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The element.</param>
            <param name="y">The second element whose inverse to add to the first.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Reciprocal``2(Nordril.Functional.Algebra.IContainsSecond{``1},``0)">
            <summary>
            Returns the inverse element with respect to the second grouplike structure, typically called the "reciprocal" of the element (as in division).
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The element whose inverse to return.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ringlike.Divide``2(Nordril.Functional.Algebra.IContainsSecond{``1},``0,``0)">
            <summary>
            Applies <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> of the second grouplike structure to the first element <paramref name="x"/> and the inverse of the second element <paramref name="y"/>, equivalent to "division" in the case of multiplication.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The element.</param>
            <param name="y">The second element whose inverse to add to the first.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.NearRing`3">
            <summary>
            A value-level near-ring.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.NearRing`3.#ctor(`1,`2)">
            <summary>
            Creates a new near-ring.
            </summary>
            <param name="first">The first grouplike structure.</param>
            <param name="second">The second grouplike structure.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.NearRing`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.NearRing`3.Second">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Semiring`3">
            <summary>
            A value-level semiring.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semiring`3.#ctor(`1,`2)">
            <summary>
            Creates a new semiring.
            </summary>
            <param name="first">The first grouplike structure.</param>
            <param name="second">The second grouplike structure.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.Semiring`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.Semiring`3.Second">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Ring`3">
            <summary>
            A value-level ring.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Ring`3.#ctor(`1,`2)">
            <summary>
            Creates a new ring.
            </summary>
            <param name="first">The first grouplike structure.</param>
            <param name="second">The second grouplike structure.</param>
        </member>
        <member name="P:Nordril.Functional.Algebra.Ring`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.Ring`3.Second">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.BooleanRing">
            <summary>
            Extension methods for boolean rings.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.BooleanRing.Bool">
            <summary>
            The boolean ring (B,XOR,&amp;&amp;,false,true).
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.BooleanRing.BoolXorRing">
            <summary>
            The boolean ring (B,XOR,&amp;&amp;,false,true).
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.BooleanRing.BoolXorRing.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.BooleanRing.BoolXorRing.Second">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.EuclideanDomain">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/>s.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.EuclideanDomain.Integers">
            <summary>
            Gets the Euclidean domain of integers.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.EuclideanDomain.IntegerEuclideanDomain">
            <summary>
            The Euclidean domain of integers.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.EuclideanDomain.IntegerEuclideanDomain.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.EuclideanDomain.IntegerEuclideanDomain.Second">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.IntegerEuclideanDomain.EuclideanDivide(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.IntegerEuclideanDomain.IsZero(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.Mod``3(Nordril.Functional.Algebra.IEuclideanDomain{``0,``1,``2},``0,``0)">
            <summary>
            Performs the modulus-operation on two elements, returning the remainder of <see cref="M:Nordril.Functional.Algebra.IEuclideanDomain`3.EuclideanDivide(`0,`0)"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.Mod``4(Nordril.Functional.Algebra.IContainsRinglike{``1},``0,``0)">
            <summary>
            Performs the modulus-operation on two elements, returning the remainder of <see cref="M:Nordril.Functional.Algebra.IEuclideanDomain`3.EuclideanDivide(`0,`0)"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.EuclideanDivide``4(Nordril.Functional.Algebra.IContainsRinglike{``1},``0,``0)">
            <summary>
            Performs Euclidean division on two elements <paramref name="x"/> and <paramref name="y"/> and returns a quotient <c>q</c> and a remainder <c>r</c>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike structure.</typeparam>
            <typeparam name="TSecond">The type of the second grouplike structure.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The divident.</param>
            <param name="y">The divisor.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.Gcd``3(Nordril.Functional.Algebra.IEuclideanDomain{``0,``1,``2},``0,``0)">
            <summary>
            Gets the greatest common divisor of two elements in a <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/> via Euclid's algorithm. The GCD of two elements <c>X</c> and <c>Y</c> is the unique minimal principal ideal.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.Gcd``4(Nordril.Functional.Algebra.IContainsRinglike{``1},``0,``0)">
            <summary>
            Gets the greatest common divisor of two elements in a <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/> via Euclid's algorithm. The GCD of two elements <c>X</c> and <c>Y</c> is the unique minimal principal ideal.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.Lcm``3(Nordril.Functional.Algebra.IEuclideanDomain{``0,``1,``2},``0,``0)">
            <summary>
            Gets the least common multiple of two elements in a <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/> via Euclid's algorithm. The LCDM is defined as:
            <code>
                r.Mult(r.Gcd(x,y), r.Lcm(x,y)) == r.Mult(x,y)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
            <exception cref="T:System.DivideByZeroException">If <paramref name="x"/> or <paramref name="y"/> is zero.</exception>
        </member>
        <member name="M:Nordril.Functional.Algebra.EuclideanDomain.Lcm``4(Nordril.Functional.Algebra.IContainsRinglike{``1},``0,``0)">
            <summary>
            Gets the least common multiple of two elements in a <see cref="T:Nordril.Functional.Algebra.IEuclideanDomain`3"/> via Euclid's algorithm. The LCDM is defined as:
            <code>
                r.Mult(r.Gcd(x,y), r.Lcm(x,y)) == r.Mult(x,y)
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="r">The ringlike structure.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
            <exception cref="T:System.DivideByZeroException">If <paramref name="x"/> or <paramref name="y"/> is zero.</exception>
        </member>
        <member name="T:Nordril.Functional.Algebra.Field">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.IField`3"/>s.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Field.Double">
            <summary>
            The double-field with addition and multiplication.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Field.Decimal">
            <summary>
            The decimal-field with addition and multiplication.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.Field.DoubleField">
            <summary>
            The field of <see cref="T:System.Double"/>s, which works the same way as the Euclidean domain of integers, though the <see cref="M:Nordril.Functional.Algebra.IEuclideanDomain`3.EuclideanDivide(`0,`0)"/>-function may be numerically unstable.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Field.DoubleField.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.Field.DoubleField.Second">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.DoubleField.EuclideanDivide(System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.DoubleField.IsZero(System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.Field.DecimalField">
            <summary>
            The field of <see cref="T:System.Decimal"/>s, which works the same way as the Euclidean domain of integers, though the <see cref="M:Nordril.Functional.Algebra.IEuclideanDomain`3.EuclideanDivide(`0,`0)"/>-function may be numerically unstable.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.Field.DecimalField.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.Field.DecimalField.Second">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.DecimalField.EuclideanDivide(System.Decimal,System.Decimal)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.DecimalField.IsZero(System.Decimal)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.Average``3(System.Collections.Generic.IEnumerable{``0},Nordril.Functional.Algebra.IField{``0,``1,``2})">
            <summary>
            Computes the average value of a sequence iteratively using the operations of the field <paramref name="field"/>. See the <see cref="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Double})"/>-family of functions. The average of the empty sequence is defined as <see cref="M:Nordril.Functional.Algebra.Ringlike.Zero``3(Nordril.Functional.Algebra.IRinglike{``0,``1,``2})"/>.
            </summary>
            <param name="xs">The sequence to traverse.</param>
            <param name="field">The field whose operations to use.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.Average``4(System.Collections.Generic.IEnumerable{``0},Nordril.Functional.Algebra.IContainsRinglike{``1})">
            <summary>
            Computes the average value of a sequence iteratively using the operations of the field <paramref name="field"/>. See the <see cref="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Double})"/>-family of functions. The average of the empty sequence is defined as <see cref="M:Nordril.Functional.Algebra.Ringlike.Zero``3(Nordril.Functional.Algebra.IRinglike{``0,``1,``2})"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="xs">The sequence to traverse.</param>
            <param name="field">The field whose operations to use.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.WeightedAverage``3(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``0}},Nordril.Functional.Algebra.IField{``0,``1,``2})">
            <summary>
            Computes the weighted average value of a sequence iteratively using the operations of the field <paramref name="field"/>. See the <see cref="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Double})"/>-family of functions. The average of the empty sequence is defined as <see cref="M:Nordril.Functional.Algebra.Ringlike.Zero``2(Nordril.Functional.Algebra.IContainsFirst{``1})"/>.
            </summary>
            <param name="xs">The sequence to traverse.</param>
            <param name="field">The field whose operations to use.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Field.WeightedAverage``4(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``0}},Nordril.Functional.Algebra.IContainsRinglike{``1})">
            <summary>
            Computes the weighted average value of a sequence iteratively using the operations of the field <paramref name="field"/>. See the <see cref="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Double})"/>-family of functions. The average of the empty sequence is defined as <see cref="M:Nordril.Functional.Algebra.Ringlike.Zero``2(Nordril.Functional.Algebra.IContainsFirst{``1})"/>.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
            <typeparam name="TRinglike">The type of the ringlike structure.</typeparam>
            <typeparam name="TFirst">The type of the first grouplike operation.</typeparam>
            <typeparam name="TSecond">The type of the second groupike operation.</typeparam>
            <param name="xs">The sequence to traverse.</param>
            <param name="field">The field whose operations to use.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Lattice">
            <summary>
            Extension methods for lattices.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.Lattice.SetLattice`1">
            <summary>
            The set-lattice, with set-union as the meet and set-intersection as the join.
            </summary>
            <typeparam name="T">The type of elements in the sets.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Lattice.SetLattice`1.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Algebra.Lattice.SetLattice`1.Second">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Algebra.Lattice.SetLattice`1.Op(System.Collections.Generic.ISet{`0},System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasUnary`1">
            <summary>
            An algebraic structure supporting a unary operation with no further guaranteed properties.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasUnaryIdempotent`1">
            <summary>
            An algebraic structure with a unary operation which is idempotent.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IHasUnaryInvolution`1">
            <summary>
            An algebraic structure with a unary operation which is an involution, i.e.
            <code>
                m.UnaryOp(m.UnaryOp(X)) == X
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IUnary`1">
            <summary>
            An algebraic structure supporting a unary operation with no further guaranteed properties.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IUnary`1.UnaryOp(`0)">
            <summary>
            The unary operation. This operation should not change its operand.
            </summary>
            <param name="x">The operand.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IUnaryIdempotent`1">
            <summary>
            An algebraic structure with a unary operation which is idempotent.
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IUnaryInvolution`1">
            <summary>
            An algebraic structure with a unary operation which is an involution, i.e.
            <code>
                m.UnaryOp(m.UnaryOp(X)) == X
            </code>
            </summary>
            <typeparam name="T">The type of the carrier set.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.IAlternative`1">
            <summary>
            A subset of <see cref="T:Nordril.Functional.Category.IApplicative`1"/> that has a notion of "combining computations". It's up to the implementor to define how this combining works, but implementors should obey the following laws:
            <code>
                x.Empty().Alt(a) == a (left-neutrality of Empty)
                a.Alt(x.Empty()) == a (right-neutrality of Empty)
                a.Alt(b).Alt(c)  == a.Alt(b.Alt(c)) (associativity of Alt)
            </code>
            <see cref="T:Nordril.Functional.Category.IAlternative`1"/> is thus a <see cref="T:Nordril.Functional.Algebra.IHasMonoid`1"/> on <see cref="T:Nordril.Functional.Category.IApplicative`1"/>.
            Moreover, the implementor should obey
            <code>
                x.Empty().Ap(a) == x.Empty() (guard)
            </code>
            Additionally, if the implementor implements <see cref="T:Nordril.Functional.Category.IMonadPlus`1"/>, it should also obey:
            <code>
                x.Empty().Bind(f) == x.Empty()
            </code>
            </summary>
            <remarks>
            <see cref="T:Nordril.Functional.Category.IAlternative`1"/> serves two purposes: it functions as a monoid on instances of <see cref="T:Nordril.Functional.Category.IApplicative`1"/> and it provides a "guard"-function which can stop a computation if it's not fulfilled. This is done via <see cref="M:Nordril.Functional.Category.IAlternative`1.Empty"/>.
            </remarks>
            <typeparam name="TSource">The data contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IAlternative`1.Empty">
            <summary>
            Returns a computation with zero results. The this-value MUST NOT BE USED by implementors.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.IAlternative`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <summary>
            Combines two computations.
            </summary>
            <param name="x">The other computation.</param>
        </member>
        <member name="T:Nordril.Functional.Category.Alternative">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Alternative.Guard``1(System.Func{System.Boolean})">
            <summary>
            A guard-function with respect to <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/> and <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>. If the condition is not fulfilled, the computation does not proceed.
            </summary>
            <typeparam name="TResult">The type of the resultant <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.</typeparam>
            <param name="condition">The condition.</param>
            <returns>Either Pure(Unit) or Empty.</returns>
        </member>
        <member name="M:Nordril.Functional.Category.Alternative.AltSum``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Aggregates a sequence of <see cref="T:Nordril.Functional.Category.IAlternative`1"/>, combining the element from left to right via <see cref="M:Nordril.Functional.Category.IAlternative`1.Alt(Nordril.Functional.Category.IAlternative{`0})"/>. The accumulator is <see cref="M:Nordril.Functional.Category.IAlternative`1.Empty"/>.
            </summary>
            <typeparam name="TResult">The type of values in the <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.</typeparam>
            <typeparam name="TAlt">The type of the <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Alternative.Optional``1(Nordril.Functional.Category.IAlternative{``0})">
            <summary>
            Returns an <see cref="T:Nordril.Functional.Category.IAlternative`1"/> containing <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> its value, if present, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> otherwise.
            </summary>
            <typeparam name="TResult">The type of the value in <paramref name="alt"/>.</typeparam>
            <param name="alt">The <see cref="T:Nordril.Functional.Category.IAlternative`1"/> to check.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IApplicative`1">
            <summary>
            An applicative functor which supports applying multi-argument functions to containers.
            Implementations must fulfill the following (assuming that Pure(a) == X.Pure(a) for readability)
            for all a, f, g, h.
            <code>
                Pure(a).Ap(b => b) == Pure(a) (identity)
                Pure(a).Ap(Pure(f)) == Pure(f(a)) (homomorphism)
                Pure(a).Ap(f) == f.Ap(Pure(a => f(a))) (interchange)
                h.Ap(g).Ap(f) == h.Ap(g.Ap(f.Ap(Pure(comp)))) (composition)
                where
                   comp f2 f1 x = f2(f1(x)) 
            </code>
            </summary>
            <typeparam name="TSource">The data contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)">
            <summary>
            Wraps a value into an applicative. The this-value MUST NOT BE USED by implementors.
            </summary>
            <typeparam name="TResult">The type of the value to wrap.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <summary>
            Takes an applicative value and a function wrapped in an applicative value,
            and applies the function to this container.
            </summary>
            <typeparam name="TResult">The result type</typeparam>
            <param name="f">The wrapped function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.Applicative">
            <summary>
            Extensions for <see cref="T:Nordril.Functional.Category.IApplicative`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.ApF``2(Nordril.Functional.Category.IApplicative{System.Func{``0,``1}},Nordril.Functional.Category.IApplicative{``0})">
            <summary>
            <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/> with the arguments reversed,
            meaning that the function is applied to the argument, which reads more natural.
            </summary>
            <typeparam name="TSource">The argument type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="f">The applicative containing the function mapping the source type to the result type.</param>
            <param name="x">The applicative containing the source type.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.ApRight``2(Nordril.Functional.Category.IApplicative{``0},Nordril.Functional.Category.IApplicative{``1})">
            <summary>
            Performs the action <paramref name="x"/>, followed by the <paramref name="y"/> action, returning the result of the second action.
            </summary>
            <typeparam name="TSource">The return-type of the first action.</typeparam>
            <typeparam name="TResult">The return-type of the second action.</typeparam>
            <param name="x">The first action.</param>
            <param name="y">The second action.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.ApLeft``2(Nordril.Functional.Category.IApplicative{``0},Nordril.Functional.Category.IApplicative{``1})">
            <summary>
            Performs the action <paramref name="x"/>, followed by the <paramref name="y"/> action, returning the result of the first action.
            </summary>
            <typeparam name="TSource">The return-type of the first action.</typeparam>
            <typeparam name="TResult">The return-type of the second action.</typeparam>
            <param name="x">The first action.</param>
            <param name="y">The second action.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.Pure``2(``0)">
            <summary>
            Wraps an object in an applicative via <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            </summary>
            <typeparam name="TSource">The type of the object to wrap.</typeparam>
            <typeparam name="TResult">The type of the applicative to return.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.PureUnsafe``2(``0)">
            <summary>
            Wraps an object in an applicative via <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            The applicative in question does not have to posess a parameterless constuctor; instead, a call to <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/> with the this-pointer being null is forced.
            If the requested applicative uses the this-pointer in <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>, this will result in a <see cref="T:System.NullReferenceException"/>.
            </summary>
            <typeparam name="TSource">The type of the object to wrap.</typeparam>
            <typeparam name="TResult">The type of the applicative to return.</typeparam>
            <param name="x">The value to wrap.</param>
            <exception cref="T:System.NullReferenceException">If <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/> of <typeparamref name="TResult"/> uses the this-pointer.</exception>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.LiftA``3(System.Func{``0,``1,``2})">
            <summary>
            Lifts a binary function to take two applicative arguments.
            </summary>
            <example>
            <code>
                var x = Maybe.Just(5);
                var y = Maybe.Nothing&lt;int&gt;();
                Func&lt;int,int,int&gt; f = (x,y) => x + y;
                
                //f takes integer arguments, but we can apply it to two maybe-arguments,
                //with automatic unpacking and packing of the results, via liftA*.
                var result = f.LiftA2()(x, y);
            </code>
            </example>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.LiftA``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Lifts a ternary function to take three applicative arguments. See <see cref="M:Nordril.Functional.Category.Applicative.LiftA``3(System.Func{``0,``1,``2})"/>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the second argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.LiftA``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Lifts a quaternary function to take three applicative arguments. See <see cref="M:Nordril.Functional.Category.Applicative.LiftA``3(System.Func{``0,``1,``2})"/>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the second argument.</typeparam>
            <typeparam name="T4">The type of the second argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.WhereAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            An applicative/monadic filter operation which is a generalization of <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>. If the applicative is <see cref="T:Nordril.Functional.Data.Identity`1"/>, this function behaves identically to that in LINQ. The sequence is traversed via <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>.
            </summary>
            <example>
                //Computing the powerset (interpreting a sequence as a set).
                //Using the non-determinism monad of FuncList, every element is non-deterministically
                //both excluded and included, and the result is a FuncList containing as elements all possible
                //subsets of {1,2,3}.
                var new List&lt;int&gt; { 1, 2, 3}.WhereAp(x => new FuncList&lt;bool&gt; {false, true});
            </example>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TPredicate">The applicate-type of the predicate.</typeparam>
            <typeparam name="TResult">The applicative-type of the result. This should agree with <typeparamref name="TPredicate"/>.</typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="f">The filtering predicate. Elements for which it returns true are included, otherwise they're excluded.</param>
            <returns>The sequence, traversed left to right, using the applicative combining operation at each step.</returns>
            <exception cref="T:System.NullReferenceException">If the applicative in question does not implement <see cref="M:Nordril.Functional.Category.Applicative.Pure``2(``0)"/> correctly and uses the this-pointer.</exception>
            <exception cref="T:System.InvalidCastException">If <typeparamref name="TPredicate"/> and <typeparamref name="TResult"/> are incompatible.</exception>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.WhereApAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            The async-version of <see cref="M:Nordril.Functional.Category.Applicative.WhereAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TPredicate">The applicate-type of the predicate.</typeparam>
            <typeparam name="TResult">The applicative-type of the result. This should agree with <typeparamref name="TPredicate"/>.</typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="f">The filtering predicate. Elements for which it returns true are included, otherwise they're excluded.</param>
            <returns>The sequence, traversed left to right, using the applicative combining operation at each step.</returns>
            <exception cref="T:System.NullReferenceException">If the applicative in question does not implement <see cref="M:Nordril.Functional.Category.Applicative.Pure``2(``0)"/> correctly and uses the this-pointer.</exception>
            <exception cref="T:System.InvalidCastException">If <typeparamref name="TPredicate"/> and <typeparamref name="TResult"/> are incompatible.</exception>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})">
            <summary>
            An applicative/monadic <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/> operation. If the applicative is <see cref="T:Nordril.Functional.Data.Identity`1"/>, this function behaves identically to that in LINQ. The sequence is traversed via <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>.
            </summary>
            <example>
                //Map each element to itself and its negation
                //Using the non-determinism monad of FuncList, every element is non-deterministically
                //mapped to both values, and the result is a FuncList containing as elements all possible
                //combinations.
                var new List&lt;int&gt; { 1, 2, 3}.SelectAp(x => new FuncList&lt;bool&gt; {x, x*(-1)});
                
                //result: [1,2,3], [1,2,-3], [1,-2,3], [1,-2,-3], [-1,2,3], [-1,2,-3], [-1,-2,3], [-1,-2,-3]
            </example>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TResult">The type of the result-elements.</typeparam>
            <typeparam name="TResultList">The applicative-type of the result. This should agree with <typeparamref name="TResult"/></typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="f">The filtering predicate. Elements for which it returns true are included, otherwise they're excluded.</param>
            <returns>The sequence, traversed left to right, using the applicative combining operation at each step.</returns>
            <exception cref="T:System.NullReferenceException">If the applicative in question does not implement <see cref="M:Nordril.Functional.Category.Applicative.Pure``2(``0)"/> correctly and uses the this-pointer.</exception>
            <exception cref="T:System.InvalidCastException">If <typeparamref name="TResultList"/> and <typeparamref name="TResult"/> are incompatible.</exception>
        </member>
        <member name="M:Nordril.Functional.Category.Applicative.SelectApAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Category.IApplicative{``1}}})">
            <summary>
            The async-version of <see cref="M:Nordril.Functional.Category.Applicative.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})"/>
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TResult">The type of the result-elements.</typeparam>
            <typeparam name="TResultList">The applicative-type of the result. This should agree with <typeparamref name="TResult"/></typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="f">The filtering predicate. Elements for which it returns true are included, otherwise they're excluded.</param>
            <returns>The sequence, traversed left to right, using the applicative combining operation at each step.</returns>
            <exception cref="T:System.NullReferenceException">If the applicative in question does not implement <see cref="M:Nordril.Functional.Category.Applicative.Pure``2(``0)"/> correctly and uses the this-pointer.</exception>
            <exception cref="T:System.InvalidCastException">If <typeparamref name="TResultList"/> and <typeparamref name="TResult"/> are incompatible.</exception>
        </member>
        <member name="T:Nordril.Functional.Category.IArrow`2">
            <summary>
            A monoid in the category of strong profunctor whose morphisms are strong natural transformations, meaning the following:
            <code>
            X.LiftFirst().Then(f) == f.Then(X.LiftFirst()) (commutativity)<br />
            </code>
            The stereotypical example of an instance is <see cref="T:System.Func`2"/> (wrapped in <see cref="T:Nordril.Functional.Data.Fun`2"/>), with the methods having the "obvious" implementations.
            </summary>
            <typeparam name="TNeed">The type of values the arrow needs.</typeparam>
            <typeparam name="THave">The type of values the arrow contains.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IArrow`2.Make``2(System.Func{``0,``1})">
            <summary>
            Turns a function into an arrow. Implementors MUST NOT access the this-pointer and must obey the following:
            <code>
            X.Make(f) == X.Id().Promap(x => x, f)<br />
            </code>
            </summary>
            <typeparam name="TNeedResult">The type of the input of <paramref name="f"/>.</typeparam>
            <typeparam name="THaveResult">The type of the output of <paramref name="f"/>.</typeparam>
            <param name="f">The function to turn into an arrow.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IArrow`2.TogetherWith``2(Nordril.Functional.Category.IArrow{``0,``1})">
            <summary>
            Combines two arrows into an arrow which runs its first tuple-component through <c>this</c> and the second through <paramref name="that"/>. Also known as <c>(***)</c>. Implementors must obey the following:
            <code>
            X.TogetherWith(Y) == X.LiftFirst().Then(X.Make((x,y) => (y,x))).Then(Y.LiftFirst()).Then(X.Make((x,y) => (y,x)))
            </code>
            </summary>
            <typeparam name="TNeedRight">The type of values the second arrow needs.</typeparam>
            <typeparam name="THaveRight">The type of values the second arrow has.</typeparam>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="T:Nordril.Functional.Category.Arrow">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IArrow`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.Fanout``3(Nordril.Functional.Category.IArrow{``0,``1},Nordril.Functional.Category.IArrow{``0,``2})">
            <summary>
            Sends the same input to two arrows and returns the outputs of both as a tuple.
            Also known as <em>(&amp;&amp;&amp;)</em>
            </summary>
            <typeparam name="TNeed">The type of the input of the arrows.</typeparam>
            <typeparam name="THaveLeft">The type of the output of the first arrow.</typeparam>
            <typeparam name="THaveRight">The type of the output of the second arrow.</typeparam>
            <param name="arrow">The first arrow.</param>
            <param name="that">The second arrow.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.EitherOr``4(Nordril.Functional.Category.IArrowChoice{``0,``1},Nordril.Functional.Category.IArrowChoice{``2,``3})">
            <summary>
            Combines two arrows into one which can take the input of either one. Also known as <em>(+++)</em>
            </summary>
            <typeparam name="TNeedLeft">The type of the input of the first arrow.</typeparam>
            <typeparam name="THaveLeft">The type of the output of the first arrow.</typeparam>
            <typeparam name="TNeedRight">The type of the input of the second arrow.</typeparam>
            <typeparam name="THaveRight">The type of the output of the second arrow.</typeparam>
            <param name="arrow">The first arrow.</param>
            <param name="that">The second arrow.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.ToArrowChoice``2(Nordril.Functional.Category.ICategory{``0,``1})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.ICategory`2"/> to an <see cref="T:Nordril.Functional.Category.IArrowChoice`2"/>.
            </summary>
            <typeparam name="TNeed">The type of values the arrow needs.</typeparam>
            <typeparam name="THave">The type of values the arrow contains.</typeparam>
            <param name="arrow">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.ToArrowChoice``2(Nordril.Functional.Category.IChoice{``0,``1})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IChoice`2"/> to an <see cref="T:Nordril.Functional.Category.IArrowChoice`2"/>.
            </summary>
            <typeparam name="TNeed">The type of values the arrow needs.</typeparam>
            <typeparam name="THave">The type of values the arrow contains.</typeparam>
            <param name="arrow">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.ToArrow``2(Nordril.Functional.Category.ICategory{``0,``1})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.ICategory`2"/> to an <see cref="T:Nordril.Functional.Category.IArrow`2"/>.
            </summary>
            <typeparam name="TNeed">The type of values the arrow needs.</typeparam>
            <typeparam name="THave">The type of values the arrow contains.</typeparam>
            <param name="arrow">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.ToArrow``2(Nordril.Functional.Category.IProfunctor{``0,``1})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> to an <see cref="T:Nordril.Functional.Category.IArrow`2"/>.
            </summary>
            <typeparam name="TNeed">The type of values the arrow needs.</typeparam>
            <typeparam name="THave">The type of values the arrow contains.</typeparam>
            <param name="arrow">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Arrow.Fanin``3(Nordril.Functional.Category.IArrowChoice{``0,``2},Nordril.Functional.Category.IArrowChoice{``1,``2})">
            <summary>
            Creates an arrow that accepts the input of either of two arrows and returns the output (with both arrows having the same output type).
            Also known as <em>(|||)</em>.
            </summary>
            <typeparam name="TNeedLeft">The type of the result of the first arrow.</typeparam>
            <typeparam name="TNeedRight">The type of the result of the second arrow.</typeparam>
            <typeparam name="THave">The type of the result.</typeparam>
            <param name="arrow">The first arrow.</param>
            <param name="that">The second arrow.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IArrowChoice`2">
            <summary>
            An <see cref="T:Nordril.Functional.Category.IArrow`2"/> which also supports choosing a left or a right value.
            </summary>
            <typeparam name="TNeed">The type of values the arrow needs.</typeparam>
            <typeparam name="THave">The type of values the arrow contains.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.IAsyncApplicative`1">
            <summary>
            An <see cref="T:Nordril.Functional.Category.IApplicative`1"/> which supports asynchronous operations.
            </summary>
            <typeparam name="TSource">The type of the values contained in the applicative.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IAsyncApplicative`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            </summary>
            <typeparam name="TResult">The type of the value to wrap.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IAsyncApplicative`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the applicative.</param>
        </member>
        <member name="T:Nordril.Functional.Category.AsyncApplicative">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IAsyncApplicative`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.AsyncApplicative.ApAsync``2(System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncApplicative{``0}},Nordril.Functional.Category.IApplicative{System.Func{``0,System.Threading.Tasks.Task{``1}}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="x">The task which returns the source-applicative.</param>
            <param name="f">The function to apply to the applicative.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IAsyncFunctor`1">
            <summary>
            An <see cref="T:Nordril.Functional.Category.IFunctor`1"/> which supports asynchronous operations.
            </summary>
            <typeparam name="TSource">The type of the values contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IAsyncFunctor`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>.
            </summary>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="f">The function to apply to the function.</param>
        </member>
        <member name="T:Nordril.Functional.Category.AsyncFunctor">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IAsyncFunctor`1"/>
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.AsyncFunctor.MapAsync``2(System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncFunctor{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>.
            </summary>
            <typeparam name="TSource">The type of the source value.</typeparam>
            <typeparam name="TResult">The type of the result value.</typeparam>
            <param name="task">The source on whose result to run <see cref="M:Nordril.Functional.Category.IAsyncFunctor`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})"/>.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IAsyncMonad`1">
            <summary>
            An <see cref="T:Nordril.Functional.Category.IMonad`1"/> which supports asynchronous operations.
            </summary>
            <typeparam name="TSource">The type of the values contained in the monad.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IAsyncMonad`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the monad.</param>
        </member>
        <member name="T:Nordril.Functional.Category.AsyncMonad">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IAsyncMonad`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.AsyncMonad.BindAsync``3(System.Threading.Tasks.Task{``0},System.Func{``1,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``2}}})">
            <summary>
            The asynchronous version of <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TMonad">The monad on which to bind.</typeparam>
            <typeparam name="TSource">The type of the source value.</typeparam>
            <typeparam name="TResult">The type of the result value.</typeparam>
            <param name="task">The task on whose result to run <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/></param>
            <param name="f">The function to apply to the monad.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IBifunctor`2">
            <summary>
            A bifunctor that contains both <typeparamref name="TLeft"/> values and <typeparamref name="TRight"/> values.
            An example is a tuple.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IBifunctor`2.BiMap``2(System.Func{`0,``0},System.Func{`1,``1})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.BiMap(a => a, b => b) == X (identity)<br />
                X.BiMap(x => f(g(x)), x => h(i(x))) == X.BiMap(g, i).BiMap(f, h)(homomorphism) <br />
            </code>
            </summary>
            <typeparam name="TLeftResult">The type of the left result.</typeparam>
            <typeparam name="TRightResult">The type of the right result.</typeparam>
            <param name="f">The left function to apply to the functor.</param>
            <param name="g">The right function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.BifunctorExtensions">
            <summary>
            Extensions for <see cref="T:Nordril.Functional.Category.IBifunctor`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.LeftMap``3(Nordril.Functional.Category.IBifunctor{``0,``1},System.Func{``0,``2})">
            <summary>
            Maps over just the left part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/>.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <typeparam name="TLeftResult">The type of the left result.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.LeftMap``2(Nordril.Functional.Category.IBifunctor{``0,``1},System.Action{``0})">
            <summary>
            Applies an action to the left part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/> and returns it.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.RightMap``3(Nordril.Functional.Category.IBifunctor{``0,``1},System.Func{``1,``2})">
            <summary>
            Maps over just the right part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/>.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <typeparam name="TRightResult">The type of the right result.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.RightMap``2(Nordril.Functional.Category.IBifunctor{``0,``1},System.Action{``1})">
            <summary>
            Applies an action to the right part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/> and returns it.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.ICategory`2">
            <summary>
            A (morphism in a) category in the category-theoretical sense
            which goes from <typeparamref name="TNeed"/> to <typeparamref name="THave"/>.
            A category is a collection of objects (here: types) and morphisms between two objects (going from <typeparamref name="TNeed"/> to <typeparamref name="THave"/>).
            The stereotypical example of an instance is <see cref="T:System.Func`2"/> (wrapped in <see cref="T:Nordril.Functional.Data.Fun`2"/>), with the methods having the "obvious" implementations.
            </summary>
            <typeparam name="TNeed">The type of the source of the morphism.</typeparam>
            <typeparam name="THave">The type of the result of the morphism.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.ICategory`2.Id``1">
            <summary>
            Creates the identity-morphism. Implementors MUST NOT access the this-pointer and must obey the following:
            <code>
            X.Id().Then(Y) == X (left-identity of Id)<br />
            X.Then(Y.Id()) == X (right-identity of Id)<br />
            </code>
            </summary>
            <typeparam name="THaveResult">The type of the source/target of the identity-morphism.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.ICategory`2.Then``1(Nordril.Functional.Category.ICategory{`1,``0})">
            <summary>
            Concatenates a second morphism to this first and returns the resultant, combined morphism. Implementors must obey the following:
            <code>
            X.Then(Y).Then(Z) == X.Then(Y.Then(Z)) (associativity)<br />
            </code>
            </summary>
            <typeparam name="THaveResult">The type of the result of the second morphism.</typeparam>
            <param name="that">The second morphism.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IChoice`2">
            <summary>
            A <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> which can be turned into a "left"- and "right"-choice, with the typical example
            being lifting a function <c>a -&gt; b</c> into a function <c>Either&lt;a, c&gt; -&gt; Either&lt;b, c&gt;</c> which runs the original function
            if the input-argument is a left-value and just passes a right-value along unchanged. The right-choice is analogous.
            Implementors must fulfill the following laws:
            <code>
            todo
            </code>
            </summary>
            <typeparam name="TNeed">The type of the input.</typeparam>
            <typeparam name="THave">The type of the output.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IChoice`2.ChooseLeft``1">
            <summary>
            Lift the <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> into <see cref="T:Nordril.Functional.Data.Either`2"/> by mapping it over its left-value.
            </summary>
            <typeparam name="TRight">The unchanged right-value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IChoice`2.ChooseRight``1">
            <summary>
            Lift the <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> into <see cref="T:Nordril.Functional.Data.Either`2"/> by mapping it over its right-value.
            </summary>
            <typeparam name="TLeft">The unchanged left-value.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.IComonad`1">
            <summary>
            A comonad, which is the categorical dual of a <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            Whereas monads support the wrapping of values, comonads support their unwrapping.
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IComonad`1.Extract">
            <summary>
            Extracts a new value from the comonad.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.IComonad`1.Extend``1(System.Func{Nordril.Functional.Category.IComonad{`0},``0})">
            <summary>
            Takes a function that extracts values from a comonad and chains it to this comonad by wrapping its result into a comonad.
            Implementros must fulfill the following for all X and f, g:
            <code>
                X.Extend(x => x.Extract()) = id (comonadic left-identity)
                X.Extend(f).Extract() = f (comonadic right-identity)
                X.Extend(g).Extend(f) = X.Extend(x => f(x.Extend(g))) (comonadic associativity)
            </code>
            Alternately, one can state these laws via Cokleisli composition =>=:
            <code>
                f =>= (x => x.Extract() = f (comonadic left-identity*)
                (x => x.Extract()) =>= f = f (comonadic right-identity*)
                (f =>= g) =>= h = f =>= (g =>= h) (comonadic associativity*)
            </code>
            For more detail, see https://hackage.haskell.org/package/comonad.
            </summary>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="f">The function to chain to the comonad.</param>
        </member>
        <member name="T:Nordril.Functional.Category.ComonadExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IComonad`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.ComonadExtensions.Duplicate``1(Nordril.Functional.Category.IComonad{``0})">
            <summary>
            The dual of <see cref="M:Nordril.Functional.Category.MonadExtensions.Join``1(Nordril.Functional.Category.IMonad{Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TSource">The type of values produced by the comonad.</typeparam>
            <param name="m">The comonad to duplicate.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ComonadExtensions.Comp``3(System.Func{Nordril.Functional.Category.IComonad{``0},``1},System.Func{Nordril.Functional.Category.IComonad{``1},``2})">
            <summary>
            Concatenates two comonad-functions.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TResult1">The intermediate result type.</typeparam>
            <typeparam name="TResult2">The funal result type.</typeparam>
            <param name="f">The first comonad-function.</param>
            <param name="g">The second comonad-function.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IContravariant`1">
            <summary>
            A contravariant functor. A contravariant functor is a functor that <em>needs</em> values of type <typeparamref name="TSource"/>
            instead of containing them.
            </summary>
            <typeparam name="TSource">The of the required values.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IContravariant`1.ContraMap``1(System.Func{``0,`0})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.ContraMap(a => a) == X (identity)
                X.ContraMap(a => g(f(a))) == X.Map(g).Map(f) (contravariant homomorphism)
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IContravariantApplicative`1">
            <summary>
            An <see cref="T:Nordril.Functional.Category.IPhantomFunctor`1"/> that is also an <see cref="T:Nordril.Functional.Category.IApplicative`1"/>.
            The stereotypical example is <see cref="T:Nordril.Functional.Data.Const`3"/>, which can use the <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/>-instance of the real value to put in a neutral element for <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            </summary>
            <typeparam name="TSource">The phantom type.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductFirst`1">
            <summary>
            A coproduct having a first component.
            </summary>
            <typeparam name="T1">The type of the first component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductFirst`1.IsFirst">
            <summary>
            Returns true iff the coproduct contains the first component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductFirst`1.First">
            <summary>
            Returns the first component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductSecond`1">
            <summary>
            A coproduct having a second component.
            </summary>
            <typeparam name="T2">The type of the second component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductSecond`1.IsSecond">
            <summary>
            Returns true iff the coproduct contains the second component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductSecond`1.Second">
            <summary>
            Returns the second component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductThird`1">
            <summary>
            A coproduct having a third component.
            </summary>
            <typeparam name="T3">The type of the third component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductThird`1.IsThird">
            <summary>
            Returns true iff the coproduct contains the third component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductThird`1.Third">
            <summary>
            Returns the third component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductFourth`1">
            <summary>
            A coproduct having a fourth component.
            </summary>
            <typeparam name="T4">The type of the fourth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductFourth`1.IsFourth">
            <summary>
            Returns true iff the coproduct contains the fourth component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductFourth`1.Fourth">
            <summary>
            Returns the fourth component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductFifth`1">
            <summary>
            A coproduct having a fifth component.
            </summary>
            <typeparam name="T5">The type of the fifth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductFifth`1.IsFifth">
            <summary>
            Returns true iff the coproduct contains the fifth component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductFifth`1.Fifth">
            <summary>
            Returns the fifth component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductSixth`1">
            <summary>
            A coproduct having a sixth component.
            </summary>
            <typeparam name="T6">The type of the sixth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductSixth`1.IsSixth">
            <summary>
            Returns true iff the coproduct contains the sixth component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductSixth`1.Sixth">
            <summary>
            Returns the sixth component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductSeventh`1">
            <summary>
            A coproduct having a seventh component.
            </summary>
            <typeparam name="T7">The type of the seventh component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductSeventh`1.IsSeventh">
            <summary>
            Returns true iff the coproduct contains the seventh component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductSeventh`1.Seventh">
            <summary>
            Returns the seventh component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.ICoproductEigth`1">
            <summary>
            A coproduct having an eigth component.
            </summary>
            <typeparam name="T8">The type of the eigth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductEigth`1.IsEigth">
            <summary>
            Returns true iff the coproduct contains the eigth component.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Category.ICoproductEigth`1.Eigth">
            <summary>
            Returns the eigth component.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.IEvaluator`3">
            <summary>
            An evaluator which can run an evaluation on a value of type <typeparamref name="TSource"/> and return a result
            of type <typeparamref name="TResult"/>.
            An example would be an expression tree which is reduced to a value.
            </summary>
            <typeparam name="TSource">The type of objects which this evaluator can evaluate.</typeparam>
            <typeparam name="TResult">The type of the result, if the evaluation is successful.</typeparam>
            <typeparam name="TError">The type of the error, if the evaluation is unsuccessful.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IEvaluator`3.Evaluate(`0)">
            <summary>
            Evaluates a <typeparamref name="TSource"/> and returns a <typeparamref name="TResult"/>.
            The evaluation may fail, and in that case, the method must return a <typeparamref name="TError"/>.
            </summary>
            <param name="arg">The value to evaluate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFilterable`2">
            <summary>
            Filterable data structures. A filterable structure supports a <see cref="M:Nordril.Functional.Category.IFilterable`2.Filter(System.Func{`1,System.Boolean})"/>-method which returns a filtered copy of the structure, with exactly the elements which fulfill a predicate.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TSource">The type of element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFilterable`2.Filter(System.Func{`1,System.Boolean})">
            <summary>
            Filters the container's elements, leaving the original unchanged and returning a version of the container which have the same structure as the original, but only with those elements which fulfill <paramref name="f"/>. What "leaving out elements" means exactly, depends on the implementor.
            </summary>
            <param name="f">The predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.ISemifilterable`2">
            <summary>
            Filterable data structures which do not support the removal of all elements. This is a weaker form of <see cref="T:Nordril.Functional.Category.IFilterable`2"/> which does not support returning empty data structures if all elements have been excluded, but returns <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> instead.
            An example is <see cref="T:Nordril.Functional.Data.Tree`1"/>, which cannot represent empty trees, but which still supports a kind of filtering of its nodes.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TSource">The type of element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.ISemifilterable`2.Semifilter(System.Func{`1,System.Boolean})">
            <summary>
            Filters the container's elements, leaving the original unchanged and returning a version of the container which have the same structure as the original, but only with those elements which fulfill <paramref name="f"/>. What "leaving out elements" means exactly, depends on the implementor.
            If all elements have been excluded by <paramref name="f"/>, <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> is returned.
            </summary>
            <param name="f">The predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFilterable`1">
            <summary>
            Filterable data structures where elements can be both changed, as with <see cref="T:Nordril.Functional.Category.IFunctor`1"/>, but also removed.
            </summary>
            <typeparam name="TSource">The type of the elements in the container.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFilterable`1.MapMaybe``1(System.Func{`0,Nordril.Functional.Data.Maybe{``0}})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.MapMaybe(x => Maybe.Just(f(x)) == X.Map(f) (conservation)<br />
                X.MapMaybe(f).MapMaybe(g) == X.MapMaybe(f.Bind(g).ToMaybe()) (composition) <br />
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFoldable`1">
            <summary>
            Data structures that suppoort folding, i.e. aggregation over their members.
            <see cref="T:Nordril.Functional.Category.IFoldable`1"/> is basically just <see cref="T:System.Collections.Generic.IEnumerable`1"/>, with extra functions.
            </summary>
            <typeparam name="TSource">The type of the values contained in the data structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFoldable`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <summary>
            Maps each element of the structure to a monoid and then combines the elements
            using the monoid's <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> operation.
            </summary>
            <param name="monoid">The monoid dictionary that should be used.</param>
            <param name="f">The function that maps an element to a monoid.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IFoldable`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <summary>
            Right-associative fold of the data structure.
            </summary>
            <typeparam name="TResult">The result type of the fold.</typeparam>
            <param name="f">The aggregation function, which takes an element of the structure and the current accumulator value,
            and returns the new accumulator value.</param>
            <param name="accumulator">The initial accumulator value.</param>
        </member>
        <member name="T:Nordril.Functional.Category.Foldable">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IFoldable`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Foldable.FoldMap``2(Nordril.Functional.Category.IFoldable{``0},System.Func{``1},System.Func{``0,``1})">
            <summary>
            Maps each element of the structure to a monoid and then combines the elements
            using the monoid's <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/> operation.
            </summary>
            <typeparam name="TSource">The type of elements contained in <paramref name="foldable"/>.</typeparam>
            <typeparam name="TMonoid">The monoid to which to mape the elements.</typeparam>
            <param name="foldable">The object to fold.</param>
            <param name="empty">The neutral element of the monoid.</param>
            <param name="f">The function that maps an element to a monoid.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Foldable.TraverseDiscard``3(Nordril.Functional.Category.IFoldable{``1},System.Func{``1,Nordril.Functional.Category.IApplicative{``2}})">
            <summary>
            A limited form of traversal which traverses a <see cref="T:Nordril.Functional.Category.IFoldable`1"/> structure and discards the results.
            </summary>
            <typeparam name="TApplicative">The type of the applicative.</typeparam>
            <typeparam name="TSource">The type of the element in the input structure.</typeparam>
            <typeparam name="TResult">The type of the result of the action.</typeparam>
            <param name="foldable">The object to fold.</param>
            <param name="f">The function to apply to each contained element.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Foldable.TraverseDiscard``2(Nordril.Functional.Category.IFoldable{``0},System.Type,System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})">
            <summary>
            A limited form of traversal which traverses a <see cref="T:Nordril.Functional.Category.IFoldable`1"/> structure and discards the results.
            </summary>
            <typeparam name="TSource">The type of the element in the input structure.</typeparam>
            <typeparam name="TResult">The type of the result of the action.</typeparam>
            <param name="applicative">The type of the applicative.</param>
            <param name="foldable">The object to fold.</param>
            <param name="f">The function to apply to each contained element.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFunctor`1">
            <summary>
            A functor. A functor is a container that contains 0 or more instances of <typeparamref name="TSource"/> and the only thing it supports is applying a function to each of those elements.
            One can apply functions to functors to change their contained type.
            </summary>
            <typeparam name="TSource">The type of values contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.Map(a => a) == X (identity)<br />
                X.Map(a => g(f(a))) == X.Map(f).Map(g) (homomorphism) <br />
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.FunctorExtensions">
            <summary>
            Extensions for the <see cref="T:Nordril.Functional.Category.IFunctor`1"/> class.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.FunctorExtensions.Void``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Erases the contents of a functor.
            </summary>
            <typeparam name="TSource">The source type of the functor.</typeparam>
            <param name="f">The functor.</param>
        </member>
        <member name="M:Nordril.Functional.Category.FunctorExtensions.Map``1(Nordril.Functional.Category.IFunctor{``0},System.Action{``0})">
            <summary>
            Applies an action to a functor and returns it.
            The action is presumable mutating.
            </summary>
            <typeparam name="TSource">The source type of the functor.</typeparam>
            <param name="f">The functor.</param>
            <param name="a">The action to apply to the values in the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IKeyedContravariant`2">
            <summary>
            A keyed contravariant functor. A contravariant functor is a functor that <em>needs</em> keys of type <typeparamref name="TKey"/> and values of type <typeparamref name="TSource"/> instead of containing them.
            </summary>
            <typeparam name="TKey">The type of keys needed by the functor.</typeparam>
            <typeparam name="TSource">The type of values needed by the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IKeyedContravariant`2.ContraMapWithKey``1(System.Func{`0,``0,`1})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            The first argument of the function is the key associated with the value.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.ContraMap((k, a) => a) == X (identity)<br />
                X.ContraMap((k, a) => g(k, f(k, a))) == X.Map(g).Map(f) (contravariant homomorphism)<br />
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IKeyedFunctor`2">
            <summary>
            A keyed functor, meaning a container which not only has values of type <typeparamref name="TSource"/>, but also immutable keys of type <typeparamref name="TKey"/> which the mapping-function may use as input.
            </summary>
            <typeparam name="TKey">The type of keys contained in the functor.</typeparam>
            <typeparam name="TSource">The type of values contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IKeyedFunctor`2.MapWithKey``1(System.Func{`0,`1,``0})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            The first argument of the function is the key associated with the value.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.Map((k,a) => a) == X (identity)<br />
                X.Map((k,a) => g(k, f(k, a))) == X.Map(f).Map(g) (homomorphism)<br />
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonad`1">
            <summary>
            A monad. Monads, in addition to wrapping values (via <see cref="T:Nordril.Functional.Category.IApplicative`1"/>
            and mapping over their contained values (via <see cref="T:Nordril.Functional.Category.IFunctor`1"/> support temporarily
            unpacking their contained values and re-packing them via the <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>
            operator. Unlike <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>,
            this allows dynamically controlling the computational path at runtime, instead of just applying a fixed
            function over one of more wrapped arguments.
            </summary>
            <typeparam name="TSource">The type of the values contained in the monad.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <summary>
            Unpacks the value(s) contained in this monad and applies a function to them.
            Bind corresponds to chaining functions, with the addition of the monadic context.
            Implementors must fulfill the following laws:
            <code>
                Pure(a).Bind(f) == f(a) (left identity of pure)<br />
                X.Bind(a =&gt; Pure(a)) = X (right identity of pure)<br />
                f.Bind(x => g(x).Bind(h)) == f.Bind(g).Bind(h) (associativity) <br />
            </code>
            These laws are identical to the laws of <see cref="T:Nordril.Functional.Algebra.IHasMonoid`1"/>, except for the
            type variable in <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.MonadExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Then``2(Nordril.Functional.Category.IMonad{``0},System.Func{``0,Nordril.Functional.Category.IMonad{``1}})">
            <summary>
            A more readable alias to <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="a">The value containing the source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.ThenM``3(System.Func{``0,Nordril.Functional.Category.IMonad{``1}},System.Func{``1,Nordril.Functional.Category.IMonad{``2}})">
            <summary>
            Chains two monad-producing functions by executing the first, then the second, gluing them together using
            <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>. The monadic equivalent of
            <see cref="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})"/>.
            </summary>
            <typeparam name="TSource">The input of the first function.</typeparam>
            <typeparam name="TResult1">The output of the first function (wrapped in a monad) and the input of the second.</typeparam>
            <typeparam name="TResult2">The output of the second function (wrapped in a monad).</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.AfterM``3(System.Func{``1,Nordril.Functional.Category.IMonad{``2}},System.Func{``0,Nordril.Functional.Category.IMonad{``1}})">
            <summary>
            Chains two monad-producing functions by executing the second, then the first, gluing them together using
            <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>. The monadic equivalent of
            <see cref="M:Nordril.Functional.F.After``3(System.Func{``1,``2},System.Func{``0,``1})"/>.
            </summary>
            <typeparam name="TSource">The input of the second function.</typeparam>
            <typeparam name="TResult1">The output of the first function (wrapped in a monad) and the input of the second.</typeparam>
            <typeparam name="TResult2">The output of the second function (wrapped in a monad).</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Then``2(Nordril.Functional.Category.IMonad{``0},Nordril.Functional.Category.IMonad{``1})">
            <summary>
            Extracts the value(s) from the source and replaces it with another one, ignoring the values of the source.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="a">The value containing the source.</param>
            <param name="b">The value containing the result.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Comp``3(System.Func{``0,Nordril.Functional.Category.IMonad{``1}},System.Func{``1,Nordril.Functional.Category.IMonad{``2}})">
            <summary>
            Concatenates two monad-functions.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TResult1">The intermediate result type.</typeparam>
            <typeparam name="TResult2">The funal result type.</typeparam>
            <param name="f">The first monad function.</param>
            <param name="g">The second monad function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Join``1(Nordril.Functional.Category.IMonad{Nordril.Functional.Category.IMonad{``0}})">
            <summary>
            Flattens the structure of a monad. The following holds for all X and f, given a correctly implemented
            <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/> and
            <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>:
            <code>
                X.Map(x => x.Join()).Join() = X.Join().Join()
                X.Map(x => x.Pure()).Join() = X.Pure().Join() = id
                X.Map(x => x.Map(f)).Join() = X.Join().Map(f)
            </code>
            </summary>
            <typeparam name="T">The type in the monad.</typeparam>
            <param name="a">The monad to flatten.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.AggregateM``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,``2})">
            <summary>
            A monadic version of <see cref="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})"/> which aggregates a sequence <paramref name="xs"/> with a monadic function <paramref name="f"/> and an accumulator <paramref name="acc"/>.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TAcc">The accumulator type.</typeparam>
            <typeparam name="TMonadAcc"><typeparamref name="TAcc"/>, wrapped in an <see cref="T:Nordril.Functional.Category.IMonad`1"/>.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="acc">The initial accumulator.</param>
            <param name="f">The folding function taking the aggregator and a sequence-element, and returning a monadic accumulator-value.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.UnfoldM``1(Nordril.Functional.Category.IMonad{Nordril.Functional.Data.Maybe{``0}})">
            <summary>
            A monadic <see cref="M:Nordril.Functional.CollectionExtensions.Unfold``2(``0,System.Func{``0,Nordril.Functional.Data.Maybe{System.ValueTuple{``0,``1}}})"/> which generates a sequence each time the <paramref name="seed"/>-value evaluates to <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.<br />
            Equivalent to:
            <code>
            while (seed().TryGetValue(_, y)) { yield return y; }
            </code>
            </summary>
            <typeparam name="TSource">The type of the seed/generated elements.</typeparam>
            <param name="seed">The monadic seed-value.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.WhileM``1(Nordril.Functional.Category.IMonad{System.Boolean},Nordril.Functional.Category.IMonad{``0})">
            <summary>
            Runs <paramref name="condition"/> repeatedly as long as it returns <c>true</c>, and runs <paramref name="body"/> each time, collecting the results.<br />
            Equivalent to:
            <code>
            while (condition()) {
                yield return body();
            }
            </code>
            </summary>
            <typeparam name="TSource">The type of the seed/generated elements.</typeparam>
            <param name="condition">The monadic condition.</param>
            <param name="body">The monadic body.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonadMorph`4">
            <summary>
            A functor in the category of monads which offers the counterpart to <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.Lift(`0)"/>.
            </summary>
            <remarks>
            <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.Lift(`0)"/> and <see cref="M:Nordril.Functional.Category.IMonadMorph`4.Hoist(`2)"/> are two ways of arriving at the same destination. If we have a value of type <c>A</c>, a monad <c>M&lt;A&gt;</c>, and a monad-transformer <c>T&lt;I, M,A&gt;</c>, we can go from <c>A</c> to <c>T&lt;I, M,A&gt;</c> over two "paths", as illustrated by this ASCII-diagram:
            <code>
               A -----[M.Pure]----&gt; M&lt;A&gt;<br />
               |                     |<br />
            [I.Pure]             [T.Lift]<br />
               |                     |<br />
               v                     v<br />
              I&lt;A&gt; --[T.Hoist]--&gt; T&lt;M,A&gt;<br />
            </code>
            That is, if we have, say, a value of type <see cref="T:System.Int32"/>, a monad <see cref="T:Nordril.Functional.Data.Io`1"/>, and a transformer <see cref="T:Nordril.Functional.Data.MaybeT`4"/> (which is the transformer-version of <see cref="T:Nordril.Functional.Data.Maybe`1"/>), then we can either
            <list type="number">
                <item>wrap the <see cref="T:System.Int32"/> into <see cref="T:Nordril.Functional.Data.Io`1"/> and then into <see cref="T:Nordril.Functional.Data.MaybeT`4"/> via <see cref="T:Nordril.Functional.Category.IMonadTransformer`4"/>, or</item>
                <item>wrap the <see cref="T:System.Int32"/> into <see cref="T:Nordril.Functional.Data.Maybe`1"/>, and then into <see cref="T:Nordril.Functional.Data.MaybeT`4"/> via <see cref="M:Nordril.Functional.Category.IMonadMorph`4.Hoist(`2)"/>.</item>
            </list>
            <c>lift</c> is thus used to lift "unrelated" computations into a monad transformer (like <see cref="T:Nordril.Functional.Data.Io`1"/> into <see cref="T:Nordril.Functional.Data.MaybeT`4"/>), whereas <c>hoist</c> is used to lift the "basic" version of computation into its transformer-form (like <see cref="T:Nordril.Functional.Data.Maybe`1"/> into <see cref="T:Nordril.Functional.Data.MaybeT`4"/>).
            <br />
            Formally, this interface is one morphism in a functor in the category of monads.
            </remarks>
            <typeparam name="TUnlifted">The unlifted monadic value (e.g. <c>IO&lt;int&gt;</c>). This is used only by <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.Lift(`0)"/>.</typeparam>
            <typeparam name="TLifted">The type of the overall monadic value, e.g. <c>IO&lt;Maybe&lt;int&gt;&gt;</c>.</typeparam>
            <typeparam name="TInner">The inner monadic value, e.g. <c>Maybe&lt;int&gt;</c>.</typeparam>
            <typeparam name="TSource">The innermost source-type.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadMorph`4.Hoist(`2)">
            <summary>
            Hoist a value from the base form of the monad into its transformer-form, wrapping it, effectively, in a second monad.
            </summary>
            <param name="inner">The value in the inner monad to hoist.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonadPlus`1">
            <summary>
            Monads that support choice (see <see cref="M:Nordril.Functional.Category.IMonadPlus`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})"/>) in addition to failure (see <see cref="M:Nordril.Functional.Category.IMonadZero`1.Mzero"/>).
            </summary>
            <typeparam name="T">The type of the contained elements.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadPlus`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <summary>
            Adds two monad values. Implementors must fulfill the following for all X and a, b, c, and k:
            <code>
                X.Mzero.Mplus(a) = a (left identity)<br />
                a.Mplus(X.mzero) = a (right identity)<br />
                a.Mplus(b).Mplus(c) = a.Mplus(b.Mplus(c)) (associativity)<br />
                a.Mplus(b).Bind(k) = a.Bind(k).Mplus(b.Bind(k)) (left-distribution)<br />
            </code>
            </summary>
            <param name="that">The second argument.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonadTransformer`4">
            <summary>
            A monad transformer which wraps an inner monad (<typeparamref name="TInner"/>) in an outer monad (<typeparamref name="TLifted"/>), combining their semantics.
            Monad transformers are, here, also monads, enabling the usage of <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>, and <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>, though they also provide monad-transformer-versions of these functions suffixed with "T". The only unique method of a monad transformer is <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.Lift(`0)"/>, which takes a value from the unlifted monad and lifts it.
            </summary>
            <remarks>
            Monad transformers allow one to combine the functionality of a whole list/stack of monads, e.g. <see cref="T:Nordril.Functional.Data.Reader`2"/>, <see cref="T:Nordril.Functional.Data.Writer`3"/>, and <see cref="T:Nordril.Functional.Data.State`2"/> in a single computation, though, in general, the order of wrapping matters, meaning <c>OuterT&lt;InnerT&lt;A&gt;&gt;</c> might have different semantics than <c>InnerT&lt;OuterT&lt;A&gt;&gt;</c>. Since monad transformers require higher-kinded types, the type parameters one has to specify are somewhat cumbersome due to CLR-limitations.
            </remarks>
            <typeparam name="TUnlifted">The unlifted monadic value (e.g. <c>IO&lt;int&gt;</c>). This is used only by <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.Lift(`0)"/>.</typeparam>
            <typeparam name="TLifted">The type of the overall monadic value, e.g. <c>IO&lt;Maybe&lt;int&gt;&gt;</c>.</typeparam>
            <typeparam name="TInner">The inner monadic value, e.g. <c>Maybe&lt;int&gt;</c>.</typeparam>
            <typeparam name="TSource">The innermost source-type.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadTransformer`4.PureT``4(``3)">
            <summary>
            The monad-transformer-version of <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            </summary>
            <typeparam name="TUnliftedResult">The unlifted type of the result.</typeparam>
            <typeparam name="TLiftedResult">The lifted type of the result.</typeparam>
            <typeparam name="TInnerResult">The inner type of the result.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadTransformer`4.MapT``4(System.Func{`3,``3})">
            <summary>
            The monad-transformer-version of <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>.
            </summary>
            <typeparam name="TUnliftedResult">The unlifted type of the result.</typeparam>
            <typeparam name="TLiftedResult">The lifted type of the result.</typeparam>
            <typeparam name="TInnerResult">The inner type of the result.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The pure function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadTransformer`4.ApT``7(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,System.Func{`3,``6}})">
            <summary>
            The monad-transformer-version of <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>.
            </summary>
            <typeparam name="TUnliftedFunc">The unlifted type of the function.</typeparam>
            <typeparam name="TLiftedFunc">The lifted type of the function.</typeparam>
            <typeparam name="TInnerFunc">The inner type of the function.</typeparam>
            <typeparam name="TUnliftedResult">The unlifted type of the result.</typeparam>
            <typeparam name="TLiftedResult">The lifted type of the result.</typeparam>
            <typeparam name="TInnerResult">The inner type of the result.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The monadic value containing the function to apply to this monadic value.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadTransformer`4.BindT``4(System.Func{`3,Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3}})">
            <summary>
            The monad-transformer-version of <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TUnliftedResult">The unlifted type of the result.</typeparam>
            <typeparam name="TLiftedResult">The lifted type of the result.</typeparam>
            <typeparam name="TInnerResult">The inner type of the result.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The monadic function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadTransformer`4.Lift(`0)">
            <summary>
            Lifts a value from an inner monad into this monad transformer, wrapping it, effectively, in a second monad.
            </summary>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Category.MonadTransformer">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IMonadTransformer`4"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.MonadTransformer.MakeMap``5(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3})">
            <summary>
            Creates a <see cref="T:System.Func`3"/> which runs <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.MapT``4(System.Func{`3,``3})"/>, doing the type variable replacement at runtime.
            </summary>
            <typeparam name="TUnlifted">The unlifted value.</typeparam>
            <typeparam name="TLifted">The lifted value, containing the inner value.</typeparam>
            <typeparam name="TInner">The inner value.</typeparam>
            <typeparam name="TSource">The raw value.</typeparam>
            <typeparam name="TResult">The result-type.</typeparam>
            <param name="transformer">The transformer whose <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.MapT``4(System.Func{`3,``3})"/>-function to use.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadTransformer.MakePure``5(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3})">
            <summary>
            Creates a <see cref="T:System.Func`3"/> which runs <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.PureT``4(``3)"/>, doing the type variable replacement at runtime.
            </summary>
            <typeparam name="TUnlifted">The unlifted value.</typeparam>
            <typeparam name="TLifted">The lifted value, containing the inner value.</typeparam>
            <typeparam name="TInner">The inner value.</typeparam>
            <typeparam name="TSource">The raw value.</typeparam>
            <typeparam name="TResult">The result-type.</typeparam>
            <param name="transformer">The transformer whose <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.PureT``4(``3)"/>-function to use.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadTransformer.MakeAp``5(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3})">
            <summary>
            Creates a <see cref="T:System.Func`3"/> which runs <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.ApT``7(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,System.Func{`3,``6}})"/>, doing the type variable replacement at runtime.
            </summary>
            <typeparam name="TUnlifted">The unlifted value.</typeparam>
            <typeparam name="TLifted">The lifted value, containing the inner value.</typeparam>
            <typeparam name="TInner">The inner value.</typeparam>
            <typeparam name="TSource">The raw value.</typeparam>
            <typeparam name="TResult">The result-type.</typeparam>
            <param name="transformer">The transformer whose <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.ApT``7(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,System.Func{`3,``6}})"/>-function to use.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadTransformer.MakeBind``5(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3})">
            <summary>
            Creates a <see cref="T:System.Func`3"/> which runs <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.BindT``4(System.Func{`3,Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3}})"/>, doing the type variable replacement at runtime.
            </summary>
            <typeparam name="TUnlifted">The unlifted value.</typeparam>
            <typeparam name="TLifted">The lifted value, containing the inner value.</typeparam>
            <typeparam name="TInner">The inner value.</typeparam>
            <typeparam name="TSource">The raw value.</typeparam>
            <typeparam name="TResult">The result-type.</typeparam>
            <param name="transformer">The transformer whose <see cref="M:Nordril.Functional.Category.IMonadTransformer`4.BindT``4(System.Func{`3,Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3}})"/>-function to use.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonadZero`1">
            <summary>
            A monad with a zero, which corresponds to the zero of an algebraic ring,
            being, in essence, a "fail"-element.
            </summary>
            <typeparam name="T">The type of value contained in the monad.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadZero`1.Mzero">
            <summary>
            The zero of the monad. The zero must fulfill the following for any X:
            <code>
                X.Bind(X.MZero) == X.MZero (left zero)<br />
                X.MZero.Bind(f) == X.MZero (right zero)<br />
            </code>
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.IMonoFunctor`2">
            <summary>
            Monofunctors. Monofunctors are like functors (see <see cref="T:Nordril.Functional.Category.IFunctor`1"/>), but
            they only support one specific type of element. An example would be a string, which is a monofunctor
            over char.
            Implementations have to obey the same laws as those of <see cref="T:Nordril.Functional.Category.IFunctor`1"/> (for all X and f,g):
            <code>
                X.Map(a => a) == X (identity)<br />
                X.Map(a => g(f(a))) == X.Map(f).Map(g) (homomorphism)<br />
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TElem">The type of element contained in the monofunctor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonoFunctor`2.MonoMap(System.Func{`1,`1})">
            <summary>
            Applies a function to the values contained within the monofunctor
            and returns the result, without modifying the original object.
            </summary>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonoMonad`2">
            <summary>
            A monad. Monads, in addition to wrapping values (via <see cref="T:Nordril.Functional.Category.IApplicative`1"/>
            and mapping over their contained values (via <see cref="T:Nordril.Functional.Category.IFunctor`1"/> support temporarily
            unpacking their contained values and re-packing them via the <see cref="M:Nordril.Functional.Category.IMonoMonad`2.Bind(System.Func{`1,`0})"/>
            operator. Unlike <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>,
            this allows dynamically controlling the computational path at runtime, instead of just applying a fixed
            function over one of more wrapped arguments.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TSource">The type of the values contained in the monad.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonoMonad`2.Pure(`1)">
            <summary>
            Wraps a value into an applicative. The this-value MUST NOT BE USED by implementors.
            </summary>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IMonoMonad`2.Bind(System.Func{`1,`0})">
            <summary>
            Unpacks the value(s) contained in this monad and applies a function to them.
            Bind corresponds to chaining functions, with the addition of the monadic context.
            Implementors must fulfill the following laws:
            <code>
                Pure(a).Bind(f) == f(a) (left identity of pure)
                f.Bind(x => g(x).Bind(h)) == f.Bind(g).Bind(h) (associativity)
            </code>
            These laws are identical to the laws of <see cref="T:Nordril.Functional.Algebra.IHasMonoid`1"/>, except for the
            type variable in <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            </summary>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.MonoMonadExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.ThenMono``2(Nordril.Functional.Category.IMonoMonad{``0,``1},System.Func{``1,``0})">
            <summary>
            A more readable alias to <see cref="M:Nordril.Functional.Category.IMonoMonad`2.Bind(System.Func{`1,`0})"/>.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="a">The value containing the source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.ThenMMono``2(System.Func{``1,``0},System.Func{``1,``0})">
            <summary>
            Chains two monad-producing functions by executing the first, then the second, gluing them together using
            <see cref="M:Nordril.Functional.Category.IMonoMonad`2.Bind(System.Func{`1,`0})"/>. The monadic equivalent of
            <see cref="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})"/>.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TSource">The input of the first function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.AfterMMono``2(System.Func{``1,``0},System.Func{``1,``0})">
            <summary>
            Chains two monad-producing functions by executing the second, then the first, gluing them together using
            <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>. The monadic equivalent of
            <see cref="M:Nordril.Functional.F.After``3(System.Func{``1,``2},System.Func{``0,``1})"/>.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TSource">The input of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.ThenMono``2(Nordril.Functional.Category.IMonoMonad{``0,``1},``0)">
            <summary>
            Extracts the value(s) from the source and replaces it with another one, ignoring the values of the source.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="a">The value containing the source.</param>
            <param name="b">The value containing the result.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.CompMono``2(System.Func{``1,``0},System.Func{``1,``0})">
            <summary>
            Concatenates two mono-monad-functions.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TSource">The source type.</typeparam>
            <param name="f">The first monad function.</param>
            <param name="g">The second monad function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.PureUnsafeMono``2(``0)">
            <summary>
            Wraps an object in an applicative via <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            The applicative in question does not have to posess a parameterless constuctor; instead, a call to <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/> with the this-pointer being null is forced.
            If the requested applicative uses the this-pointer in <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>, this will result in a <see cref="T:System.NullReferenceException"/>.
            </summary>
            <typeparam name="TValue">The type of the object to wrap.</typeparam>
            <typeparam name="T">The type of the applicative to return.</typeparam>
            <param name="x">The value to wrap.</param>
            <exception cref="T:System.NullReferenceException">If <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/> of <typeparamref name="T"/> uses the this-pointer.</exception>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.LiftMonoM``2(System.Func{``1,``1,``1})">
            <summary>
            Lifts a binary function to take two <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/> arguments. See <see cref="M:Nordril.Functional.Category.Applicative.LiftA``3(System.Func{``0,``1,``2})"/>.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TValue">The type of the arguments.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.LiftMonoA``2(System.Func{``1,``1,``1,``1})">
            <summary>
            Lifts a ternary function to take three <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/> arguments. See <see cref="M:Nordril.Functional.Category.MonoMonadExtensions.LiftMonoM``2(System.Func{``1,``1,``1})"/>.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TValue">The type of the arguments.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonoMonadExtensions.LiftMonoA``2(System.Func{``1,``1,``1,``1,``1})">
            <summary>
            Lifts a quaternary function to take three <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/> arguments. See <see cref="M:Nordril.Functional.Category.MonoMonadExtensions.LiftMonoM``2(System.Func{``1,``1,``1})"/>.
            </summary>
            <typeparam name="T">The type of the <see cref="T:Nordril.Functional.Category.IMonoMonad`2"/>.</typeparam>
            <typeparam name="TValue">The type of the arguments.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IPhantomFunctor`1">
            <summary>
            A phantom-functor which is both a functor and a contravariant functor.
            Since a (covariant) functor and a contravariant functor to "the opposite things",
            one containing and one consuming values of type <typeparamref name="T"/>, the only
            way for any class to implement both is to not contain <typeparamref name="T"/> at all - 
            hence, <typeparamref name="T"/> is only a <em>phantom.</em>
            </summary>
            <typeparam name="T">The type of the values in the functor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.PhantomFunctor">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IPhantomFunctor`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.PhantomFunctor.MapPhantom``2(Nordril.Functional.Category.IPhantomFunctor{``0})">
            <summary>
            Maps the phantom type of an <see cref="T:Nordril.Functional.Category.IPhantomFunctor`1"/> to a new type.
            </summary>
            <typeparam name="TSource">The source phantom type.</typeparam>
            <typeparam name="TResult">The result phantom type.</typeparam>
            <param name="f">The functor whose phantom type to map.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IProfunctor`2">
            <summary>
            A functor that is contravariant in one type argument (meaning it needs values of that type)
            and covariant in its second type argument (meaning it contains values of that type).
            Implementors must fulfill the following for all X and f,g:
            <code>
                X.Promap(f, x => x) = X.Contramap(f)<br />
                X.Promap(x => x, f) = X.Map(f)<br />
            </code>
            </summary>
            <typeparam name="TNeed">The type of values the functor needs.</typeparam>
            <typeparam name="THave">The type of values the functor contains.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IProfunctor`2.Promap``2(System.Func{``0,`0},System.Func{`1,``1})">
            <summary>
            Applies a function to the contravariant part of the functor and another over its covariant one.
            If the profunctor taks A and produces B, then we apply two functions:
            one from NewA to A, and one from B to NewB. The result is a profunctor that takes NewA and produces NewB.
            </summary>
            <typeparam name="TNeedResult">The type of the new values the profunctor will need.</typeparam>
            <typeparam name="THaveResult">The type of the new values the profunctor will contain.</typeparam>
            <param name="in">The function to apply to the contravariant values.</param>
            <param name="out">The function to apply to the covariant values.</param>
        </member>
        <member name="T:Nordril.Functional.Category.Profunctor">
            <summary>
            Extension methods for profunctors.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Profunctor.MakeFun``2(System.Func{``0,``1})">
            <summary>
            Wrap a <see cref="T:System.Func`2"/> into <see cref="T:Nordril.Functional.Data.Fun`2"/>.
            </summary>
            <typeparam name="TNeed">The type of the input.</typeparam>
            <typeparam name="THave">The type of the output.</typeparam>
            <param name="f">The function to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Profunctor.ToFun``2(Nordril.Functional.Category.IProfunctor{``0,``1})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> to a <see cref="T:Nordril.Functional.Data.Fun`2"/>.
            </summary>
            <typeparam name="TIn">The type of the input.</typeparam>
            <typeparam name="TOut">The type of the output.</typeparam>
            <param name="pf">The profunctor to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Profunctor.ToFunc``2(Nordril.Functional.Category.IProfunctor{``0,``1})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> to a <see cref="T:Nordril.Functional.Data.Fun`2"/> and returns its underlying function.
            </summary>
            <typeparam name="TIn">The type of the input.</typeparam>
            <typeparam name="TOut">The type of the output.</typeparam>
            <param name="pf">The profunctor to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IStrong`2">
            <summary>
            A strong profunctor which supports lifting its input/output to a tuple-type.
            The stereotypical example of an instance is <see cref="T:System.Func`2"/> (wrapped in <see cref="T:Nordril.Functional.Data.Fun`2"/>), with the methods having the "obvious" implementations.
            </summary>
            <typeparam name="TNeed">The type of values the functor needs.</typeparam>
            <typeparam name="THave">The type of values the functor contains.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IStrong`2.LiftFirst``1">
            <summary>
            Lifts the profunctor into one which takes and produces a tuple, passing through <typeparamref name="TRight"/> unchanged. Implementors must obey the following:
            <code>
            X.LiftFirst() == X.LiftSecond().Promap((x,y) => (y,x), (x,y) => (y,x))<br />
            X.LiftFirst().LiftFirst() == X.LiftFirst().X.Promap(assoc, unassoc) where <br />
            assoc ((a, b), c) = (a, (b, c))<br />
            unassoc (a, (b, c)) == ((a, b), c)<br />
            </code>
            </summary>
            <typeparam name="TRight">The type of the second tuple-component.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IStrong`2.LiftSecond``1">
            <summary>
            Lifts the profunctor into one which takes and produces a tuple, passing through <typeparamref name="TLeft"/> unchanged. Implementors must obey the following:
            <code>
            X.LiftSecond() == X.LiftFirst().Promap((x,y) => (y,x), (x,y) => (y,x))<br />
            </code>
            </summary>
            <typeparam name="TLeft">The type of the first tuple-component.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.ITraversable`1">
            <summary>
            Data structures which can be traversed left to right.
            </summary>
            <typeparam name="TSource">The type of the elements in the container.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.ITraversable`1.Traverse``2(System.Func{`0,``0})">
            <summary>
            Maps each element of to an <see cref="T:Nordril.Functional.Category.IApplicative`1"/> and collects the results.
            The following must hold for implementations:
            <code>
            X.Traverse(F).Then(T) == X.Traverse(F.Then(T)) (naturality)<br />
            X.Traverse(x => new Identity&lt;T&gt;) == new Identity&lt;T&lt;Source&gt;&gt;(X) where X is T&lt;Source&gt; (identity)<br />
            X.Traverse(y => new Compose(f(x).Map(g))) == new Compose(X.Traverse(f).Map(y => y.Traverse(g)) (composition)<br />
            </code>
            </summary>
            <typeparam name="TApplicative">The type of the resulting applicative.</typeparam>
            <typeparam name="TResult">The type of the resulting elements.</typeparam>
            <param name="f">The mapping-function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ITraversable`1.Traverse``1(System.Type,System.Func{`0,Nordril.Functional.Category.IApplicative{``0}})">
            <summary>
            Maps each element of to an <see cref="T:Nordril.Functional.Category.IApplicative`1"/> and collects the results.
            The following must hold for implementations:
            <code>
            X.Traverse(F).Then(T) == X.Traverse(F.Then(T)) (naturality)<br />
            X.Traverse(x => new Identity&lt;T&gt;) == new Identity&lt;T&lt;Source&gt;&gt;(X) where X is T&lt;Source&gt; (identity)<br />
            X.Traverse(y => new Compose(f(x).Map(g))) == new Compose(X.Traverse(f).Map(y => y.Traverse(g)) (composition)<br />
            </code>
            </summary>
            <param name="applicative">The type of the resulting applicative. Must be of type <c>IApplicative&lt;TResult&gt;</c></param>
            <typeparam name="TResult">The type of the resulting elements.</typeparam>
            <param name="f">The mapping-function.</param>
        </member>
        <member name="T:Nordril.Functional.Category.Traversable">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Traversable.Traverse``2(Nordril.Functional.Category.ITraversable{``0})">
            <summary>
            Iterates through an <see cref="T:Nordril.Functional.Category.ITraversable`1"/> containing <see cref="T:Nordril.Functional.Category.IApplicative`1"/>-elements and collects the results.
            </summary>
            <typeparam name="TSource">The type of the elements.</typeparam>
            <typeparam name="TApplicative">The type of the applicative to which to map the contained elements.</typeparam>
            <param name="x">The <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IWitherable`1">
            <summary>
            A traversable data structure which also supports the removal of elements during the traversal.
            Also known as <em>Witherable</em>.
            </summary>
            <typeparam name="TSource">The type of elements in the container.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IWitherable`1.TraverseMaybe``2(System.Func{`0,``0})">
            <summary>
            Maps each element of to an <see cref="T:Nordril.Functional.Category.IApplicative`1"/> and collects the results.
            The following must hold for implementations:
            <code>
            X.TraverseMaybe(x => f(x).Map(y => Maybe.Just(y)) == X.Traverse(f) (conservation)<br />
            new Compose(X.TraverseMaybe(g).Map(y => y.TraverseMaybe(f))) == X.TraverseMaybe(x => new Compose(g(x).Then(y => y.Map(z => z.TraverseMaybe(f)))) (composition)<br />
            </code>
            </summary>
            <typeparam name="TApplicative">The type of the resulting applicative.</typeparam>
            <typeparam name="TResult">The type of the resulting elements.</typeparam>
            <param name="f">The mapping-function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IWitherable`1.TraverseMaybe``1(System.Type,System.Func{`0,Nordril.Functional.Category.IApplicative{Nordril.Functional.Data.Maybe{``0}}})">
            <summary>
            Maps each element of to an <see cref="T:Nordril.Functional.Category.IApplicative`1"/> and collects the results.
            The following must hold for implementations:
            <code>
            X.Traverse(F).Then(T) == X.Traverse(F.Then(T)) (naturality)<br />
            X.Traverse(x => new Identity&lt;T&gt;) == new Identity&lt;T&lt;Source&gt;&gt;(X) where X is T&lt;Source&gt; (identity)<br />
            X.Traverse(y => new Compose(f(x).Map(g))) == new Compose(X.Traverse(f).Map(y => y.Traverse(g)) (composition)<br />
            </code>
            </summary>
            <param name="applicative">The type of the resulting applicative. Must be of type <c>IApplicative&lt;TResult&gt;</c></param>
            <typeparam name="TResult">The type of the resulting elements.</typeparam>
            <param name="f">The mapping-function.</param>
        </member>
        <member name="T:Nordril.Functional.Category.Linq.PolyLinqExtensions">
            <summary>
            LINQ methods for generic <see cref="T:Nordril.Functional.Category.IFunctor`1"/>s/<see cref="T:Nordril.Functional.Category.IMonad`1"/>s, enabling the writing of LINQ-queries.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.Linq.PolyLinqExtensions.Select``2(Nordril.Functional.Category.IFunctor{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>. The functor-type is preserved, but checking for a concrete type is the responsibility of the caller.
            Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.Linq.PolyLinqExtensions.SelectMany``3(Nordril.Functional.Category.IMonad{``0},System.Func{``0,Nordril.Functional.Category.IMonad{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>. The monad-type is preserved, but checking that every computation in the query is in the same monad, and checking for a concrete type are the responsibility of the caller.
            Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="T:Nordril.Functional.CollectionExtensions">
            <summary>
            Extension methods for collections.
            </summary>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Aggregate2``3(System.Collections.Generic.IEnumerable{``0},``2,System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``2,``0,``1,``2})">
            <summary>
            Performs two nested aggregations: the outer one traverses <paramref name="xs"/>, the inner one traverses the result of <paramref name="selector"/> for each element of <paramref name="xs"/>. Thus, this function is the equivalent of running two nested loops, with <paramref name="selector"/> generating the elements for the inner loop. The accumulator is forwarded across each step.
            </summary>
            <typeparam name="T1">The type of element in the outer sequence.</typeparam>
            <typeparam name="T2">The type of element in the inner sequence.</typeparam>
            <typeparam name="TAcc">The type of the accumulator/result.</typeparam>
            <param name="xs">The sequence to traverse.</param>
            <param name="acc">The initial accumulator.</param>
            <param name="selector">The selector which generates the inner sequence for each element of <paramref name="xs"/>.</param>
            <param name="f">The combining function for the accumulator and the current element of the outer sequence, as well as the current element of th e inner list.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AggregateRight``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``1},``1)">
            <summary>
            Performs a right-fold on a sequence. For associative combining functions <paramref name="f"/>, <see cref="M:Nordril.Functional.CollectionExtensions.AggregateRight``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``1},``1)"/> returns the same result as <see cref="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})"/>, though it will use heap memory linear in the length of <paramref name="xs"/>. The definition is:
            <code>
                {x1,x2,...,xn}.AggregateRight(acc, f) = f(x1, f(x2, ... f(xn, acc)...)
                for instance
                {1, 2, 3, 4}.AggregateRight(0, (x, acc) =&gt; x + acc = 1 + (2 + (3 + (4 + 0)))
            </code>
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TResult">The type of the result/accumulator.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="acc">The accumulator.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AggregateRightAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,System.Threading.Tasks.Task{``1}},``1)">
            <summary>
            The async-version of <see cref="M:Nordril.Functional.CollectionExtensions.AggregateRight``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``1},``1)"/>.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TResult">The type of the result/accumulator.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="acc">The accumulator.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.All(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Returns true iff all elements of <paramref name="xs"/> equal true.
            </summary>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AnyTrue(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Returns true iff at least one element of <paramref name="xs"/> equals true.
            </summary>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})"/>, using double-precision for the computation.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})"/>, using double-precision for the computation.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})"/>, using double-precision for the computation.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})"/>, using double-precision for the computation. Due to numerical errors, values may diverage.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})"/>, using double-precision for the computation. Due to numerical errors, values may diverage.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})"/>, using double-precision for the computation. Due to numerical errors, values may diverage.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})"/>, using double-precision for the computation. Due to numerical errors, values may diverage.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})"/>, using double-precision for the computation. Due to numerical errors, values may diverage.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})"/>, using decimal-precision for the computation. Due to numerical errors, values may diverage.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AverageIterative(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Computes the average value of a sequence iteratively, meaning that the calculation won't overflow, unlike <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})"/> possibly does.
            Otherwise, the result will be the same as <see cref="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})"/>, using decimal-precision for the computation.
            </summary>
            <param name="xs">The sequence to traverse.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Returns all combinations of the elements of two sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="zs">The third sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="zs">The third sequence.</param>
            <param name="us">The fourth sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``6(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <typeparam name="T5">The type of elements in the fifth sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="zs">The third sequence.</param>
            <param name="us">The fourth sequence.</param>
            <param name="vs">The fifth sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``7(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4},System.Collections.Generic.IEnumerable{``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <typeparam name="T5">The type of elements in the fifth sequence.</typeparam>
            <typeparam name="T6">The type of elements in the sixth sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="zs">The third sequence.</param>
            <param name="us">The fourth sequence.</param>
            <param name="vs">The fifth sequence.</param>
            <param name="ws">The sixth sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``8(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4},System.Collections.Generic.IEnumerable{``5},System.Collections.Generic.IEnumerable{``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <typeparam name="T5">The type of elements in the fifth sequence.</typeparam>
            <typeparam name="T6">The type of elements in the sixth sequence.</typeparam>
            <typeparam name="T7">The type of elements in the seventh sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="zs">The third sequence.</param>
            <param name="us">The fourth sequence.</param>
            <param name="vs">The fifth sequence.</param>
            <param name="ws">The sixth sequence.</param>
            <param name="ss">The seventh sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``9(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4},System.Collections.Generic.IEnumerable{``5},System.Collections.Generic.IEnumerable{``6},System.Collections.Generic.IEnumerable{``7},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T1">The type of elements in the first sequence.</typeparam>
            <typeparam name="T2">The type of elements in the second sequence.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <typeparam name="T5">The type of elements in the fifth sequence.</typeparam>
            <typeparam name="T6">The type of elements in the sixth sequence.</typeparam>
            <typeparam name="T7">The type of elements in the seventh sequence.</typeparam>
            <typeparam name="T8">The type of elements in the eigth sequence.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The first sequence.</param>
            <param name="ys">The second sequence.</param>
            <param name="zs">The third sequence.</param>
            <param name="us">The fourth sequence.</param>
            <param name="vs">The fifth sequence.</param>
            <param name="ws">The sixth sequence.</param>
            <param name="ss">The seventh sequence.</param>
            <param name="ts">The eigth sequence.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Cartesian``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Func{System.Collections.Generic.IEnumerable{``0},``1})">
            <summary>
            Returns all combinations of the elements of three sequences (the Cartesian product).
            </summary>
            <typeparam name="T">The type of elements in the equences.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="sequences">The sequences.</param>
            <param name="f">The result selector function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Concatenates a sequence of sequences.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence whose elements to concatenate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ConcatStrings(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Efficiently concatenates the elements of a sequence of strings into a single strings. An alias for <see cref="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})"/>.
            </summary>
            <param name="xs">The sequence whose elements to concatenate.</param>
            <param name="separator">The separator to put between each two elements.</param>
            <param name="prefix">The optional prefix to apply to the resultant string.</param>
            <param name="postfix">The optional postfix to apply to the resultant string.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Empty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns true iff the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.FirstMaybe``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of the sequence if it exists, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.FirstMaybe``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element of the sequence which fulfills a predicate if it exists, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to check.</param>
            <param name="predicate">The predicate the element has to fulfill.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach(System.Collections.IEnumerable,System.Action{System.Object})">
            <summary>
            Performs an action <paramref name="action"/> on each element of a sequence.
            </summary>
            <param name="xs">The list to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs an action <paramref name="action"/> on each element of a sequence.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1})">
            <summary>
            Performs an action <paramref name="action"/> on each element of two sequences which are traversed in parallel, until the end of the shorter one..
            </summary>
            <typeparam name="T1">The type of elements in the first sequencde.</typeparam>
            <typeparam name="T2">The type of elements in the second sequencde.</typeparam>
            <param name="xs">The first sequence to traverse.</param>
            <param name="ys">The second sequence to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Action{``0,``1,``2})">
            <summary>
            Performs an action <paramref name="action"/> on each element of three sequences which are traversed in parallel, until the end of the shorter one..
            </summary>
            <typeparam name="T1">The type of elements in the first sequencde.</typeparam>
            <typeparam name="T2">The type of elements in the second sequencde.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <param name="xs">The first sequence to traverse.</param>
            <param name="ys">The second secquence to traverse.</param>
            <param name="zs">The third sequence to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Action{``0,``1,``2,``3})">
            <summary>
            Performs an action <paramref name="action"/> on each element of four sequences which are traversed in parallel, until the end of the shorter one..
            </summary>
            <typeparam name="T1">The type of elements in the first sequencde.</typeparam>
            <typeparam name="T2">The type of elements in the second sequencde.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <param name="xs">The first sequence to traverse.</param>
            <param name="ys">The second secquence to traverse.</param>
            <param name="us">The third sequence to traverse.</param>
            <param name="zs">The fourth sequence to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the index of the first occurrence of an element <paramref name="elem"/> in a sequence, or null.
            The search is linear and the runtime O(n).
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to check.</param>
            <param name="elem">The element to search for.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Intercalate``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersperses a sequence <paramref name="separator"/> between each two elements of a sequence <paramref name="xs"/>.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <param name="xs">The sequence to intersperse.</param>
            <param name="separator">The separator to intersperse between each two elements of <paramref name="xs"/>.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Intersperse``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Intersperses an element <paramref name="separator"/> between each two elements of a sequence.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <param name="xs">The sequence to intersperse.</param>
            <param name="separator">The separator to intersperse between each two elements of <paramref name="xs"/>.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the element of the sequence whose key (extracted by <paramref name="keySelector"/>) is maximal, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the sequence is empty.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="xs">The sequence.</param>
            <param name="keySelector">The key-selection function. null-values count as greater than all other values.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Returns the element of the sequence whose key (extracted by <paramref name="keySelector"/>) is maximal, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the sequence is empty.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="xs">The sequence.</param>
            <param name="keySelector">The key-selection function. null-values count as greater than all other values.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MergeAdjacent``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,Nordril.Functional.Data.Maybe{``0}})">
            <summary>
            Iterates through a sequence and merges any two adjacent elements for which the function <paramref name="mergeIf"/> returns a value. Multiple adjacent elements are merges as well, with the return value of <paramref name="mergeIf"/> functioning as an accumulator.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="xs">The list to merge.</param>
            <param name="mergeIf">The merging function. If two elements shouldn't be merged, it should return no value.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MinMaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}},System.Boolean)">
            <summary>
            Returns the element of the sequence whose key (extracted by <paramref name="keySelector"/>) is minimal/maximal, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the sequence is empty.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="xs">The sequence.</param>
            <param name="keySelector">The key-selection function. null-values count as smaller/greater than all other values.</param>
            <param name="minMax">If true, the minimum is returned, otherwise the maximum.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MinMaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Boolean)">
            <summary>
            Returns the element of the sequence whose key (extracted by <paramref name="keySelector"/>) is minimal/maximal, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the sequence is empty.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="xs">The sequence.</param>
            <param name="keySelector">The key-selection function. null-values count as smaller/greater than other values.</param>
            <param name="minMax">If true, the minimum is returned, otherwise the maximum.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the element of the sequence whose key (extracted by <paramref name="keySelector"/>) is minimal, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the sequence is empty.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="xs">The sequence.</param>
            <param name="keySelector">The key-selection function. null-values count as greater than all other values.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Returns the element of the sequence whose key (extracted by <paramref name="keySelector"/>) is minimal, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the sequence is empty.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="xs">The sequence.</param>
            <param name="keySelector">The key-selection function. null-values count as smaller than all other values.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Partitions a list into two lists based on a predicate <paramref name="putInFirst"/>. All elements which fulfill <paramref name="putInFirst"/> are put into the first list, and all others are put into the second.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <param name="xs">The sequence to split.</param>
            <param name="putInFirst">The splitting predicate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Partition``2(System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Either{``0,``1}})">
            <summary>
            Partitions a list of <see cref="T:Nordril.Functional.Data.Either`2"/> into left- and right-lists.
            </summary>
            <typeparam name="TLeft">The type of the left-elements.</typeparam>
            <typeparam name="TRight">The type of the right-elements.</typeparam>
            <param name="xs">The sequence to split.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.SelectAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``0})">
            <summary>
            Applies a function at a specific, 0-based index at a sequence and returns the original elements of the sequence at all others. This method takes O(n) time.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to search.</param>
            <param name="point">The point at which to apply the function.</param>
            <param name="f">The function to apply at index <paramref name="point"/>.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.SelectKeyValue``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a dictionary of key-value-pairs into a new form.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The sequence to traverse.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.SelectMaybe``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Data.Maybe{``1}})">
            <summary>
            Applies a function which produces a <see cref="T:Nordril.Functional.Data.Maybe`1"/> to each element of a sequence and returns a sequence of those resultant elements for which <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true. This is useful for appliying a function which may not have a results and filtering it for results in one go.
            <br />
            Semantically, the following holds for all xs:
            <code>
               xs.SelectMaybe(f) == xs.Select(f).Where(x =&lt; x.HasValue).Select(x =&gt; x.Value());
            </code>
            </summary>
            <example>
            We compute the square roots of all elements in the sequence and return only those which were computed from positive numbers:
            <code>
            var xs = new [] {9, -10, -5, 25, 16, -144};
            
            var ys = xs.SelectMaybe(x =&gt; Maybe.JustIf(x &gt;= 0, () =&gt; Math.Sqrt(x)));
            //ys = [3, 5, 4]
            </code>
            </example>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TResult">The type of elements ot generate.</typeparam>
            <param name="xs">The sequence to whose elements to apply the function.</param>
            <param name="f">The function to apply to each element of the sequence.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MakeFuncList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.IFuncList`1"/> out of a sequence of elements. Analogous to <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to turn into a list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MakeFuncSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.IFuncSet`1"/> out of a sequence of elements.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to turn into a set.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MakeFuncList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.IFuncList`1"/> out of a sequence of elements with a custom comparer. Analogous to <see cref="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to turn into a list.</param>
            <param name="comparer">The equality comparer.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MakeFuncSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.IFuncSet`1"/> out of a sequence of elements with a custom comparer.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to turn into a set.</param>
            <param name="comparer">The equality comparer.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unfold``2(``0,System.Func{``0,Nordril.Functional.Data.Maybe{System.ValueTuple{``0,``1}}})">
            <summary>
            Generates a (potentially infinite) sequence from a seed value <paramref name="seed"/> and a function to generate the next seed and element <paramref name="next"/>.
            </summary>
            <typeparam name="TSeed">The type of the seed value.</typeparam>
            <typeparam name="TResult">The type of elements to generate.</typeparam>
            <param name="seed">The initial seed value.</param>
            <param name="next">The function to generate the next seed, and the next element to yield. If the return value is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>, the sequence-generation stops.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unique``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns just the unique elements of the sequence. Two elements <c>x</c> and <c>y</c> are regarded as equal iff <c>x.Equals(y)</c> is true. If two or more elements are equal, only the first element is returned.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to filter.</param>
            <returns>Those elements whose keys are the first occurrences in the sequence.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unique``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns just the unique elements of the sequence. Two elements <c>x</c> and <c>y</c> are regarded as equal iff <c>keySelector(x).Equals(keySelector(y))</c> is true. If two or more elements are equal, only the first element is returned.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TKey">The keys of the elements.</typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="keySelector">The keys selection function.</param>
            <returns>Those elements whose keys are the first occurrences in the sequence.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unique``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,``1,System.Boolean},System.Func{``1,System.Int32})">
            <summary>
            Returns just the unique elements of the sequence. Two elements <c>x</c> and <c>y</c> are regarded as equal iff <c>comparer.Equal(keySelector(x), keySelector(y))</c> is true. If two or more elements are equal, only the first element is returned.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TKey">The keys of the elements.</typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="keySelector">The keys selection function.</param>
            <param name="comparer">The equality comparer to use to determine element equality.</param>
            <param name="hashFunc">The hash-function. The following must hold: <c>comparer(x,y) => hashFunc(x) == hashFunc(y)</c>.</param>
            <returns>Those elements whose keys are the first occurrences in the sequence.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.ValueTuple{``1,``2}})">
            <summary>
            The oppostive of <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})"/>, in that it takes a list <paramref name="xs"/> and splits it into two lists of the same size via a function <paramref name="f"/>.
            </summary>
            <typeparam name="T">The type of elements in the source list.</typeparam>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <param name="f">The splitting function.</param>
            <returns>Two lists of the same size as <paramref name="xs"/>, with <paramref name="f"/> having been applied to the element of <paramref name="xs"/> in order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            The oppostive of <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})"/>, in that it takes a list <paramref name="xs"/> and splits it into two lists of the same size.
            </summary>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <returns>Two lists of the same size as <paramref name="xs"/>, with the same element order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``3(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2}})">
            <summary>
            The oppostive of <see cref="M:Nordril.Functional.CollectionExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})"/>, in that it takes a list <paramref name="xs"/> and splits it into three lists of the same size.
            </summary>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <typeparam name="T3">The type of elements in the third result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <returns>Three lists of the same size as <paramref name="xs"/>, with the same element order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``4(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3}})">
            <summary>
            The oppostive of <see cref="M:Nordril.Functional.CollectionExtensions.Zip``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})"/>, in that it takes a list <paramref name="xs"/> and splits it into fource lists of the same size.
            </summary>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <typeparam name="T3">The type of elements in the third result list.</typeparam>
            <typeparam name="T4">The type of elements in the fourth result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <returns>Three lists of the same size as <paramref name="xs"/>, with the same element order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Zips three sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Zips three sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <summary>
            Zips four sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <typeparam name="T4">The type of elements in the fourth list.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
            <param name="us">The fourth list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Zips four sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <typeparam name="T4">The type of elements in the fourth list.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
            <param name="us">The fourth list.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Func{System.Collections.Generic.IList{``0},``1})">
            <summary>
            Zips a sequence of sequences together, iterating through all sequences in parallel, until the end of the longest one, omitting those sequences whose end has been reached from the input of <paramref name="f"/>. For each i, the list of elements at index i is combined into one result via <paramref name="f"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="xs">The sequences to zip.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Zips a sequence of sequences together, iterating through all sequences in parallel, until the end of the shortest one. For each i, the list of elements at index i is combined into one result list.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
            <param name="xs">The sequences to zip.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ZipWithStream``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``1})">
            <summary>
            Zips a list with a stream. A steam is an infinite series comprising an initial element <paramref name="start"/> and a "next element"-function <paramref name="next"/>.
            </summary>
            <typeparam name="T1">The type of elements in the list.</typeparam>
            <typeparam name="T2">The type of elements in the stream.</typeparam>
            <param name="xs">The list.</param>
            <param name="start">The initial element of the stream.</param>
            <param name="next">The "next element"-function.</param>
            <returns>The elements of the first list, together with the created elements of the stream.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.HashElements``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a hash value for a collection of elements by hashing the contained elements
            and adding them to a seed a multiplier. The hash code is computed by the formula:
            <code>
               collection.foldl(487, (acc, cur) => acc*31 + cur.GetHashCode())
            </code>
            Users should NOT rely on this implementation detail.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="collection">The collection to hash.</param>
        </member>
        <member name="T:Nordril.Functional.Composite.ConflictResolution">
            <summary>
            A conflict resolution strategy when two pieces of data clash.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Composite.ConflictResolution.UseNew">
            <summary>
            Overwrite the old data with the new.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Composite.ConflictResolution.UseExisting">
            <summary>
            Leave the old data in place.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Composite.ConflictResolution.Fail">
            <summary>
            Leave the old data in place and fail the process (usually by throwing an exception).
            </summary>
        </member>
        <member name="T:Nordril.Functional.Composite.IComposite`2">
            <summary>
            A component which can be composed of sub-components of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the sub-components.</typeparam>
            <typeparam name="TName">The type of the (sub-)component's name.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Composite.IComposite`2.Parts">
            <summary>
            The set of sub-components. If this component is atomic, this method must return an empty set.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Composite.IComposite`2.ReplaceParts(System.Collections.Generic.IEnumerable{`0},Nordril.Functional.Composite.ConflictResolution,System.Int32@)">
            <summary>
            Replaces the given elements of <see cref="P:Nordril.Functional.Composite.IComposite`2.Parts"/> with the given <see cref="P:Nordril.Functional.Composite.INamed`1.Name"/> names, modulo the <see cref="T:Nordril.Functional.Composite.ConflictResolution"/> <paramref name="resolution"/>.
            </summary>
            <param name="parts">The list of parts to replace, with their names.</param>
            <param name="resolution">The resolution strategy to use in case of conflict.</param>
            <param name="numReplaced">The number of replacements which occurred. &lt;= the count of <paramref name="parts"/>.</param>
            <returns>A copy of the callee, which might be different or identical (if not replacement occurred). The caller should not rely on the return value (not) being reference-equal to the callee.</returns>
            <exception cref="T:Nordril.Functional.Algebra.KeyAlreadyPresentException">If <see cref="F:Nordril.Functional.Composite.ConflictResolution.Fail"/> was specified and the old component already existed.</exception>
        </member>
        <member name="T:Nordril.Functional.Composite.INamed`1">
            <summary>
            Objects which possess a unique name of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Nordril.Functional.Composite.INamed`1.Name">
            <summary>
            Gets the object's name.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Compose`3">
            <summary>
            The composition of two functors, e.g. <c>Maybe(List(int))</c>.
            </summary>
            <typeparam name="TFOuter">The type of the outer functor.</typeparam>
            <typeparam name="TFInner">The type of the inner functor.</typeparam>
            <typeparam name="TSource">The type of the contained elements.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Compose`3.Value">
            <summary>
            The contained value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Compose`3.#ctor(`0)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="value">The value to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Compose`3.Map``1(System.Func{`2,``0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Const`1">
            <summary>
            A const-functor that does not actually contain any values.
            </summary>
            <typeparam name="T">The type of value by which to tag the functor. No values are actually present.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.ContraMap``1(System.Func{``0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.op_Equality(Nordril.Functional.Data.Const{`0},Nordril.Functional.Data.Const{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.op_Inequality(Nordril.Functional.Data.Const{`0},Nordril.Functional.Data.Const{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.Equals(Nordril.Functional.Data.Const{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Const`2">
            <summary>
            A const-functor that contains a "real" value, but which is a functor according to a
            second value which is does not actually contain.
            This is analogous to <see cref="T:Nordril.Functional.Data.Const`1"/>, with the difference that we have a "hidden" value
            that does not influence the functor-instance.
            </summary>
            <typeparam name="TReal">The actual value contained in the functor.</typeparam>
            <typeparam name="TPhantom">The value which is only present as a phantom.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Const`2.RealValue">
            <summary>
            The value contained in the functor.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.#ctor(`0)">
            <summary>
            Creates a new const-instance with a value.
            </summary>
            <param name="realValue">The value to store in the functor.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.ContraMap``1(System.Func{``0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Equals(System.Object)">
            <summary>
            Determines equality based on <see cref="P:Nordril.Functional.Data.Const`2.RealValue"/>.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.op_Equality(Nordril.Functional.Data.Const{`0,`1},Nordril.Functional.Data.Const{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.op_Inequality(Nordril.Functional.Data.Const{`0,`1},Nordril.Functional.Data.Const{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Equals(Nordril.Functional.Data.Const{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Remember``1">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Const`3"/> by adding monoid-information.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Remember``2(System.Func{`0,``1})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Const`3"/> by adding monoid-information and also changing the type of the real value.
            </summary>
            <typeparam name="TMonoid">The type of the monoid to add.</typeparam>
            <typeparam name="TRealResult">The type of the resultant real value.</typeparam>
            <param name="f">The function to map the real value.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Const`3">
            <summary>
            A const-functor that contains a "real" value, but which is a functor according to a
            second value which is does not actually contain. <typeparamref name="TPhantom"/> also forms a monoid with the help of <typeparamref name="TMonoid"/>.
            This is analogous to <see cref="T:Nordril.Functional.Data.Const`1"/>, with the difference that we have a "hidden" value
            that does not influence the functor-instance.
            </summary>
            <typeparam name="TMonoid">The monoid over <typeparamref name="TReal"/>.</typeparam>
            <typeparam name="TReal">The actual value contained in the functor.</typeparam>
            <typeparam name="TPhantom">The value which is only present as a phantom.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Const`3.RealValue">
            <summary>
            The value contained in the functor.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.#ctor(`1)">
            <summary>
            Creates a new const-instance with a value.
            </summary>
            <param name="realValue">The value to store in the functor.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.ContraMap``1(System.Func{``0,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Map``1(System.Func{`2,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Equals(System.Object)">
            <summary>
            Determines equality based on <see cref="P:Nordril.Functional.Data.Const`3.RealValue"/>.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.op_Equality(Nordril.Functional.Data.Const{`0,`1,`2},Nordril.Functional.Data.Const{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.op_Inequality(Nordril.Functional.Data.Const{`0,`1,`2},Nordril.Functional.Data.Const{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Equals(Nordril.Functional.Data.Const{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`2,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Forget">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Const`2"/> which does not have the monoid-information.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const`3.Forget``1(System.Func{`1,``0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Const`2"/> which does not have the monoid-information.
            </summary>
            <typeparam name="TRealResult">The type of the resultant real value.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Const">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Const`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const.Select``2(Nordril.Functional.Data.Const{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Const`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.Const{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Const`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const.Select``3(Nordril.Functional.Data.Const{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Const`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TReal">The real value in the source.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const.Select``3(System.Threading.Tasks.Task{Nordril.Functional.Data.Const{``0,``1}},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Const`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TReal">The real value in the source.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const.ToConst``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Const`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const.ToConst``1(Nordril.Functional.Category.IContravariant{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IContravariant`1"/> to a <see cref="T:Nordril.Functional.Data.Const`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.ConstCxt`1">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.Const`2"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods. See <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> for examples
            </summary>
            <typeparam name="TReal">The type of the real value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.ConstCxt`1.Make``1(`0)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Const`2"/>.
            </summary>
            <typeparam name="TPhantom">The varying phantom-type.</typeparam>
            <param name="value">The real value.</param>
        </member>
        <member name="T:Nordril.Functional.Data.DictionaryEqualityComparer">
            <summary>
            A factory-class that creates <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>s which compare dictionaries for structural equality.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.DictionaryEqualityComparer.Make``2(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a structural <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for key- and value-types for which the caller provides <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>s.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.DictionaryEqualityComparer.Make``2">
            <summary>
            Creates a structural <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for key- and value-types which are <see cref="T:System.IEquatable`1"/>.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.DictionaryEqualityComparer`2">
            <summary>
            An equality-comparer which compares two dictionaries for structural equality, meaning based on the keys and values they contain.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.DictionaryEqualityComparer`2.KeyComp">
            <summary>
            The key-comparer.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.DictionaryEqualityComparer`2.KeyEqComp">
            <summary>
            The key-comparer, upcast to an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.DictionaryEqualityComparer`2.ValueComp">
            <summary>
            The value-commparer.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.DictionaryEqualityComparer`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="keyComp">The key-comparer. This must also implement <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</param>
            <param name="valueComp">The value-comparer.</param>
        </member>
        <member name="M:Nordril.Functional.Data.DictionaryEqualityComparer`2.Equals(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.DictionaryEqualityComparer`2.GetHashCode(System.Collections.Generic.IDictionary{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either">
            <summary>
            Static methods for <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``3(Nordril.Functional.Data.Either{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TLeft">The type of the either's left-value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``4(Nordril.Functional.Data.Either{``0,``1,``2},System.Func{``2,``3})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`3"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``5(Nordril.Functional.Data.Either{``0,``1,``2,``3},System.Func{``3,``4})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`4"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``6(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4},System.Func{``4,``5})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`5"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``7(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5},System.Func{``5,``6})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`6"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``8(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6},System.Func{``6,``7})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`7"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``9(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``7},System.Func{``7,``8})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`8"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``4(Nordril.Functional.Data.Either{``0,``1},System.Func{``1,Nordril.Functional.Data.Either{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`2"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TLeft">The type of the either's left-value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``5(Nordril.Functional.Data.Either{``0,``1,``2},System.Func{``2,Nordril.Functional.Data.Either{``0,``1,``3}},System.Func{``2,``3,``4})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`3"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``6(Nordril.Functional.Data.Either{``0,``1,``2,``3},System.Func{``3,Nordril.Functional.Data.Either{``0,``1,``2,``4}},System.Func{``3,``4,``5})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`4"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``7(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4},System.Func{``4,Nordril.Functional.Data.Either{``0,``1,``2,``3,``5}},System.Func{``4,``5,``6})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`5"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``8(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5},System.Func{``5,Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``6}},System.Func{``5,``6,``7})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`6"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``9(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6},System.Func{``6,Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``7}},System.Func{``6,``7,``8})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`7"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``10(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``7},System.Func{``7,Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``8}},System.Func{``7,``8,``9})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Either`8"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``3(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1}},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TLeft">The type of the either's left-value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``4(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2}},System.Func{``2,``3})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`3"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``5(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3}},System.Func{``3,``4})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`4"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``6(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4}},System.Func{``4,``5})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`5"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``7(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5}},System.Func{``5,``6})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`6"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``8(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6}},System.Func{``6,``7})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`7"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Select``9(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``7}},System.Func{``7,``8})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`8"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``4(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1}},System.Func{``1,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``2}}},System.Func{``1,``2,``3})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`2"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TLeft">The type of the either's left-value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``5(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2}},System.Func{``2,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``3}}},System.Func{``2,``3,``4})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`3"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``6(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3}},System.Func{``3,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``4}}},System.Func{``3,``4,``5})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`4"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``7(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4}},System.Func{``4,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``5}}},System.Func{``4,``5,``6})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`5"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``8(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5}},System.Func{``5,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``6}}},System.Func{``5,``6,``7})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`6"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``9(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6}},System.Func{``6,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``7}}},System.Func{``6,``7,``8})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`7"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.SelectMany``10(System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``7}},System.Func{``7,System.Threading.Tasks.Task{Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``8}}},System.Func{``7,``8,``9})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Either`8"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.FromLeft``2(``0)">
            <summary>
            Creates a left-either from a value.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.FromRight``2(``1)">
            <summary>
            Creates a right-either from a value.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.FromRight``2(Nordril.Functional.Data.EitherCxt{``0},``1)">
            <summary>
            Creates a right-either from a value.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherIf``2(System.Boolean,System.Func{``0},System.Func{``1})">
            <summary>
            Creates a right-either from a value.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="isRight">If true, an <see cref="M:Nordril.Functional.Data.Either.FromRight``2(``1)"/> will be created, and if false, an <see cref="M:Nordril.Functional.Data.Either.FromLeft``2(``0)"/>.</param>
            <param name="leftFactory">The left-value to store in the either.</param>
            <param name="rightFactory">The right-value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Coalesce``4(Nordril.Functional.Data.Either{``0,``1,``2},System.Func{``0,``3},System.Func{``1,``3},System.Func{``2,``3})">
            <summary>
            Coalesces an <see cref="T:Nordril.Functional.Data.Either`3"/> into a single value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="coproduct">The Either to coalesce.</param>
            <param name="one">The function to apply if the Either contains a first value.</param>
            <param name="two">The function to apply if the Either contains a second value.</param>
            <param name="three">The function to apply if the Either contains a third value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Coalesce``5(Nordril.Functional.Data.Either{``0,``1,``2,``3},System.Func{``0,``4},System.Func{``1,``4},System.Func{``2,``4},System.Func{``3,``4})">
            <summary>
            Coalesces an <see cref="T:Nordril.Functional.Data.Either`4"/> into a single value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="coproduct">The Either to coalesce.</param>
            <param name="one">The function to apply if the Either contains a first value.</param>
            <param name="two">The function to apply if the Either contains a second value.</param>
            <param name="three">The function to apply if the Either contains a third value.</param>
            <param name="four">The function to apply if the Either contains a fourth value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Coalesce``6(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4},System.Func{``0,``5},System.Func{``1,``5},System.Func{``2,``5},System.Func{``3,``5},System.Func{``4,``5})">
            <summary>
            Coalesces an <see cref="T:Nordril.Functional.Data.Either`5"/> into a single value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="coproduct">The Either to coalesce.</param>
            <param name="one">The function to apply if the Either contains a first value.</param>
            <param name="two">The function to apply if the Either contains a second value.</param>
            <param name="three">The function to apply if the Either contains a third value.</param>
            <param name="four">The function to apply if the Either contains a fourth value.</param>
            <param name="five">The function to apply if the Either contains a fifth value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Coalesce``7(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5},System.Func{``0,``6},System.Func{``1,``6},System.Func{``2,``6},System.Func{``3,``6},System.Func{``4,``6},System.Func{``5,``6})">
            <summary>
            Coalesces an <see cref="T:Nordril.Functional.Data.Either`6"/> into a single value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="coproduct">The Either to coalesce.</param>
            <param name="one">The function to apply if the Either contains a first value.</param>
            <param name="two">The function to apply if the Either contains a second value.</param>
            <param name="three">The function to apply if the Either contains a third value.</param>
            <param name="four">The function to apply if the Either contains a fourth value.</param>
            <param name="five">The function to apply if the Either contains a fifth value.</param>
            <param name="six">The function to apply if the Either contains a sixth value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Coalesce``8(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6},System.Func{``0,``7},System.Func{``1,``7},System.Func{``2,``7},System.Func{``3,``7},System.Func{``4,``7},System.Func{``5,``7},System.Func{``6,``7})">
            <summary>
            Coalesces an <see cref="T:Nordril.Functional.Data.Either`7"/> into a single value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="coproduct">The Either to coalesce.</param>
            <param name="one">The function to apply if the Either contains a first value.</param>
            <param name="two">The function to apply if the Either contains a second value.</param>
            <param name="three">The function to apply if the Either contains a third value.</param>
            <param name="four">The function to apply if the Either contains a fourth value.</param>
            <param name="five">The function to apply if the Either contains a fifth value.</param>
            <param name="six">The function to apply if the Either contains a sixth value.</param>
            <param name="seven">The function to apply if the Either contains a seventh value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Coalesce``9(Nordril.Functional.Data.Either{``0,``1,``2,``3,``4,``5,``6,``7},System.Func{``0,``8},System.Func{``1,``8},System.Func{``2,``8},System.Func{``3,``8},System.Func{``4,``8},System.Func{``5,``8},System.Func{``6,``8},System.Func{``7,``8})">
            <summary>
            Coalesces an <see cref="T:Nordril.Functional.Data.Either`8"/> into a single value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigthvalue.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="coproduct">The Either to coalesce.</param>
            <param name="one">The function to apply if the Either contains a first value.</param>
            <param name="two">The function to apply if the Either contains a second value.</param>
            <param name="three">The function to apply if the Either contains a third value.</param>
            <param name="four">The function to apply if the Either contains a fourth value.</param>
            <param name="five">The function to apply if the Either contains a fifth value.</param>
            <param name="six">The function to apply if the Either contains a sixth value.</param>
            <param name="seven">The function to apply if the Either contains a seventh value.</param>
            <param name="eight">The function to apply if the Either contains an eigth value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.One``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either1`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either1{``0})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Two``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either2`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either2{``1})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Three``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either1`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either3{``2})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Four``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either1`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either4{``3})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Five``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either5`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either5{``4})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Six``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either6`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either6{``5})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Seven``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either7`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either7{``6})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.Eight``1(``0)">
            <summary>
            Creates the <see cref="T:Nordril.Functional.Data.Either8`1"/>-consturctor. See the <see cref="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either8{``7})"/>-family of functions.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``1(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates a 1-element coproduct based on the <see cref="T:Nordril.Functional.Data.Either1`1"/>-constructor.
            </summary>
            <typeparam name="T1">The type of the value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``2(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`2"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``3(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`3"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``4(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`4"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``5(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`5"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``6(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`7"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either1{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the first value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``2(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`2"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``3(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`3"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``4(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`4"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``5(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`5"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``6(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`7"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either2{``1})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the second value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``3(Nordril.Functional.Data.Either3{``2})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`3"/> containing the third value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``4(Nordril.Functional.Data.Either3{``2})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`4"/> containing the third value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``5(Nordril.Functional.Data.Either3{``2})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`5"/> containing the third value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``6(Nordril.Functional.Data.Either3{``2})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the third value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either3{``2})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`7"/> containing the third value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either3{``2})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the third value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``4(Nordril.Functional.Data.Either4{``3})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`4"/> containing the fourth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``5(Nordril.Functional.Data.Either4{``3})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`5"/> containing the fourth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``6(Nordril.Functional.Data.Either4{``3})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the fourth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either4{``3})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`7"/> containing the fourth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either4{``3})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the fourth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``5(Nordril.Functional.Data.Either5{``4})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`5"/> containing the fifth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``6(Nordril.Functional.Data.Either5{``4})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the fifth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either5{``4})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`7"/> containing the fifth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either5{``4})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the fifth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``6(Nordril.Functional.Data.Either6{``5})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the sixth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either6{``5})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`6"/> containing the sixth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either6{``5})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the sixth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``7(Nordril.Functional.Data.Either7{``6})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`7"/> containing the seventh value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either7{``6})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the seventh value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherWith``8(Nordril.Functional.Data.Either8{``7})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Either`8"/> containing the eigth value.
            </summary>
            <typeparam name="T1">The type of the first value.</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
            <typeparam name="T3">The type of the third value.</typeparam>
            <typeparam name="T4">The type of the fourth value.</typeparam>
            <typeparam name="T5">The type of the fifth value.</typeparam>
            <typeparam name="T6">The type of the sixth value.</typeparam>
            <typeparam name="T7">The type of the seventh value.</typeparam>
            <typeparam name="T8">The type of the eigth value.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.ToEither``2(Nordril.Functional.Category.IBifunctor{``0,``1})">
            <summary>
            Tries to cast a generic bifunctor to an either via an explicit cast. Provided for convenience.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="f">The bifunctor.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either`2">
            <summary>
            A sum type that can either be a left or a right, but not both. While left and right have no special semantics, per convention,
            the left is regarded as the "error-case", and the right is regarded as the "ok-case", if the either is used to model failure.
            Available as a data-source in LINQ-queries.
            </summary>
            <typeparam name="TLeft">The type of the left value in the either.</typeparam>
            <typeparam name="TRight">The type of the right value in the either.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.IsLeft">
            <summary>
            Returns true iff the either contains a left value.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.IsRight">
            <summary>
            Returns true iff the either contains a right value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Left">
            <summary>
            Tries to get the left value in an either and throws an <see cref="T:Nordril.Functional.PatternMatchException"/> if the either is a right.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Right">
            <summary>
            Tries to get the right value in an either and throws an <see cref="T:Nordril.Functional.PatternMatchException"/> if the either is a left.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.Second">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this coproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.#ctor(`0,Nordril.Functional.Data.TagLeft)">
            <summary>
            Creates a new left-<see cref="T:Nordril.Functional.Data.Either`2"/> from a value. The type-level tag is required to disambiguate between constructors.
            </summary>
            <param name="value">The value to store in the either.</param>
            <param name="discriminator">The discriminator tag.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.#ctor(`1,Nordril.Functional.Data.TagRight)">
            <summary>
            Creates a new right-<see cref="T:Nordril.Functional.Data.Either`2"/> from a value. The type-level tag is required to disambiguate between constructors.
            </summary>
            <param name="value">The value to store in the either.</param>
            <param name="discriminator">The discriminator tag.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`2"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`2"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.FromLeft(`0)">
            <summary>
            Creates a left-either from a value.
            </summary>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.FromRight(`1)">
            <summary>
            Creates a right-either from a value.
            </summary>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Deconstruct(System.Boolean@,`0@,`1@)">
            <summary>
            Tuple deconstructor function.
            </summary>
            <param name="isLeft">True if this <see cref="T:Nordril.Functional.Data.Either`2"/> has a left-value, and false if it has a right-value.</param>
            <param name="left">The left-value, if present, or <c>default</c>.</param>
            <param name="right">The right-value, if present, or <c>default</c>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.SetLeft(`0)">
            <summary>
            Sets the either to a left, clearing the right, if present.
            </summary>
            <param name="left">The value to put into the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.SetRight(`1)">
            <summary>
            Sets the either to a right, clearing the left, if present.
            </summary>
            <param name="right">The value to put into the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.TryGetValue(`0@,`1@)">
            <summary>
            Returns whether this <see cref="T:Nordril.Functional.Data.Either`2"/> contains a left- or a right-value. If it contains a left-value, <paramref name="left"/> will contain the left-value and <paramref name="right"/> will be <c>default</c> and vice versa.
            </summary>
            <param name="left">The left-value, if it exists, otherwise <c>default</c>.</param>
            <param name="right">The right-value, if it exists, otherwise <c>default</c>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Swap">
            <summary>
            Turns a left-either into a right-either and vice versa.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.LeftOr(`0)">
            <summary>
            A safe way to get a either's left value. If <see cref="P:Nordril.Functional.Data.Either`2.IsLeft"/> is true, <see cref="M:Nordril.Functional.Data.Either`2.Left"/>
            is returned, otherwise, <paramref name="alternative"/> is returned.
            </summary>
            <param name="alternative">The value to return if the either is right.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.RightOr(`1)">
            <summary>
            A safe way to get a either's right value. If <see cref="P:Nordril.Functional.Data.Either`2.IsRight"/> is true, <see cref="M:Nordril.Functional.Data.Either`2.Right"/>
            is returned, otherwise, <paramref name="alternative"/> is returned.
            </summary>
            <param name="alternative">The value to return if the either is left.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Coalesce``1(System.Func{`0,``0},System.Func{`1,``0})">
            <summary>
            Coalesces an either to a single value. If the either is a left, the first function is applied. If it is a right,
            the second function is applied.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="f">The function to apply if the either is a left.</param>
            <param name="g">The function to apply if the either is a right.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`2"/>-objects based on their underlying values. This method returns true if both objects are left-eithers/right-eithers and if <see cref="M:System.Object.Equals(System.Object)"/> returns true for the underlying <see cref="M:Nordril.Functional.Data.Either`2.Left"/> or <see cref="M:Nordril.Functional.Data.Either`2.Right"/>, respectively.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.op_Equality(Nordril.Functional.Data.Either{`0,`1},Nordril.Functional.Data.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.op_Inequality(Nordril.Functional.Data.Either{`0,`1},Nordril.Functional.Data.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Equals(Nordril.Functional.Data.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.BiMap``2(System.Func{`0,``0},System.Func{`1,``1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.BindAsync``1(System.Func{`1,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`1,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.MapAsync``1(System.Func{`1,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either`3">
            <summary>
            A three-component <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
            <typeparam name="T1">The first component.</typeparam>
            <typeparam name="T2">The second component.</typeparam>
            <typeparam name="T3">The third component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`3.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`3.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`3.IsThird">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`3.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`3.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`3.Third">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`3"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`3"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.#ctor(Nordril.Functional.Data.Either3{`2})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`3"/>-coproduct out of a third value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`3"/>-objects based on their underlying values.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Equals(Nordril.Functional.Data.Either{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this coproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.BindAsync``1(System.Func{`2,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Bind``1(System.Func{`2,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`2,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`2,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.MapAsync``1(System.Func{`2,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.Map``1(System.Func{`2,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.op_Equality(Nordril.Functional.Data.Either{`0,`1,`2},Nordril.Functional.Data.Either{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`3.op_Inequality(Nordril.Functional.Data.Either{`0,`1,`2},Nordril.Functional.Data.Either{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either`4">
            <summary>
            A four-component <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
            <typeparam name="T1">The first component.</typeparam>
            <typeparam name="T2">The second component.</typeparam>
            <typeparam name="T3">The third component.</typeparam>
            <typeparam name="T4">The fourth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.IsThird">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.IsFourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.Third">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`4.Fourth">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`4"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`4"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.#ctor(Nordril.Functional.Data.Either3{`2})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`4"/>-coproduct out of a third value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.#ctor(Nordril.Functional.Data.Either4{`3})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`4"/>-coproduct out of a fourth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`4"/>-objects based on their underlying values.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Equals(Nordril.Functional.Data.Either{`0,`1,`2,`3})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this coproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.BindAsync``1(System.Func{`3,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Bind``1(System.Func{`3,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`3,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`3,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.MapAsync``1(System.Func{`3,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.Map``1(System.Func{`3,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.op_Equality(Nordril.Functional.Data.Either{`0,`1,`2,`3},Nordril.Functional.Data.Either{`0,`1,`2,`3})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`4.op_Inequality(Nordril.Functional.Data.Either{`0,`1,`2,`3},Nordril.Functional.Data.Either{`0,`1,`2,`3})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either`5">
            <summary>
            A five-component <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
            <typeparam name="T1">The first component.</typeparam>
            <typeparam name="T2">The second component.</typeparam>
            <typeparam name="T3">The third component.</typeparam>
            <typeparam name="T4">The fourth component.</typeparam>
            <typeparam name="T5">The fifth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.IsThird">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.IsFourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.IsFifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.Third">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.Fourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`5.Fifth">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`5"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`5"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.#ctor(Nordril.Functional.Data.Either3{`2})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`5"/>-coproduct out of a third value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.#ctor(Nordril.Functional.Data.Either4{`3})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`5"/>-coproduct out of a fourth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.#ctor(Nordril.Functional.Data.Either5{`4})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`5"/>-coproduct out of a fifth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`5"/>-objects based on their underlying values.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Equals(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this coproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.BindAsync``1(System.Func{`4,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Bind``1(System.Func{`4,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`4,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`4,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.MapAsync``1(System.Func{`4,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.Map``1(System.Func{`4,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.op_Equality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`5.op_Inequality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either`6">
            <summary>
            A six-component <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
            <typeparam name="T1">The first component.</typeparam>
            <typeparam name="T2">The second component.</typeparam>
            <typeparam name="T3">The third component.</typeparam>
            <typeparam name="T4">The fourth component.</typeparam>
            <typeparam name="T5">The fifth component.</typeparam>
            <typeparam name="T6">The sixth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.IsThird">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.IsFourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.IsFifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.IsSixth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.Third">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.Fourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.Fifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`6.Sixth">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`6"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.#ctor(Nordril.Functional.Data.Either3{`2})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`6"/>-coproduct out of a third value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.#ctor(Nordril.Functional.Data.Either4{`3})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`6"/>-coproduct out of a fourth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.#ctor(Nordril.Functional.Data.Either5{`4})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`6"/>-coproduct out of a fifth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.#ctor(Nordril.Functional.Data.Either6{`5})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`6"/>-coproduct out of a sixth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`6"/>-objects based on their underlying values.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Equals(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this coproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.BindAsync``1(System.Func{`5,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Bind``1(System.Func{`5,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`5,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`5,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.MapAsync``1(System.Func{`5,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.Map``1(System.Func{`5,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.op_Equality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`6.op_Inequality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either`7">
            <summary>
            A seven-component <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
            <typeparam name="T1">The first component.</typeparam>
            <typeparam name="T2">The second component.</typeparam>
            <typeparam name="T3">The third component.</typeparam>
            <typeparam name="T4">The fourth component.</typeparam>
            <typeparam name="T5">The fifth component.</typeparam>
            <typeparam name="T6">The sixth component.</typeparam>
            <typeparam name="T7">The seventh component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsThird">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsFourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsFifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsSixth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.IsSeventh">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.Third">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.Fourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.Fifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.Sixth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`7.Seventh">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either3{`2})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a third value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either4{`3})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a fourth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either5{`4})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a fifth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either6{`5})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a sixth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.#ctor(Nordril.Functional.Data.Either7{`6})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`7"/>-coproduct out of a seventh value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`7"/>-objects based on their underlying values.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Equals(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this coproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.BindAsync``1(System.Func{`6,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Bind``1(System.Func{`6,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`6,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`6,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.MapAsync``1(System.Func{`6,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.Map``1(System.Func{`6,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.op_Equality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`7.op_Inequality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either`8">
            <summary>
            An eight-component <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
            <typeparam name="T1">The first component.</typeparam>
            <typeparam name="T2">The second component.</typeparam>
            <typeparam name="T3">The third component.</typeparam>
            <typeparam name="T4">The fourth component.</typeparam>
            <typeparam name="T5">The fifth component.</typeparam>
            <typeparam name="T6">The sixth component.</typeparam>
            <typeparam name="T7">The seventh component.</typeparam>
            <typeparam name="T8">The eigth component.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsSecond">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsThird">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsFourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsFifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsSixth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsSeventh">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.IsEigth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.First">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Second">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Third">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Fourth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Fifth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Sixth">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Seventh">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Either`8.Eigth">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either1{`0})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a first value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either2{`1})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a second value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either3{`2})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a third value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either4{`3})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a fourth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either5{`4})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a fifth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either6{`5})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a sixth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either7{`6})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a seventh value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.#ctor(Nordril.Functional.Data.Either8{`7})">
            <summary>
            Constructors an <see cref="T:Nordril.Functional.Data.Either`8"/>-coproduct out of a eigth value.
            </summary>
            <param name="either">The value to wrap</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`8"/>-objects based on their underlying values.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.Equals(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6,`7})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.BindAsync``1(System.Func{`7,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.Bind``1(System.Func{`7,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`7,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`7,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.MapAsync``1(System.Func{`7,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.Map``1(System.Func{`7,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.op_Equality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6,`7},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6,`7})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`8.op_Inequality(Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6,`7},Nordril.Functional.Data.Either{`0,`1,`2,`3,`4,`5,`6,`7})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either1`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductFirst`1"/>.
            </summary>
            <typeparam name="T1">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either1`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either1`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either2`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductSecond`1"/>.
            </summary>
            <typeparam name="T2">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either2`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either2`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either3`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductThird`1"/>.
            </summary>
            <typeparam name="T3">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either3`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either3`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either4`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductFourth`1"/>.
            </summary>
            <typeparam name="T4">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either4`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either4`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either5`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductFifth`1"/>.
            </summary>
            <typeparam name="T5">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either5`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either5`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either6`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductSixth`1"/>.
            </summary>
            <typeparam name="T6">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either6`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either6`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either7`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductSeventh`1"/>.
            </summary>
            <typeparam name="T7">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either7`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either7`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either8`1">
            <summary>
            The Either-constructor for <see cref="T:Nordril.Functional.Category.ICoproductEigth`1"/>.
            </summary>
            <typeparam name="T8">The type of the value.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either8`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either8`1.#ctor(`0)">
            <summary>
            Wraps a new value.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.EitherCxt`1">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.Either`2"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods. See <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> for examples
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.EitherTag">
            <summary>
            A tag indicating the state of an <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.EitherTag.Left">
            <summary>
            Indicates that the either is a left.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.EitherTag.Right">
            <summary>
            Indicates that the either is a right.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.EitherTag8">
            <summary>
            The 8-valued either-tag.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.TagLeftRight">
            <summary>
            A type-level tag indicating "left" or "right".
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.TagLeftRight.#ctor">
            <summary>
            Empty, protected constructor.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.TagLeft">
            <summary>
            A type-level tag indicating "left" (as opposed to "right").
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TagLeft.Value">
            <summary>
            The tag's singleton value.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.TagRight">
            <summary>
            A type-level tag indicating "right" (as opposed to "left").
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TagRight.Value">
            <summary>
            The tag's singleton value.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Eq">
            <summary>
            Lifting to structural equality.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Eq.Make``1(``0,System.Func{``0,``0,System.Boolean})">
            <summary>
            Creates an <see cref="T:System.IEquatable`1"/> out of a value and an equality comparison function.
            </summary>
            <typeparam name="T">The type of the value to wrap.</typeparam>
            <param name="value">The value to wrap.</param>
            <param name="equals">The equality comparison function.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Eq`1">
            <summary>
            An <see cref="T:System.IEquatable`1"/>-wrapper around a type.
            </summary>
            <typeparam name="T">The type of the wrapped element.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Eq`1.Value">
            <summary>
            Gets the underlying value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Eq`1.#ctor(`0,System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="value">The underlying value.</param>
            <param name="equals">The equality comparison function.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Eq`1.Equals(Nordril.Functional.Data.Eq{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Eq`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Eq`1.op_Equality(Nordril.Functional.Data.Eq{`0},Nordril.Functional.Data.Eq{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Eq`1.op_Inequality(Nordril.Functional.Data.Eq{`0},Nordril.Functional.Data.Eq{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Eq`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Fun`2">
            <summary>
            A profunctor-wrapper for <see cref="T:System.Func`2"/>, needed for prisms.
            <see cref="T:Nordril.Functional.Data.Fun`2"/> is ismorphic to <see cref="T:System.Func`2"/>, but since it's a struct, it can implement
            interfaces, esp. <see cref="T:Nordril.Functional.Category.IProfunctor`2"/> (allowing a function to be prepended to its input and another to be appended to its output)
            and <see cref="T:Nordril.Functional.Category.IChoice`2"/> (allowing it to be lifted into <see cref="T:Nordril.Functional.Data.Either`2"/>).
            </summary>
            <typeparam name="TIn">The type of the input.</typeparam>
            <typeparam name="TOut">The type of the output.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Fun`2.Func">
            <summary>
            The underlying function.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="func">The function to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.ContraMap``1(System.Func{``0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.Promap``2(System.Func{``0,`0},System.Func{`1,``1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.ChooseLeft``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.ChooseRight``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.Make``2(System.Func{``0,``1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.TogetherWith``2(Nordril.Functional.Category.IArrow{``0,``1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.Id``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.Then``1(Nordril.Functional.Category.ICategory{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.LiftFirst``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Fun`2.LiftSecond``1">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.FuncDictionary`2">
            <summary>
            A wrapper around an arbitrary <see cref="T:System.Collections.Generic.IDictionary`2"/> which can determine equality based on the contained keys and values instead of by reference, and which implements various functional interfaces. Two <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/>-object are equal if they contain the same set of keys and, for every contained key, <see cref="M:System.Object.Equals(System.Object)"/> of the corresponding values returns true.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.FuncDictionary`2.dict">
            <summary>
            The underlying dictionary field.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.FuncDictionary`2.comparer">
            <summary>
            The comparer.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncDictionary`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/> from a pair of keys and values.
            </summary>
            <param name="keyComparer">A comparer for the keys.</param>
            <param name="pairs">The pairs to put into the dictionary.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/> from a pair of keys and values, and a custom comparer.
            </summary>
            <param name="pairs">The pairs to put into the dictionary.</param>
            <param name="keyComparer">The comparer for the keys. This must also implement <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</param>
            <param name="valueComparer">The equality comparer for the values.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/> from a pair of keys and values.
            </summary>
            <param name="keyComparer">The comparer for the keys. This must also implement <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</param>
            <param name="pairs">The pairs to put into the dictionary.</param>
        </member>
        <member name="P:Nordril.Functional.Data.FuncDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Equals(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Determines equality based on the contents of two <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/>-objects. Two objects are equal if they have the same set of keys and if, for every contained key, <see cref="M:System.IEquatable`1.Equals(`0)"/> of the values returns true.
            </summary>
            <param name="other">The other <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Equals(System.Object)">
            <summary>
            See <see cref="M:Nordril.Functional.Data.FuncDictionary`2.Equals(System.Collections.Generic.IDictionary{`0,`1})"/>.
            </summary>
            <param name="obj">The other oject.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.op_Equality(Nordril.Functional.Data.FuncDictionary{`0,`1},Nordril.Functional.Data.FuncDictionary{`0,`1})">
            <summary>
            See <see cref="M:Nordril.Functional.Data.FuncDictionary`2.Equals(System.Collections.Generic.IDictionary{`0,`1})"/>.
            </summary>
            <param name="left">The first object.</param>
            <param name="right">The second object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.op_Inequality(Nordril.Functional.Data.FuncDictionary{`0,`1},Nordril.Functional.Data.FuncDictionary{`0,`1})">
            <summary>
            See <see cref="M:Nordril.Functional.Data.FuncDictionary`2.Equals(System.Collections.Generic.IDictionary{`0,`1})"/>.
            </summary>
            <param name="left">The first object.</param>
            <param name="right">The second object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.GetHashCode">
            <summary>
            Computes the hash based on <see cref="M:Nordril.Functional.CollectionExtensions.HashElements``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.AddPure(`0,`1,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.RemovePure(`0,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.UpsertPure(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.UpdatePure(`0,System.Func{`0,`1,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.DictCoalesce">
            <summary>
            Retuns <see cref="F:Nordril.Functional.Data.FuncDictionary`2.dict"/>. If <see cref="F:Nordril.Functional.Data.FuncDictionary`2.dict"/> has not been assigned, it's set to a new, empty dictionary first.
            </summary>
            <remarks>
            If two callers hold references to this struct and <see cref="F:Nordril.Functional.Data.FuncDictionary`2.dict"/> has not been initialized yet, they will hold references to different dictionaries after this method returns.
            </remarks>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.ComparerCoalesce">
            <summary>
            Retuns <see cref="F:Nordril.Functional.Data.FuncDictionary`2.comparer"/>. If <see cref="F:Nordril.Functional.Data.FuncDictionary`2.comparer"/> has not been assigned, it's set to a new, default comparer first
            </summary>
            <remarks>
            If two callers hold references to this struct and <see cref="F:Nordril.Functional.Data.FuncDictionary`2.comparer"/> has not been initialized yet, they will hold references to different lists after this method returns.
            </remarks>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.Map``1(System.Func{`1,``0})">
            <summary>
            Applies a function to the values of the dictionary and returns the new dictionary, leaving the old one unchanged. If <typeparamref name="TValue"/> is different from <typeparamref name="TResult"/>, the value-comparer is downgraded to <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
            <typeparam name="TResult">The type of the new values.</typeparam>
            <param name="f">The function to apply to the values.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.MapWithKey``1(System.Func{`0,`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary`2.MonoMap(System.Func{`1,`1})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.FuncDictionary">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary.Select``3(Nordril.Functional.Data.FuncDictionary{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TKey">The type of the source's key.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary.Make``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/> based on the <see cref="T:System.IEquatable`1"/>-instances of the keys and values.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
            <param name="xs"></param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.FuncDictionary.Make``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncDictionary`2"/> based on the <see cref="T:System.IEquatable`1"/>-instances of the keys and values.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
            <param name="xs"></param>
            <returns></returns>
        </member>
        <member name="T:Nordril.Functional.Data.FuncList`1">
            <summary>
            A functional list. This class is a wrapper for <see cref="T:System.Collections.Generic.List`1"/> which implements various functional interfaces.
            </summary>
            <remarks>
            Because an <see cref="T:System.Collections.Generic.IEnumerable`1"/>-implementation is all we need for the operations of <see cref="T:Nordril.Functional.Category.IApplicative`1"/>, <see cref="T:Nordril.Functional.Category.IMonad`1"/>, etc. (thanks to LINQ), these operations have correspondingly relaxed constraints, and instead of <see cref="T:Nordril.Functional.Data.FuncList`1"/> as their parameter, they only require <see cref="T:System.Collections.Generic.IEnumerable`1"/>. This applies to <see cref="M:Nordril.Functional.Data.FuncList`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>, <see cref="M:Nordril.Functional.Data.FuncList`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>, and <see cref="M:Nordril.Functional.Data.FuncList`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})"/>.
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncList`1"/> from the elements of <paramref name="xs"/>, using <see cref="M:System.Object.Equals(System.Object)"/> for equality-comparisons among elements.
            </summary>
            <param name="xs">The elements to store in the list.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncList`1"/> with an initial capacity of <paramref name="capacity"/>, using <paramref name="comparer"/> for equality-comparisons among elements, or <see cref="M:System.Object.Equals(System.Object)"/> is <paramref name="comparer"/> is null.
            </summary>
            <param name="capacity">The initial capacity of the list.</param>
            <param name="comparer">The equality comparer for the list's elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncList`1"/> from the elements of <paramref name="xs"/>, using <paramref name="comparer"/> for equality-comparisons among elements, or <see cref="M:System.Object.Equals(System.Object)"/> is <paramref name="comparer"/> is null.
            </summary>
            <param name="xs">The elements to store in the list.</param>
            <param name="comparer">The equality comparer for the list's elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncList`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a sequence of elements in order to this list.
            </summary>
            <param name="xs">The elements to add.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Gets a shallow copy of a range of elements from this list.
            </summary>
            <param name="index">The index from which to start the range.</param>
            <param name="count">The number of elements to get, starting from <paramref name="index"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncList`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Mzero">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.MapWithKey``1(System.Func{System.Int32,`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Filter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Empty">
            <summary>
            Returns an empty list.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <summary>
            Concatenates two lists. <paramref name="x"/> only has to be an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, not a <see cref="T:Nordril.Functional.Data.IFuncList`1"/>.
            </summary>
            <param name="x">The other sequence.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Equals(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetComparer``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Copy">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.ListCoalesce">
            <summary>
            Retuns <see cref="F:Nordril.Functional.Data.FuncList`1.list"/>. If <see cref="F:Nordril.Functional.Data.FuncList`1.list"/> has not been assigned, it's set to a new, empty list first.
            </summary>
            <remarks>
            If two callers hold references to this struct and <see cref="F:Nordril.Functional.Data.FuncList`1.list"/> has not been initialized yet, they will hold references to different lists after this method returns.
            </remarks>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.ComparerCoalesce">
            <summary>
            Retuns <see cref="F:Nordril.Functional.Data.FuncList`1.comparer"/>. If <see cref="F:Nordril.Functional.Data.FuncList`1.comparer"/> has not been assigned, it's set to a new, default comparer first
            </summary>
            <remarks>
            If two callers hold references to this struct and <see cref="F:Nordril.Functional.Data.FuncList`1.comparer"/> has not been initialized yet, they will hold references to different lists after this method returns.
            </remarks>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Traverse``2(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Traverse``1(System.Type,System.Func{`0,Nordril.Functional.Category.IApplicative{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.TraverseMaybe``2(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.TraverseMaybe``1(System.Type,System.Func{`0,Nordril.Functional.Category.IApplicative{Nordril.Functional.Data.Maybe{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.MapMaybe``1(System.Func{`0,Nordril.Functional.Data.Maybe{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.op_Equality(Nordril.Functional.Data.FuncList{`0},Nordril.Functional.Data.FuncList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.op_Inequality(Nordril.Functional.Data.FuncList{`0},Nordril.Functional.Data.FuncList{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.FuncList">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.FuncList`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.Select``2(Nordril.Functional.Data.FuncList{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.FuncList`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.SelectMany``3(Nordril.Functional.Data.FuncList{``0},System.Func{``0,Nordril.Functional.Data.FuncList{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.FuncList`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.FuncList{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.FuncList`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Data.FuncList{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Data.FuncList{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.FuncList`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.Make``1(``0[])">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncList`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="elements">The list of elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.ToFuncList``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.IFuncList`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.FuncSet`1">
            <summary>
            A functional set. This class is a wrapper for <see cref="T:System.Collections.Generic.HashSet`1"/> which implements various functional interfaces.
            </summary>
            <remarks>
            Because an <see cref="T:System.Collections.Generic.IEnumerable`1"/>-implementation is all we need for the operations of <see cref="T:Nordril.Functional.Category.IApplicative`1"/>, <see cref="T:Nordril.Functional.Category.IMonad`1"/>, etc. (thanks to LINQ), these operations have correspondingly relaxed constraints, and instead of <see cref="T:Nordril.Functional.Data.FuncList`1"/> as their parameter, they only require <see cref="T:System.Collections.Generic.IEnumerable`1"/>. This applies to <see cref="M:Nordril.Functional.Data.FuncSet`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>, <see cref="M:Nordril.Functional.Data.FuncSet`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.FuncSet`1.Comparer">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncSet`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncSet`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncSet`1"/> from the elements of <paramref name="xs"/>, using <see cref="M:System.Object.Equals(System.Object)"/> for equality-comparisons among elements.
            </summary>
            <param name="xs">The elements to store in the list.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncSet`1"/> from the elements of <paramref name="xs"/>, using <paramref name="comparer"/> for equality-comparisons among elements, or <see cref="M:System.Object.Equals(System.Object)"/> if <paramref name="comparer"/> is null.
            </summary>
            <param name="xs">The elements to store in the list.</param>
            <param name="comparer">The equality comparer for the list's elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.AddPure(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.DifferencePure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Equals(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Equals(Nordril.Functional.Data.IFuncSet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Filter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IntersectionPure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.RemovePure(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.SymmetricDifferencePure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.UnionPure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.GetComparer``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Copy">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.ReplaceEqualityComparer(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Conditionally returns either <paramref name="that"/> that or, if its <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is not reference-equals to ours, a copy with an equality-comparer that is reference-equals to ours. The point of this is so that set-theoretical operations use our equality-comparer instead of defaulting to reference-equality for elements if the equality-comparer of <paramref name="that"/> differs from ours (this behavior is from the .NET reference source).
            See https://referencesource.microsoft.com/system.core/system/Collections/Generic/HashSet.cs.html (AreEqualityComparersEqual and the functions which use it).
            </summary>
            <param name="that">The set whose equality-comparer to replace.</param>
            <returns>Either <paramref name="that"/> or a copy with its equality-comparer replaced.</returns>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.op_Equality(Nordril.Functional.Data.FuncSet{`0},Nordril.Functional.Data.FuncSet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.op_Inequality(Nordril.Functional.Data.FuncSet{`0},Nordril.Functional.Data.FuncSet{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.FuncSet">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.FuncSet`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.Select``2(Nordril.Functional.Data.FuncSet{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.FuncSet`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.SelectMany``3(Nordril.Functional.Data.FuncSet{``0},System.Func{``0,Nordril.Functional.Data.FuncSet{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.FuncSet`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.FuncSet{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.FuncSet`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Data.FuncSet{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Data.FuncSet{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.FuncSet`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.Make``1(``0[])">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncSet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
            <param name="elements">The set of elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.ToFuncSet``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.IFuncSet`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Identity`1">
            <summary>
            The identity functor which does nothing but wrap a value.
            This is equivalent to a one-value <see cref="T:Nordril.Functional.Data.Either`2"/>.
            Available as a data-source in LINQ-queries.
            </summary>
            <typeparam name="T">The type of the value being wrapped.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Identity`1.Value">
            <summary>
            Gets or sets the wrapped value.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Identity`1.IsFirst">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Identity`1.First">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.#ctor(`0)">
            <summary>
            Creates a new identity.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Equals(System.Object)">
            <summary>
            Determines equality based on the underlying <see cref="P:Nordril.Functional.Data.Identity`1.Value"/>.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.op_Equality(Nordril.Functional.Data.Identity{`0},Nordril.Functional.Data.Identity{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.op_Inequality(Nordril.Functional.Data.Identity{`0},Nordril.Functional.Data.Identity{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Equals(Nordril.Functional.Data.Identity{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Extend``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Extends this 1-elementcoproduct with an additional component, returning the a copy of the original coproduct if <paramref name="value"/> is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a coproduct containing <paramref name="value"/> if it is <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="TNew">The type by which to extend this coproduct.</typeparam>
            <param name="value">The optional value by which to extend this coproduct.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Traverse``2(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Traverse``1(System.Type,System.Func{`0,Nordril.Functional.Category.IApplicative{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Identity">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Identity`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.Select``2(Nordril.Functional.Data.Identity{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Identity`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.SelectMany``3(Nordril.Functional.Data.Identity{``0},System.Func{``0,Nordril.Functional.Data.Identity{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Io`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.Identity{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Identity`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.Make``1(``0)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Identity`1"/>.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Data.Identity{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Data.Identity{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Identity`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Identity.IdentityIso`1">
            <summary>
            An isomorphism between <see cref="T:Nordril.Functional.Data.Identity`1"/> and any type.
            </summary>
            <typeparam name="T">The underlying type to wrap.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.ToIdentity``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.Identity`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.Iso``1">
            <summary>
            Returns an isomorphism between <see cref="T:System.Func`1"/> and <see cref="T:Nordril.Functional.Data.Io`1"/>.
            </summary>
            <typeparam name="T">The type of the result of computation.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.IFuncDictionary`2">
            <summary>
            A dictionary which supports pure operations which do not modify the original.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncDictionary`2.AddPure(`0,`1,System.Boolean@)">
            <summary>
            Returns a new dictionary to which the pair (<paramref name="key"/>, <paramref name="value"/>) has been added, leaving the original unmodified. <paramref name="success"/> is true if the key was not present in the original.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <param name="success">true if the key was not present in the original, false otherwise.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncDictionary`2.RemovePure(`0,System.Boolean@)">
            <summary>
            Returns a new dictionary from which <paramref name="key"/>has been removed, leaving the original unmodified. <paramref name="success"/> is true if the key was present in the original.
            </summary>
            <param name="key">The key to remove.</param>
            <param name="success">true if the key was present in the original, false otherwise.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncDictionary`2.UpsertPure(`0,`1)">
            <summary>
            Returns a new dictionary to which the pair (<paramref name="key"/>, <paramref name="value"/>) has been added if the key was not present, or one where the value of the key <paramref name="key"/> has been overwritten by <paramref name="value"/> if it was, leaving the original unmodified.
            </summary>
            <param name="key">The key to add/update.</param>
            <param name="value">The value to add/update.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncDictionary`2.UpdatePure(`0,System.Func{`0,`1,`1})">
            <summary>
            Returns a new dictionary in which the value of the key <paramref name="key"/> has been set to the result of <paramref name="f"/> if it was present, leaving the original unmodified.
            </summary>
            <param name="key">The key whose value to update.</param>
            <param name="f">The function whose result will be the new value. The first parameter is the key, the second is the old value.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IFuncList`1">
            <summary>
            A "functional list" which, in addition to supporting the operations <see cref="T:System.Collections.Generic.IList`1"/>, implements <see cref="T:Nordril.Functional.Category.IMonadPlus`1"/> (and parent interfaces), <see cref="T:Nordril.Functional.Category.IAlternative`1"/>, and <see cref="T:Nordril.Functional.Category.IFoldable`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.IFuncSet`1">
            <summary>
            A "functional set" which, in addition to supporting the operations <see cref="T:System.Collections.Generic.ISet`1"/>, implements <see cref="T:Nordril.Functional.Category.IMonad`1"/> (and parent interfaces).
            </summary>
            <remarks>Be aware that the equality comparer of the <em>left</em> set is used for determining element-equality for all set-theoretical operations. If the right set has a different equality comparer, this behavior will violate the expected theory of equivalence relations, e.g. you might have the situation where <c>S.Equals(T) != T.Equals(S)</c> or <c>S.Except(T).UnionPure(T.Except(S)) != S.SymmetricDifferencePure(T)</c>. This is a conscious design choice, intended to allow you to use the equality comparer of your choice, and you should interpret all set-theoretical operations as modulo the equality comparer of the left set.</remarks>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.IFuncSet`1.Comparer">
            <summary>
            Returns the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> of the set.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.AddPure(`0)">
            <summary>
            Returns a new set to which <paramref name="elem"/> has been added, while leaving this set unchanged.
            </summary>
            <param name="elem">The element to add.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.RemovePure(`0)">
            <summary>
            Returns a new set from which <paramref name="elem"/> has been removed, while leaving this set unchanged.
            </summary>
            <param name="elem">The element to remove.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.UnionPure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns the union of this set and <paramref name="elem"/>, while leaving this set unchanged.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.IntersectionPure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns the intersection of this set and <paramref name="elem"/>, while leaving this set unchanged.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.DifferencePure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns the difference between this set and <paramref name="elem"/>, while leaving this set unchanged.
            The difference is set the of those elements which are contained in this set but not in <paramref name="elem"/>.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.SymmetricDifferencePure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns a new set which is the symmetric difference of this set and <paramref name="elem"/>, while leaving this set unchanged.
            The symmetric differnce is the set of those elements which are in one set but not both.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.GetComparer``1">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IComparer`1"/> for <see cref="T:System.Collections.Generic.ISet`1"/>s if the contained elements of type <typeparamref name="T1"/> are comparable.
            </summary>
            <typeparam name="T1">The of element in the <see cref="T:System.Collections.Generic.ISet`1"/>.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Io`1">
            <summary>
            A value which has an arbitrary computation (mainly Io) attached to it. This corresponds to <see cref="T:System.Func`1"/>, since in C#, any function can perform Io without declaring that fact in its type; however, this type enables one to build lazy pipelines via the <see cref="T:Nordril.Functional.Category.IMonad`1"/>-functionality, like mapping over the result while executing the attached action, run a multi-argument function over the results of computations, and composing functions. The boilerplate which this type takes care of is essentially that of function composition.
            </summary>
            <example>
            Suppose we have two actions: one which reads from the command-line and one which writes to it. We then assemble a computation which first reads two numbers from the command-line, adds them, and prints out the results:
            <code>
                var read = Io.ToIo(() => Console.ReadLine()).Map(int.Parse).ToIo();
                var write = ((int x) => Console.WriteLine(x)).AsIoAction();
                
                var pipeline = read.Bind(x => read.Bind(y => write(x,y))).ToIo();
                
                //So far, nothing has been read from or written to console, pipeline is a delayed computation.
                
                //Now we run it
                pipeline.Run();
                //Results:
                //&lt;read line&gt; 5
                //&lt;read line&gt; 3
                //&lt;write line&gt; 8
            </code>
            </example>
            <typeparam name="T">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Io`1"/> out of a <see cref="T:System.Func`1"/>.
            </summary>
            <param name="value">The synchronous function which constitutes this computation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Io`1"/> out of a <see cref="T:System.Func`1"/>.
            </summary>
            <param name="value">The asynchronous function which constitutes this computation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.Run">
            <summary>
            Returns the result of the computation, while also performing the side-effect.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <summary>
            Chains another <see cref="T:Nordril.Functional.Data.Io`1"/>-computation to this one.
            </summary>
            <typeparam name="TResult">The type of the result of the second computation.</typeparam>
            <param name="f">A function which takes the result of this computation and returns a new one. The return-type of the function has to be <see cref="T:Nordril.Functional.Data.Io`1"/> with type <typeparamref name="TResult"/>, otherwise, an <see cref="T:System.InvalidCastException"/> is thrown.</param>
            <exception cref="T:System.InvalidCastException">If the result of <paramref name="f"/> isn't <see cref="T:Nordril.Functional.Data.Io`1"/> with type <typeparamref name="TResult"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.BindFunc``1(System.Func{`0,``0})">
            <summary>
            Chains a function to this computation, with the same semantics as <see cref="M:Nordril.Functional.Data.Io`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>, i.e. lazily.
            </summary>
            <typeparam name="TResult">The type of the result of the second computation.</typeparam>
            <param name="f">The function which takes the argument of this computation and returns a result, possibly performing side-effects.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.BindAction(System.Action{`0})">
            <summary>
            Chains an <see cref="T:System.Action`1"/> to this computation, with the same semantics as <see cref="M:Nordril.Functional.Data.Io`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>, i.e. lazily, and returns <see cref="T:Nordril.Functional.Data.Unit"/> as the overall result.
            </summary>
            <param name="f">The function which takes the argument of this computation and returns no result, possibly performing side-effects.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Io`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Io">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Io`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Io.Select``2(Nordril.Functional.Data.Io{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Io`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.SelectMany``3(Nordril.Functional.Data.Io{``0},System.Func{``0,Nordril.Functional.Data.Io{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Io`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.Io{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Io`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Data.Io{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Data.Io{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Io`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Io.IoIso`1">
            <summary>
            An isomorphism between <see cref="T:Nordril.Functional.Data.Io`1"/> and <see cref="T:System.Func`2"/>.
            </summary>
            <typeparam name="T">The underlying type to wrap.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Io.Pure``1(``0)">
            <summary>
            Returns a value as <see cref="T:Nordril.Functional.Data.Io`1"/>, without performing any side-effects. Shorthand for <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            </summary>
            <typeparam name="T">The type of the value to wrap in <see cref="T:Nordril.Functional.Data.Io`1"/>.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.AsIo``1(System.Func{``0})">
            <summary>
            Wraps a function into an <see cref="T:Nordril.Functional.Data.Io`1"/>.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="f">The function to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.AsIo``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Wraps an asynchronous function into an <see cref="T:Nordril.Functional.Data.Io`1"/>.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="f">The function to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.LiftIoFunc``2(System.Func{``0,``1})">
            <summary>
            Lifts a <see cref="T:System.Func`2"/> into a function which takes a value of type <typeparamref name="T"/> and returns a value of type <typeparamref name="TResult"/> into a function which takes a value of type <typeparamref name="T"/> and returns an <see cref="T:Nordril.Functional.Data.Io`1"/>. Useful for <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/> on <see cref="T:Nordril.Functional.Data.Io`1"/>-computations.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift into <see cref="T:Nordril.Functional.Data.Io`1"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.LiftIoAction``2(System.Action{``0})">
            <summary>
            Lifts an <see cref="T:System.Action`2"/> into a function which takes a value of type <typeparamref name="T"/> into a function which takes a value of type <typeparamref name="T"/> and returns an <see cref="T:Nordril.Functional.Data.Io`1"/> with no result. Useful for <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/> on <see cref="T:Nordril.Functional.Data.Io`1"/>-computations.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift into <see cref="T:Nordril.Functional.Data.Io`1"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.ToIo``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Io`1"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="T">The type of the value contained in the functor.</typeparam>
            <param name="f">The functor to cast to a maybe.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Io.Iso``1">
            <summary>
            Returns an isomorphism between <see cref="T:System.Func`1"/> and <see cref="T:Nordril.Functional.Data.Io`1"/>.
            </summary>
            <typeparam name="T">The type of the result of computation.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Io.Unwrap``1(Nordril.Functional.Data.Io{``0})">
            <summary>
            Unwraps an <see cref="T:Nordril.Functional.Data.Io`1"/> into a <see cref="T:System.Func`1"/>.
            </summary>
            <typeparam name="T">The type of the result of the computation.</typeparam>
            <param name="io">The computation to unwrap.</param>
        </member>
        <member name="T:Nordril.Functional.Data.ISliceable`1">
            <summary>
            Data structures which can be cheaply sliced into sub-data-structures.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.ISliceable`1.Slice(System.Int32)">
            <summary>
            Gets a slice of the data structure, starting with the index <paramref name="index"/>.
            </summary>
            <param name="index">The first index which should be included in the slice.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.ISliceable`1.Slice(System.Int32,System.Int32)">
            <summary>
            Gets a slice of the data structure, starting with the index <paramref name="index"/> and containing <paramref name="count"/> elements.
            </summary>
            <param name="index">The first index which should be included in the slice.</param>
            <param name="count">The number of elements, starting from <paramref name="index"/>, to include.</param>
            <exception cref="T:System.IndexOutOfRangeException">If the data structure does not contain enough elements.</exception>
        </member>
        <member name="T:Nordril.Functional.Data.IVisitable`2">
            <summary>
            Visitable structures which allow traversal of their elements, and the calling of a visit-function at each.
            For constructing visitors, see <see cref="T:Nordril.Functional.Data.VisitorFactory"/>.
            Implementors must obey the following:
            <list type="number">
                <item>The order in which the elements of the structure are visited by <see cref="M:Nordril.Functional.Data.IVisitable`2.Visit(Nordril.Functional.Data.IVisitor{`0})"/> is the same in which they would be folded.</item>
            </list>
            </summary>
            <typeparam name="T">The type of element in the structure.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IVisitable`2.Visit(Nordril.Functional.Data.IVisitor{`0})">
            <summary>
            Traverses the structure and calls the visitor at each element.
            </summary>
            <param name="visitor">The visitor to call.</param>
            <returns>The structure-specific result.</returns>
        </member>
        <member name="T:Nordril.Functional.Data.IForwardVisitable`3">
            <summary>
            Visitable structures which signal when the traversal moves forward. <see cref="M:Nordril.Functional.Data.IVisitable`2.Visit(Nordril.Functional.Data.IVisitor{`0})"/> only tells the visitor when an element is visited, but without any additional context. <see cref="M:Nordril.Functional.Data.IForwardVisitable`3.VisitForward(Nordril.Functional.Data.IForwardVisitor{`0,`1})"/> tells the visitor between which two elements the traversal is moving. On its own, this interface is not very useful and <see cref="T:Nordril.Functional.Data.IBidirectionalVisitable`4"/> is more often appropriate, esp. with non-linear structures likes trees or graphs, where it might matter whence one comes and whither one moves.
            For constructing visitors, see <see cref="T:Nordril.Functional.Data.VisitorFactory"/>.
            </summary>
            <typeparam name="T">The type of element in the structure.</typeparam>
            <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IForwardVisitable`3.VisitForward(Nordril.Functional.Data.IForwardVisitor{`0,`1})">
            <summary>
            Traverses the structure and calls the visitor at each element, and when moving forward from one element to the next.
            Implementors must make following operations identical (in the result and the observable effects, save for those caused by <see cref="M:Nordril.Functional.Data.IForwardVisitor`2.Forward(`0,`1)"/>):
            <code>
               x.Visit(v) and x.VisitForward(v)
            </code>
            </summary>
            <param name="visitor">The visitor to call.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IBackwardVisitable`3">
            <summary>
            Visitable structures which signal when the traversal moves backward. <see cref="M:Nordril.Functional.Data.IVisitable`2.Visit(Nordril.Functional.Data.IVisitor{`0})"/> only tells the visitor when an element is visited, but without any additional context. <see cref="M:Nordril.Functional.Data.IBackwardVisitable`3.VisitBackward(Nordril.Functional.Data.IBackwardVisitor{`0,`1})"/> tells the visitor between which two elements the traversal is moving. On its own, this interface is not very useful and <see cref="T:Nordril.Functional.Data.IBidirectionalVisitable`4"/> is more often appropriate, esp. with non-linear structures likes trees or graphs, where it might matter whence one comes and whither one moves.
            For constructing visitors, see <see cref="T:Nordril.Functional.Data.VisitorFactory"/>.
            </summary>
            <typeparam name="T">The type of element in the structure.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IBackwardVisitable`3.VisitBackward(Nordril.Functional.Data.IBackwardVisitor{`0,`1})">
            <summary>
            Traverses the structure and calls the visitor at each element, and when moving backwards from one element to the previous.
            Implementors must make following operations identical (in the result and the observable effects, save for those caused by <see cref="M:Nordril.Functional.Data.IBackwardVisitor`2.Backward(`1)"/>):
            <code>
               x.Visit(v) and x.Reverse.VisitBackward(v)
            </code>
            </summary>
            <param name="visitor">The visitor to call.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IBidirectionalVisitable`4">
             <summary>
            A data structure which is both <see cref="T:Nordril.Functional.Data.IForwardVisitable`3"/> and <see cref="T:Nordril.Functional.Data.IBackwardVisitable`3"/>.
             For constructing visitors, see <see cref="T:Nordril.Functional.Data.VisitorFactory"/>.
             </summary>
             <typeparam name="T">The type of element in the structure.</typeparam>
             <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
             <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
             <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IBidirectionalVisitable`4.VisitBidirectional(Nordril.Functional.Data.IBidirectionalVisitor{`0,`1,`2})">
            <summary>
            Traverses the structure calls the visitor at each element, and when moving forward from one element to the next, and when moving backwards from one element to the previous.
            </summary>
            <param name="visitor">The visitor to call.</param>
        </member>
        <member name="T:Nordril.Functional.Data.ITreeVisitable`5">
            <summary>
            Implementors of <see cref="T:Nordril.Functional.Data.IBidirectionalVisitable`4"/> which also support a custom visitation-order. The typical example are trees, which support pre- and post-order traversal.
            </summary>
            <typeparam name="T">The type of element in the structure.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <typeparam name="TOrder">The type of the traversal-order.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.ITreeVisitable`5.VisitBidirectional(Nordril.Functional.Data.IBidirectionalVisitor{`0,`1,`2},`4)">
            <summary>
            Traverses the structure calls the visitor at each element, and when moving forward from one element to the next, and when moving backwards from one element to the previous.
            </summary>
            <param name="visitor">The visitor to call.</param>
            <param name="order">The order of the traversal.</param>
        </member>
        <member name="T:Nordril.Functional.Data.TreeVisitableExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.ITreeVisitable`5"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.TreeVisitableExtensions.TraverseTree``5(Nordril.Functional.Data.ITreeVisitable{``0,``1,``2,``3,``4},``4)">
            <summary>
            Traverses the tree without performing any visitation-actions, just returning the result.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement.</typeparam>
            <typeparam name="TTo">The type of the element which indicates the target of a forward-movement.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <typeparam name="TOrder"></typeparam>
            <param name="tree"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:Nordril.Functional.Data.IVisitor`1">
            <summary>
            A visitor which can be used by an implementor of <see cref="T:Nordril.Functional.Data.IVisitable`2"/>.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IVisitor`1.At(`0)">
            <summary>
            The function to call when an element is visited.
            </summary>
            <param name="x">The element being visited.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IForwardVisitor`2">
            <summary>
            A visitor which can be used by an implementor of <see cref="T:Nordril.Functional.Data.IForwardVisitable`3"/>.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IForwardVisitor`2.Forward(`0,`1)">
            <summary>
            The function to call when moving from one element to the next.
            </summary>
            <param name="x">The element being visited.</param>
            <param name="to">The next element.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IBackwardVisitor`2">
            <summary>
            A visitor which can be used by an implementor of <see cref="T:Nordril.Functional.Data.IForwardVisitable`3"/>.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IBackwardVisitor`2.Backward(`1)">
            <summary>
            The function to call when moving from one element to the previous.
            </summary>
            <param name="from">The previous element.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IBidirectionalVisitor`3">
            <summary>
            A bi-directional visitor.
            </summary>
            <typeparam name="T">The type of element in the structure.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.VisitorFactory">
            <summary>
            A factory for visitors.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.VisitorFactory.MakeVisitor``1(System.Action{``0})">
            <summary>
            Makes an <see cref="T:Nordril.Functional.Data.IVisitor`1"/>.
            </summary>
            <typeparam name="T">The type of element in the structure being visited.</typeparam>
            <param name="at">The function to call when an element is visited.</param>
        </member>
        <member name="M:Nordril.Functional.Data.VisitorFactory.MakeForwardVisitor``2(System.Action{``0},System.Action{``0,``1})">
            <summary>
            Makes an <see cref="T:Nordril.Functional.Data.IForwardVisitor`2"/>.
            </summary>
            <typeparam name="T">The type of element in the structure being visited.</typeparam>
            <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <param name="at">The function to call when an element is visited.</param>
            <param name="forward">The function to call when moving from one element to the next.</param>
        </member>
        <member name="M:Nordril.Functional.Data.VisitorFactory.MakeBackwardVisitor``2(System.Action{``0},System.Action{``1})">
             <summary>
             Makes an <see cref="T:Nordril.Functional.Data.IBackwardVisitor`2"/>.
             </summary>
             <typeparam name="T">The type of element in the structure being visited.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
             <param name="at">The function to call when an element is visited.</param>
             <param name="backward">The function to call when moving from one element to the previous.</param>
        </member>
        <member name="M:Nordril.Functional.Data.VisitorFactory.MakeVisitor``3(System.Action{``0},System.Action{``0,``2},System.Action{``1})">
             <summary>
             Makes an <see cref="T:Nordril.Functional.Data.IBidirectionalVisitor`3"/>.
             </summary>
             <typeparam name="T">The type of element in the structure being visited.</typeparam>
            <typeparam name="TFrom">The type of element which indicates the target of a backward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
            <typeparam name="TTo">The type of element which indicates the target of a forward-movement. This might be the same as <typeparamref name="T"/>, or, say, a integer-index.</typeparam>
             <param name="at">The function to call when an element is visited.</param>
             <param name="forward">The function to call when moving from one element to the next.</param>
             <param name="backward">The function to call when moving from one element to the previous.</param>
        </member>
        <member name="T:Nordril.Functional.Data.LexicographicalComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IComparer`1"/> which lexicographically compares two sequences of elements. If the elements in the shorter sequence are all equal according to the comparison, the longer sequence counts as the greater one.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.LexicographicalComparer`1.elementComparer">
            <summary>
            The underlying elementwise comparer.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.LexicographicalComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Creates a new comparer.
            </summary>
            <param name="elementComparer">The comparison function for two elements of the sequences.</param>
        </member>
        <member name="M:Nordril.Functional.Data.LexicographicalComparer`1.Compare(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.ListEqualityComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which compares two sequences of elements for structural equality.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.ListEqualityComparer`1.elementComparer">
            <summary>
            The underlying elementwise comparer.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.ListEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates a new comparer.
            </summary>
            <param name="elementComparer">The comparison function for two elements of the sequences.</param>
        </member>
        <member name="M:Nordril.Functional.Data.ListEqualityComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.ListEqualityComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Lst`1">
            <summary>
            A thread-safe, immutable list supporting cheap deconstruction/slicing/appending.
            </summary>
            <typeparam name="T">The type of the contents.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Lst`1.LstDisposeHandler">
            <summary>
            The handler for when this list is disposed, with the slice that the list had of the underlying list.
            </summary>
            <param name="startIncl">The start-index of this list's slice.</param>
            <param name="endExcl">The exclusive end-index of this list's slice.</param>
        </member>
        <member name="E:Nordril.Functional.Data.Lst`1.OnDisposing">
            <summary>
            Gets called when this list is disposed.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new, immutable list from a shallow copy of <paramref name="xs"/>, using the comparer <paramref name="comparer"/>.
            </summary>
            <param name="xs">The items to shallowly copy.</param>
            <param name="comparer">The comparer. If null, <see cref="M:System.Object.Equals(System.Object,System.Object)"/> will be used for element-comparison.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Dispose">
            <summary>
            Disposes the list and, perhaps, compacts the underlying list.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Lst`1.Head">
            <summary>
            Gets the first element of the list, if it exists.
            O(1).
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Lst`1.Tail">
            <summary>
            Gets the list excluding its first element, if it has at least one element.
            O(1).
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Lst`1.HeadUnsafe">
            <summary>
            Unsafely gets the first element of a list.
            O(1).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If the list if empty.</exception>
        </member>
        <member name="P:Nordril.Functional.Data.Lst`1.TailUnsafe">
            <summary>
            Unsafely gets the list excluding its first element, if it has at least one element.
            O(1).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">If the list if empty.</exception>
        </member>
        <member name="P:Nordril.Functional.Data.Lst`1.Count">
            <summary>
            Gets the number of elements in the list.
            O(1).
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.ElementAt(System.Int32)">
            <summary>
            Gets the element at the index <paramref name="index"/>, if it exists.
            O(1).
            </summary>
            <param name="index">The index of the element to get.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Append(`0)">
            <summary>
            Appends an element at the end of the list.
            O(n). Ω(1) if this list is not a slice/tail of a larger list.
            </summary>
            <param name="item">The item to append.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.AppendRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Appends a sequence of elements at the end of the list.
            O(n+m). Ω(m) where m is the number of elements to append if this list is not a slice/tail of a larger list.
            </summary>
            <param name="item">The elements to append.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Prepend(`0)">
            <summary>
            Prepends an element to the beginning of the list.
            O(n).
            </summary>
            <param name="item">The element to prepend.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.PrependRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Prepends an element to the beginning of the list.
            O(n+m), where m is the number of elements to prepend.
            </summary>
            <param name="item">The element to prepend.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Slice(System.Int32)">
            <summary>
            Gets the list starting with the index <paramref name="index"/>.
            O(1).
            </summary>
            <param name="index">The index of the first element to get.</param>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> lies outside of the list.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Slice(System.Int32,System.Int32)">
            <summary>
            Gets the list starting with the index <paramref name="index"/>, containing <paramref name="count"/> elements.
            O(1).
            </summary>
            <param name="index">The index of the first element to get.</param>
            <param name="count">The number of elements, starting with the element at index <paramref name="index"/>, to include.</param>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> lies outside of the list or if the list does not have <paramref name="count"/> elements started from <paramref name="index"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Mzero">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.MapWithKey``1(System.Func{System.Int32,`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Filter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Empty">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Equals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Lst`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Lst">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Lst`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.Select``2(Nordril.Functional.Data.Lst{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Lst`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.SelectMany``3(Nordril.Functional.Data.Lst{``0},System.Func{``0,Nordril.Functional.Data.Lst{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Lst`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.Lst{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Lst`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Data.Lst{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Data.Lst{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Lst`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.MakeLst``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Lst`1"/> out of a sequence.
            </summary>
            <typeparam name="T">The type of the elements in the sequence.</typeparam>
            <param name="xs">The elements of the sequence.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.MakeLst``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Lst`1"/> out of a sequence, with a custom <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for equality-checking.
            </summary>
            <typeparam name="T">The type of the elements in the sequence.</typeparam>
            <param name="xs">The elements of the sequence.</param>
            <param name="comparer">The comparer to use.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.Make``1(``0[])">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Lst`1"/> out of a sequence.
            </summary>
            <typeparam name="T">The type of the elements in the sequence.</typeparam>
            <param name="xs">The elements of the sequence.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Lst.ToLst``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.Lst`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Maybe`1">
            <summary>
            An optional type that works for both reference and value types.
            Also known as "Option". Available as a data-source in LINQ-queries.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Value">
            <summary>
            Returns the value, if it exists. Otherwise, a <see cref="T:Nordril.Functional.PatternMatchException"/> is thrown.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Maybe`1.HasValue">
            <summary>
            Returns true iff the maybe has a value.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Maybe`1.IsNothing">
            <summary>
            Returns true iff the maybe does not have a value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Deconstruct(System.Boolean@,`0@)">
            <summary>
            Tuple deconstructor function.
            </summary>
            <param name="hasValue">Whether the value is present.</param>
            <param name="value">The value, if present, or <c>default</c>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ClearValue">
            <summary>
            Clears the value in-place. <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> will be false.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.SetValue(`0)">
            <summary>
            Sets the value in-place. <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> will be true.
            </summary>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOr(`0)">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>
            is returned, otherwise, <paramref name="alternative"/> is returned.
            </summary>
            <param name="alternative">The value to return if the maybe has no value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOr``1(System.Func{`0,``0},``0)">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, the function <paramref name="f"/> is applied to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> and returned, otherwise <paramref name="alternative"/> is returned.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the value, if present.</param>
            <param name="alternative">The value to return if the maybe has no value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOrLazy(System.Func{`0})">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>
            is returned, otherwise, <paramref name="alternative"/> is returned. This version allows lazy evaluation of <paramref name="alternative"/>.
            </summary>
            <param name="alternative">The value to return if the maybe has no value. Wrapped in a lambda to permit lazy evaluation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOrLazy``1(System.Func{`0,``0},System.Func{``0})">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, the function <paramref name="f"/> is applied to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> and returned, otherwise, <paramref name="alternative"/> is returned. This version allows lazy evaluation of <paramref name="alternative"/>.
            </summary>
            <param name="f">The function to apply to the value, if present.</param>
            <param name="alternative">The value to return if the maybe has no value. Wrapped in a lambda to permit lazy evaluation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.TryGetValue(`0,`0@)">
            <summary>
            A safe way to get a maybe's value. The return value is <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/>. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <paramref name="result"/> will be set to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>, otherwise, it will be set to <paramref name="alternative"/>.
            </summary>
            <param name="alternative">The value to return if the maybe has no value.</param>
            <param name="result"><see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> if <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, and <paramref name="alternative"/> otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.TryGetValueLazy(System.Func{`0},`0@)">
            <summary>
            A safe way to get a maybe's value. The return value is <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/>. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <paramref name="result"/> will be set to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>, otherwise, it will be set to <paramref name="alternativeFactory"/>. This version allows lazy evaluation.
            </summary>
            <param name="alternativeFactory">The value to return if the maybe has no value. Wrapped in a lambda to permit lazy evaluation.</param>
            <param name="result"><see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> if <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, and <paramref name="alternativeFactory"/> otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Nothing">
            <summary>
            Returns a new maybe containing new value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Just(`0)">
            <summary>
            Returns a new maybe containing a value.
            </summary>
            <param name="value">The value to store in the maybe.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Mzero">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Empty">
            <summary>
            Returns <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <summary>
            Returns a copy of this, if it has a value, or a copy of <paramref name="x"/>.
            </summary>
            <param name="x">The other value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Maybe`1"/>-objects based on their values, if present. The comparison returns true if both values lack a value or if both have one and the values are equal based on their <see cref="M:System.Object.Equals(System.Object)"/>-method.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.op_Equality(Nordril.Functional.Data.Maybe{`0},Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.op_Inequality(Nordril.Functional.Data.Maybe{`0},Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Equals(Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Traverse``2(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Traverse``1(System.Type,System.Func{`0,Nordril.Functional.Category.IApplicative{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Maybe">
            <summary>
            Static methods and extension for <see cref="T:Nordril.Functional.Data.Maybe`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Select``2(Nordril.Functional.Data.Maybe{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Maybe`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.SelectMany``3(Nordril.Functional.Data.Maybe{``0},System.Func{``0,Nordril.Functional.Data.Maybe{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Maybe`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Data.Maybe{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Maybe`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Data.Maybe{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Data.Maybe{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Data.Maybe`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Maybe.MaybeIso`1">
            <summary>
            An isomorphism between <see cref="T:Nordril.Functional.Data.Maybe`1"/> and reference types, where <c>default</c> is mapped to <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and all other values to <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="T">The underlying type to wrap.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.JustIf``1(System.Boolean,System.Func{``0})">
            <summary>
            Creates a new maybe which contains a value if <paramref name="isJust"/> is true,
            and Nothing otherwise.
            Useful as a shorthand case distinction.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="isJust">The test.</param>
            <param name="factory">The function to create a value. This wrapper is there to ensure that the
            value isn't evaluated if it isn't needed.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Just``1(``0)">
            <summary>
            Returns a new maybe containing a value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="value">The value to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Iso``1">
            <summary>
            Returns an isomorphism between a reference type (which has null) and <see cref="T:Nordril.Functional.Data.Maybe`1"/>, which can be used to wrap/unwrap the <see cref="T:Nordril.Functional.Data.Maybe`1"/>.
            null of the underlying type is mapped to <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and all other values are mapped to <see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/>.
            </summary>
            <typeparam name="T">The underlying type contained in the <see cref="T:Nordril.Functional.Data.Maybe`1"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Unwrap``1(Nordril.Functional.Data.Maybe{``0})">
            <summary>
            Returns the value of the <see cref="T:Nordril.Functional.Data.Maybe`1"/> or null if it has no value. Shorthand for <c>m.ValueOr(null)</c>.
            </summary>
            <typeparam name="T">The underlying type contained in the <see cref="T:Nordril.Functional.Data.Maybe`1"/>.</typeparam>
            <param name="maybe">The <see cref="T:Nordril.Functional.Data.Maybe`1"/> to unwrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Nothing``1">
            <summary>
            Returns a new maybe containing no value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.ToMaybe``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Maybe`1"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="T">The type of the value contained in the functor.</typeparam>
            <param name="f">The functor to cast to a maybe.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.ValueOr``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1,``2},``2)">
            <summary>
            Tries to get a value from a dictionary and applies a function if present, or returns an alternative value if not.
            This does not change the dictionary. The semantics are the same as <see cref="M:Nordril.Functional.Data.Maybe`1.ValueOr``1(System.Func{`0,``0},``0)"/>.
            </summary>
            <typeparam name="TKey">The type of the dictionary's key.</typeparam>
            <typeparam name="TValue">The type of the dictionary's value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="dict">The dictionary from which to get the value.</param>
            <param name="key">The key whose corresponding value to get.</param>
            <param name="f">The function to apply to the key's value if the key is present.</param>
            <param name="alternative">The alternative value to return if the key is not present.</param>
        </member>
        <member name="T:Nordril.Functional.Data.MaybeT`4">
            <summary>
            The <see cref="T:Nordril.Functional.Data.Maybe`1"/> monad transformer which models a <see cref="T:Nordril.Functional.Data.Maybe`1"/>-value being contained in a monad, e.g. <c>IO&lt;Maybe&lt;T&gt;&gt;</c>.
            </summary>
            <typeparam name="TUnlifted">The unlifted monadic value (e.g. <c>IO&lt;T&gt;</c>).</typeparam>
            <typeparam name="TLifted">The monadic type of the inner monad, containing, in turn, a <see cref="T:Nordril.Functional.Data.Maybe`1"/>-value.</typeparam>
            <typeparam name="TInner">The <see cref="T:Nordril.Functional.Data.Maybe`1"/>-type.</typeparam>
            <typeparam name="TSource">The innermost source-type.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.MaybeT`4.Run">
            <summary>
            The inner value of type <c>m (Maybe a)</c>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.#ctor(`1)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="run">The contained monadic value with the <see cref="T:Nordril.Functional.Data.Maybe`1"/>-instance as the base value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Nothing">
            <summary>
            Creates a Nothing-instance of <see cref="T:Nordril.Functional.Data.MaybeT"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.BindT``4(System.Func{`3,Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,``3}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.ApT``7(Nordril.Functional.Category.IMonadTransformer{``0,``1,``2,System.Func{`3,``6}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Lift(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Hoist(`2)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.PureT``4(``3)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.MapT``4(System.Func{`3,``3})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Map``1(System.Func{`3,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Bind``1(System.Func{`3,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT`4.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`3,``0}})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.MaybeT">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.MaybeT`4"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT.ReplaceTypeVariable(System.Type,System.Type,System.Type)">
            <summary>
            Replaces an occurrence of a generic argument <paramref name="original"/> in a (generic or non-generic) type with <paramref name="replacement"/> and returns the result.
            </summary>
            <param name="t">The type in which to replace the argument.</param>
            <param name="original">The argument to search for (which can also be <paramref name="t"/> itself).</param>
            <param name="replacement">The argument with which to replace <paramref name="replacement"/>.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT.Just``3(``2)">
            <summary>
            Creates a <see cref="T:Nordril.Functional.Data.MaybeT`4"/> out of a pure value.
            </summary>
            <typeparam name="TUnlifted">The unlifted monadic value (e.g. <c>IO&lt;T&gt;</c>).</typeparam>
            <typeparam name="TLifted">The monadic type of the inner monad, containing, in turn, a <see cref="T:Nordril.Functional.Data.Maybe`1"/>-value.</typeparam>
            <typeparam name="TSource">The innermost source-type.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT.Just``3(``0)">
            <summary>
            Creates a <see cref="T:Nordril.Functional.Data.MaybeT`4"/> out of a outer monadic value (e.g. <see cref="T:Nordril.Functional.Data.Io`1"/>).
            </summary>
            <typeparam name="TUnlifted">The unlifted monadic value (e.g. <c>IO&lt;T&gt;</c>).</typeparam>
            <typeparam name="TLifted">The monadic type of the inner monad, containing, in turn, a <see cref="T:Nordril.Functional.Data.Maybe`1"/>-value.</typeparam>
            <typeparam name="TSource">The innermost source-type.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.MaybeT.ValueOr``4(Nordril.Functional.Data.MaybeT{``0,``1,Nordril.Functional.Data.Maybe{``2},``2},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Flattens the structure of a <see cref="T:Nordril.Functional.Data.MaybeT`4"/> by erasing the innermost <see cref="T:Nordril.Functional.Data.Maybe`1"/>-value.
            </summary>
            <typeparam name="TUnlifted">The unlifted monadic value (e.g. <c>IO&lt;T&gt;</c>).</typeparam>
            <typeparam name="TLifted">The monadic type of the inner monad, containing, in turn, a <see cref="T:Nordril.Functional.Data.Maybe`1"/>-value.</typeparam>
            <typeparam name="TSource">The innermost source-type.</typeparam>
            <typeparam name="TResult">The innermost result-type.</typeparam>
            <param name="maybe">The <see cref="T:Nordril.Functional.Data.MaybeT`4"/> to flatten.</param>
            <param name="f">The function to apply to the innermost value, if present.</param>
            <param name="alternative">The function which produces an alternative innermost alternative value, if the value is missing.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Memo`3">
            <summary>
            A memoization-monad which allows one to run computations that make use of memoization of the results. This generally makes sense for recursive functions with overlapping subproblems where we only want to compute <c>f(x) = y</c> the first time and retrieve its stored result <c>y</c> whenever a subsequent call to <c>f(x)</c> is made.
            The main function to use with this structure is <see cref="M:Nordril.Functional.Data.Memo.Memoized``3(``1,System.Func{``1,Nordril.Functional.Data.Memo{``0,``1,``2}})"/>.
            <remarks>The memoization is backed by a finite <see cref="T:System.Collections.Generic.IDictionary`2"/>. Commonly, there is no limit on the number of computed results to store, though one can limit this via a custom dictionary-implementation.</remarks>
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TKey">The type of the key by which results are memoized.</typeparam>
            <typeparam name="TValue">The type of the value which is computed.</typeparam>
            <example>
            We can calculate the fibonacci sequence, which has overlapping subproblems, as follows:
            <code>
            Memo&lt;Dictionary&lt;int, int&gt;, int, int&gt; fib(int x)
            {
                if (x == 0)
                    return Memo.Pure&lt;Dictionary&lt;int, int&gt;, int, int&gt;(0);
                else if (x == 1)
                    return Memo.Pure&lt;Dictionary&lt;int, int&gt;, int, int&gt;(1);
                else
                    return from n1 in Memo.Memoized(x - 1, fib)
                           from n2 in Memo.Memoized(x - 2, fib)
                           select n1 + n2;
            }
            
            //1346269
            var result = fib(30).RunForResult(new Dictionary&lt;int, int&gt;());
            </code>
            </example>
        </member>
        <member name="F:Nordril.Functional.Data.Memo`3.runState">
            <summary>
            The state-function which takes an initial state and produces
            both a new state and a result.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Memo`3.#ctor(System.Func{`0,System.ValueTuple{`2,`0}})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="runState">The function to run.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Memo`3.Run(`0)">
            <summary>
            Runs the state function with an initial state and returns the result, plus the actual result.
            </summary>
            <param name="initialState">The initial state (the starting point of the computation).</param>
        </member>
        <member name="M:Nordril.Functional.Data.Memo`3.Bind(System.Func{`2,Nordril.Functional.Data.Memo{`0,`1,`2}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Memo`3.MonoMap(System.Func{`2,`2})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Memo`3.Pure(`2)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Memo">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Memo`3"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Memo.Pure``3(``2)">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>, but restricted to <see cref="T:Nordril.Functional.Data.Memo`3"/>. Useful for returning pure values, esp. in LINQ-queries.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TKey">The key of the memoization.</typeparam>
            <typeparam name="TValue">The type of the source's value.</typeparam>
            <param name="value">The value to return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Memo.Select``3(Nordril.Functional.Data.Memo{``0,``1,``2},System.Func{``2,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Memo`3"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TKey">The key of the memoization.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Memo.SelectMany``3(Nordril.Functional.Data.Memo{``0,``1,``2},System.Func{``2,Nordril.Functional.Data.Memo{``0,``1,``2}},System.Func{``2,``2,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Memo`3"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TKey">The key of the memoization.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Memo.Memoized``3(``1,System.Func{``1,Nordril.Functional.Data.Memo{``0,``1,``2}})">
            <summary>
            Memoizes a function, either returning the memoized value without running <paramref name="f"/> if the key <paramref name="key"/> is already memoized, or running it, memoizing the key, and then returning the result.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TKey">The key of the memoization.</typeparam>
            <typeparam name="TValue">The type of the source's value.</typeparam>
            <param name="key">The key of the value to search. If this is present in the state, <paramref name="f"/> is not run.</param>
            <param name="f">The function to run in memoized form.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Pred`1">
            <summary>
            A predicate which wraps a function that takes a <typeparamref name="T"/> and returns true or false.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Pred`1.Func">
            <summary>
            The predicate function.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Pred`1.Neutral">
            <summary>
            The neutral element w.r.t the predicate's monoid. Creates a predicate that always returns true.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            Creates a new predicate from a function.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.Run(`0)">
            <summary>
            Runs the predicate with an argument.
            </summary>
            <param name="arg">The argument.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.ContraMap``1(System.Func{``0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.Op(Nordril.Functional.Data.Pred{`0},Nordril.Functional.Data.Pred{`0})">
            <summary>
            Combines two predicates via logical AND.
            </summary>
            <param name="x">The first predicate.</param>
            <param name="y">The second predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Pred">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Pred`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Pred.Create``1(System.Func{``0,System.Boolean})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Pred`1"/> from a function <paramref name="f"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="f">The predicate function.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Pred.ToPredicate``1(Nordril.Functional.Category.IContravariant{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IContravariant`1"/> to a <see cref="T:Nordril.Functional.Data.Pred`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Random`2">
            <summary>
            The "random"-monad, which provdes access to a pseudo-random number generator in a repeatable and pure way. Unlike using <see cref="T:System.Random"/>, two executions of <see cref="T:Nordril.Functional.Data.Random`2"/>-computations will produce the same result (provided the compuations are pure) when run with the same RNG.
            </summary>
            <typeparam name="TRng">The type of the RNG. This will be wrapped in an <see cref="T:Nordril.Functional.Data.Rng`1"/>.</typeparam>
            <typeparam name="TValue">The type of the produced value.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.Random`2.runState">
            <summary>
            The state-function which takes an initial state and produces
            both a new state and a result.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Random`2.#ctor(System.Func{Nordril.Functional.Data.Rng{`0},System.ValueTuple{`1,Nordril.Functional.Data.Rng{`0}}})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="runState">The state-function to put into the random monad.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Random`2.Run(Nordril.Functional.Data.Rng{`0})">
            <summary>
            Runs the state function with an initial state and returns the result, plus the actual result.
            </summary>
            <param name="initialState">The initial state (the starting point of the computation).</param>
        </member>
        <member name="M:Nordril.Functional.Data.Random`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Random`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Random`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Random`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Rnd">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Random`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Pure``2(``1)">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>, but restricted to <see cref="T:Nordril.Functional.Data.Random`2"/>. Useful for returning pure values, esp. in LINQ-queries.
            </summary>
            <typeparam name="TRng">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the source's value.</typeparam>
            <param name="value">The value to return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Select``3(Nordril.Functional.Data.Random{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Random`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.SelectMany``4(Nordril.Functional.Data.Random{``0,``1},System.Func{``1,Nordril.Functional.Data.Random{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Random`2"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RunForResult``2(Nordril.Functional.Data.Random{``0,``1},Nordril.Functional.Data.Rng{``0})">
            <summary>
            Runs the state function with an initial state and returns the result, discarding the final state.
            </summary>
            <param name="s">The state to run.</param>
            <param name="initialState">The initial state (the starting point of the computation).</param>
            <typeparam name="TRng">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RunForState``2(Nordril.Functional.Data.Random{``0,``1},Nordril.Functional.Data.Rng{``0})">
            <summary>
            Runs the state function with an initial state and returns the final state, discarding the result.
            </summary>
            <param name="s">The state to run.</param>
            <param name="initialState">The initial state (the starting point of the computation).</param>
            <typeparam name="TRng">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomInt``1">
            <summary>
            Gets a new random integer.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomInt``1(Nordril.Functional.Data.RandomCxt{``0})">
            <summary>
            Gets a new random integer.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomInt``1(System.Int32,System.Int32)">
            <summary>
            Gets a new random integer in the specified range.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="min">The minimum value (inclusive).</param>
            <param name="max">The maximum value (exclusive). If <paramref name="max"/> is equal to <paramref name="min"/>, <paramref name="min"/> is always returned by this method.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomInt``1(Nordril.Functional.Data.RandomCxt{``0},System.Int32,System.Int32)">
            <summary>
            Gets a new random integer in the specified range.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="min">The minimum value (inclusive).</param>
            <param name="max">The maximum value (exclusive). If <paramref name="max"/> is equal to <paramref name="min"/>, <paramref name="min"/> is always returned by this method.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomInts``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a list of random integers, all in the specified range.
            When a large list of integers is required, this function is preferable to <see cref="M:Nordril.Functional.Category.Applicative.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})"/>, which might overflow.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="min">The minimum value (inclusive).</param>
            <param name="max">The maximum value (exclusive).</param>
            <param name="num">The number of integers to return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomInts``1(Nordril.Functional.Data.RandomCxt{``0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a list of random integers, all in the specified range.
            When a large list of integers is required, this function is preferable to <see cref="M:Nordril.Functional.Category.Applicative.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})"/>, which might overflow.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="min">The minimum value (inclusive).</param>
            <param name="max">The maximum value (exclusive).</param>
            <param name="num">The number of integers to return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomDouble``1">
            <summary>
            Gets a new random double between 0.0 and 1.0.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomDouble``1(Nordril.Functional.Data.RandomCxt{``0})">
            <summary>
            Gets a new random double between 0.0 and 1.0.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomDouble``1(System.Double,System.Double)">
            <summary>
            Gets a new random double in the specified range.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="min">The minium value (inclusive).</param>
            <param name="max">The maximum value (exclusive). If <paramref name="max"/> is equal to <paramref name="min"/>, <paramref name="min"/> is always returned by this method.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomDouble``1(Nordril.Functional.Data.RandomCxt{``0},System.Double,System.Double)">
            <summary>
            Gets a new random double in the specified range.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="min">The minium value (inclusive).</param>
            <param name="max">The maximum value (exclusive). If <paramref name="max"/> is equal to <paramref name="min"/>, <paramref name="min"/> is always returned by this method.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomDoubles``1(System.Double,System.Double,System.Int32)">
            <summary>
            Gets a list of random doubles, all in the specified range.
            When a large list of doubles is required, this function is preferable to <see cref="M:Nordril.Functional.Category.Applicative.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})"/>, which might overflow.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="min">The minimum value (inclusive).</param>
            <param name="max">The maximum value (exclusive).</param>
            <param name="num">The number of integers to return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomDoubles``1(Nordril.Functional.Data.RandomCxt{``0},System.Double,System.Double,System.Int32)">
            <summary>
            Gets a list of random doubles, all in the specified range.
            When a large list of doubles is required, this function is preferable to <see cref="M:Nordril.Functional.Category.Applicative.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})"/>, which might overflow.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="min">The minimum value (inclusive).</param>
            <param name="max">The maximum value (exclusive).</param>
            <param name="num">The number of integers to return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomBytes``1(System.Byte[])">
            <summary>
            Fills a buffer <paramref name="buffer"/> with random bytes (mutating it) and returns it.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="buffer">The buffer to fill and return.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomBytes``1(Nordril.Functional.Data.RandomCxt{``0},System.Byte[])">
            <summary>
            Fills a buffer <paramref name="buffer"/> with random bytes (mutating it) and returns it.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="buffer">The buffer to fill and return.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="buffer"/> is null.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Random32Bits``1">
            <summary>
            Gets 32 uniformly random bits.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Random32Bits``1(Nordril.Functional.Data.RandomCxt{``0})">
            <summary>
            Gets 32 uniformly random bits.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Random64Bits``1">
            <summary>
            Gets 64 uniformly random bits.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Random64Bits``1(Nordril.Functional.Data.RandomCxt{``0})">
            <summary>
            Gets 64 uniformly random bits.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Random64Bits``1(Nordril.Functional.Data.Rng{``0})">
            <summary>
            Gets 64 uniformly random bits.
            </summary>
            <typeparam name="TRng"></typeparam>
            <param name="rng">The RNG.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomOrder``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns the elements of a sequence in uniformly random order.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <typeparam name="T">The type of the elements.</typeparam>
            <param name="xs">The sequence to randomly order.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomOrder``2(Nordril.Functional.Data.RandomCxt{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Returns the elements of a sequence in uniformly random order.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <typeparam name="T">The type of the elements.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="xs">The sequence to randomly order.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomGaussianDouble``1(System.Double,System.Double)">
            <summary>
            Gets a double-value from a Gaussian normal distribution with mean <paramref name="mean"/> and standard deviation <paramref name="standardDeviation"/>.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="mean">The mean.</param>
            <param name="standardDeviation">The standard deviation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomGaussianDouble``1(Nordril.Functional.Data.RandomCxt{``0},System.Double,System.Double)">
            <summary>
            Gets a double-value from a Gaussian normal distribution with mean <paramref name="mean"/> and standard deviation <paramref name="standardDeviation"/>.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="mean">The mean.</param>
            <param name="standardDeviation">The standard deviation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomGaussianDoubles``1(System.Double,System.Double,System.Int32)">
            <summary>
            Gets a list of double-values from a Gaussian normal distribution with mean <paramref name="mean"/> and standard deviation <paramref name="standardDeviation"/>.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="mean">The mean.</param>
            <param name="standardDeviation">The standard deviation.</param>
            <param name="num">The number of doubles to generate.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RandomGaussianDoubles``1(Nordril.Functional.Data.RandomCxt{``0},System.Double,System.Double,System.Int32)">
            <summary>
            Gets a alist double-values from a Gaussian normal distribution with mean <paramref name="mean"/> and standard deviation <paramref name="standardDeviation"/>.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="mean">The mean.</param>
            <param name="standardDeviation">The standard deviation.</param>
            <param name="num">The number of doubles to generate.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.Put(System.Int32)">
            <summary>
            Replaces the current state with a new one.
            </summary>
            <param name="seed">The new seed of the new PRNG.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RunRandom``1(Nordril.Functional.Data.Random{System.Random,``0},System.Int32)">
            <summary>
            Runs the state function with an initial seed and returns the result, discarding the final state.
            </summary>
            <param name="s">The computation to run.</param>
            <param name="seed">The initial state (the starting point of the computation).</param>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.RunRandom``1(Nordril.Functional.Data.Random{System.Random,``0})">
            <summary>
            Runs the state function with with an intial seed equalling <see cref="P:System.Environment.TickCount"/> (the same as when calling the parameterless constructor of <see cref="T:System.Random"/>), discarding the final state. As this is in an impure function where subsequent calls will return different results, the return-value is an <see cref="T:Nordril.Functional.Data.Io`1"/>.
            </summary>
            <param name="s">The computation to run.</param>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.Rnd.ZigguratGaussian.__blockCount">
            <summary>
            Number of blocks.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.Rnd.ZigguratGaussian.__R">
            <summary>
            Right hand x coord of the base rectangle, thus also the left hand x coord of the tail 
            (pre-determined/computed for 128 blocks).
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.Rnd.ZigguratGaussian.__A">
            <summary>
            Area of each rectangle (pre-determined/computed for 128 blocks).
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.Rnd.ZigguratGaussian.__MAXINT">
            <summary>
            Denominator for __INCR constant. This is the number of distinct values this class is capable 
            of generating in the interval [0,1], i.e. (2^53)-1 distinct values.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.Rnd.ZigguratGaussian.__INCR">
            <summary>
            Scale factor for converting a ULong with interval [0, 0x1f_ffff_ffff_ffff] to a double with interval [0,1].
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.Rnd.ZigguratGaussian.__oneBits">
            <summary>
            Binary representation of +1.0 in IEEE 754 double-precision floating-point format.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.ZigguratGaussian.Sample``1(Nordril.Functional.Data.Rng{``0})">
            <summary>
            Take a sample from the standard Gaussian distribution, i.e. with mean of 0 and standard deviation of 1.
            </summary>
            <returns>A random sample.</returns>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.ZigguratGaussian.SampleTail``1(Nordril.Functional.Data.Rng{``0})">
            <summary>
            Sample from the distribution tail (defined as having x >= __R).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.ZigguratGaussian.GaussianPdfDenorm(System.Double)">
            <summary>
            Gaussian probability density function, denormalised, that is, y = e^-(x^2/2).
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rnd.ZigguratGaussian.GaussianPdfDenormInv(System.Double)">
            <summary>
            Inverse function of GaussianPdfDenorm(x)
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Rng`1">
            <summary>
            A virtual interface for a random number generator, acting as a wrapper which can be used even if the underlying RNG does not implement any specific interface.
            </summary>
            <typeparam name="T">The type of the underlying RNG.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.NextInt">
            <summary>
            Gets a new random integer.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.NextInt(System.Int32,System.Int32)">
            <summary>
            Gets a new random integer in the specified range.
            </summary>
            <param name="min">The minium value (inclusive).</param>
            <param name="max">The maximum value (exclusive). If <paramref name="max"/> is equal to <paramref name="min"/>, <paramref name="min"/> is always returned by this method.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.NextDouble">
            <summary>
            Gets a new random double between 0.0 and 1.0.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.NextDouble(System.Double,System.Double)">
            <summary>
            Gets a new random double in the specified range.
            </summary>
            <param name="min">The minium value (inclusive).</param>
            <param name="max">The maximum value (exclusive). If <paramref name="max"/> is equal to <paramref name="min"/>, <paramref name="min"/> is always returned by this method.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.NextBytes(System.Byte[])">
            <summary>
            Fills a buffer <paramref name="buffer"/> with random bytes (mutating it) and returns it.
            </summary>
            <param name="buffer">The buffer to fill and return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.#ctor(`0,System.Func{`0,System.Int32,System.Int32,System.ValueTuple{System.Int32,`0}},System.Func{`0,System.ValueTuple{System.Double,`0}},System.Func{`0,System.Double,System.Double,System.ValueTuple{System.Double,`0}},System.Func{`0,System.Byte[],System.ValueTuple{System.Byte[],`0}})">
            <summary>
            Creates a new RNG-wrapper.
            </summary>
            <param name="obj">The underlying RNG.</param>
            <param name="nextInt">The function to return a random integer.</param>
            <param name="nextDouble">The function to return a random double between 0.0 and 1.0</param>
            <param name="nextBoundedDouble">The function to return a random double in a custom interval.</param>
            <param name="nextBytes">The function to fill a byte-array with random bytes.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rng`1.FromRandom(System.Int32)">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.Rng`1"/>-wrapper out of an instance of <see cref="T:System.Random"/>.
            </summary>
            <param name="seed">The see of the <see cref="T:System.Random"/>-object.</param>
        </member>
        <member name="T:Nordril.Functional.Data.RandomCxt`1">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.Random`2"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods like <see cref="M:System.Random.Next(System.Int32,System.Int32)"/>. See <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> for examples
            </summary>
            <typeparam name="TRng">The type of the RNG.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Reader`2">
            <summary>
            The reader-monad, which reads a state <typeparamref name="TEnvironment"/> and produces a result
            <typeparamref name="TValue"/>. Composing multiple reader-actions is like composing
            simple functions, except that an implicit variable of type <typeparamref name="TEnvironment"/>
            is being passed around.
            As such, state is a more well-behaved replacement to reader some global variable.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value produced.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.Reader`2.runReader">
            <summary>
            The state-function which takes an initial state and produces
            both a new state and a result.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Reader`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new reader from a function that takes an initial state
            and produces a new state, plus a result.
            </summary>
            <param name="runReader">The state-function to put into the state monad.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader`2.Run(`0)">
            <summary>
            Runs the reader function with an initial state and returns the result.
            </summary>
            <param name="initialState">The initial state (the starting point of the computation).</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Reader`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Reader`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Reader`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Reader">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Reader`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.Select``3(Nordril.Functional.Data.Reader{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Reader`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.SelectMany``4(Nordril.Functional.Data.Reader{``0,``1},System.Func{``1,Nordril.Functional.Data.Reader{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Reader`2"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.Get``1">
            <summary>
            Returns the current state. Also known as <em>ask</em>.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.Get``1(Nordril.Functional.Data.ReaderCxt{``0})">
            <summary>
            Returns the current state. Also known as <em>ask</em>.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.With``2(System.Func{``0,``1})">
            <summary>
            Returns the result to of a function which takes the state as an input. Also known as <em>reader</em>.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="f">The function to run.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.With``2(Nordril.Functional.Data.ReaderCxt{``0},System.Func{``0,``1})">
            <summary>
            Returns the result to of a function which takes the state as an input. Also known as <em>reader</em>.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="f">The function to run.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.Local``2(System.Func{``0,``0},Nordril.Functional.Data.Reader{``0,``1})">
            <summary>
            Returns a <see cref="T:Nordril.Functional.Data.Reader`2"/> which runs <paramref name="r"/>, but first applies <paramref name="f"/> to the environment, effectively running a <see cref="T:Nordril.Functional.Data.Reader"/> in a modified environment.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="f">The function which modifies the environment.</param>
            <param name="r">The <see cref="T:Nordril.Functional.Data.Reader"/> to run in the modified environment.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.Local``2(Nordril.Functional.Data.ReaderCxt{``0},System.Func{``0,``0},Nordril.Functional.Data.Reader{``0,``1})">
            <summary>
            Returns a <see cref="T:Nordril.Functional.Data.Reader`2"/> which runs <paramref name="r"/>, but first applies <paramref name="f"/> to the environment, effectively running a <see cref="T:Nordril.Functional.Data.Reader"/> in a modified environment.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="f">The function which modifies the environment.</param>
            <param name="r">The <see cref="T:Nordril.Functional.Data.Reader"/> to run in the modified environment.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Reader.ToReader``2(Nordril.Functional.Category.IFunctor{``1})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Reader`2"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="TEnvironment">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value contained in the functor.</typeparam>
            <param name="f">The functor to cast to a writer.</param>
        </member>
        <member name="T:Nordril.Functional.Data.ReaderCxt`1">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.Reader`2"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods like <see cref="M:Nordril.Functional.Data.Reader.Local``2(System.Func{``0,``0},Nordril.Functional.Data.Reader{``0,``1})"/>. See <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> for examples
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Rws`5">
            <summary>
            A fusing of <see cref="T:Nordril.Functional.Data.Reader`2"/>, <see cref="T:Nordril.Functional.Data.Writer`3"/>, and <see cref="T:Nordril.Functional.Data.State`2"/>, where computations can read from an environment <typeparamref name="TEnvironment"/>, write to an output <typeparamref name="TOutput"/>, and modify a state <typeparamref name="TState"/>.
            <br />
            See also <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> on how to make usage more convenient by being able to omit type parameter.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the result.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.Rws`5.runRws">
            <summary>
            The RWS-function.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Rws`5.Monoid">
            <summary>
            The output monoid for combining outputs.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.#ctor(`4)">
            <summary>
            Creates a new RWS from a result.
            </summary>
            <param name="result">The result to produce.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.#ctor(System.Func{`0,`3,System.ValueTuple{`4,`3,`1}})">
            <summary>
            Creates a new RWS from an RWS-function.
            </summary>
            <param name="runRws">The RWS-function.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.#ctor(System.Func{`0,`3,System.ValueTuple{`4,`3,`1}},Nordril.Functional.Algebra.IMonoid{`1})">
            <summary>
            Creates a new RWS from an RWS-function.
            </summary>
            <param name="runRws">The RWS-function.</param>
            <param name="monoid">The monooid on <typeparamref name="TMonoid"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.Run(`0,`3)">
            <summary>
            Runs the RWS-computation and returns the final result, state, and output.
            </summary>
            <param name="environment">The read-only environment.</param>
            <param name="state">The mutable state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.Bind``1(System.Func{`4,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`4,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Rws`5.Map``1(System.Func{`4,``0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Rws">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Rws`5"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Select``6(Nordril.Functional.Data.Rws{``0,``1,``2,``3,``4},System.Func{``4,``5})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Rws`5"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.SelectMany``7(Nordril.Functional.Data.Rws{``0,``1,``2,``3,``4},System.Func{``4,Nordril.Functional.Data.Rws{``0,``1,``2,``3,``5}},System.Func{``4,``5,``6})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Rws`5"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Get``4">
            <summary>
            Returns the current state.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Get``4(Nordril.Functional.Data.RwsCxt{``0,``1,``2,``3})">
            <summary>
            Returns the current state.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Put``4(``3)">
            <summary>
            Replaces the current state with a new one.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="value">The new state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Put``4(Nordril.Functional.Data.RwsCxt{``0,``1,``2,``3},``3)">
            <summary>
            Replaces the current state with a new one.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="value">The new state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Modify``4(System.Func{``3,``3})">
            <summary>
            Modifies the current state by running a function on it.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="f">The function to apply to the state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Modify``4(Nordril.Functional.Data.RwsCxt{``0,``1,``2,``3},System.Func{``3,``3})">
            <summary>
            Modifies the current state by running a function on it.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="f">The function to apply to the state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.GetEnvironment``4">
            <summary>
            Returns the current environment.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.GetEnvironment``4(Nordril.Functional.Data.RwsCxt{``0,``1,``2,``3})">
            <summary>
            Returns the current environment.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.With``5(System.Func{``0,``4})">
            <summary>
            Returns the result to of a function which takes the state as an input. Also known as <em>reader</em>.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="f">The function to run.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Local``5(System.Func{``0,``0},Nordril.Functional.Data.Rws{``0,``1,``2,``3,``4})">
            <summary>
            Returns a <see cref="T:Nordril.Functional.Data.Reader`2"/> which runs <paramref name="r"/>, but first applies <paramref name="f"/> to the environment, effectively running a <see cref="T:Nordril.Functional.Data.Reader"/> in a modified environment.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="f">The function which modifies the environment.</param>
            <param name="r">The <see cref="T:Nordril.Functional.Data.Reader"/> to run in the modified environment.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Tell``4(``1)">
            <summary>
            Stores a new output.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name = "output" > The output to store and return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Tell``4(Nordril.Functional.Data.RwsCxt{``0,``1,``2,``3},``1)">
            <summary>
            Stores a new output.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="output"> The output to store and return.</param>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Rws.Listen``5(Nordril.Functional.Data.Rws{``0,``1,``2,``3,``4})">
            <summary>
            Returns the result of the computation as well as the write-output.
            </summary>
            <param name="rws">The RWS to which to tell the output.</param>
        </member>
        <member name="T:Nordril.Functional.Data.RwsCxt`4">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.Rws`5"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods like <see cref="M:Nordril.Functional.Data.Rws.Get``4(Nordril.Functional.Data.RwsCxt{``0,``1,``2,``3})"/>.
            </summary>
            <example>
                <code>
                //We only need to specify this long context once.
                var cxt = new RwsCxt&lt;Dictionary&lt;string, int&gt;, IList&lt;string&gt; Monoid.ImmutableListAppendMonoid&lt;string&gt;, double&gt;();  
                
                var result =
                    //Instead of Rws.Get&lt;Dictionary&lt;string, int&gt;, IList&lt;string&gt; Monoid.ImmutableListAppendMonoid&lt;string&gt;, double&gt;()
                    from s in Rws.Get(cxt)
                    //Instead of Rws.Put&lt;Dictionary&lt;string, int&gt;, IList&lt;string&gt; Monoid.ImmutableListAppendMonoid&lt;string&gt;, double&gt;
                    from _ in Rws.Put(cxt, s*2D)
                    ...;
            </code>
            </example>
            <typeparam name="TEnvironment">The type of the environment.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.State`2">
            <summary>
            The state-monad, which maintains a state <typeparamref name="TState"/> and produces a result
            <typeparamref name="TValue"/>. Composing multiple state-actions is like composing
            simple functions, except that an implicit variable of type <typeparamref name="TState"/>
            is being passed around.
            As such, state is a more well-behaved replacement to modifying some global variable.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value produced.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.State`2.runState">
            <summary>
            The state-function which takes an initial state and produces
            both a new state and a result.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.State`2.#ctor(System.Func{`0,System.ValueTuple{`1,`0}})">
            <summary>
            Creates a new state from a function that takes an initial state
            and produces a new state, plus a result.
            </summary>
            <param name="runState">The state-function to put into the state monad.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Run(`0)">
            <summary>
            Runs the state function with an initial state and returns the final state, plus the result.
            </summary>
            <param name="initialState">The initial state (the starting point of the computation).</param>
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.State">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.State`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.State.Select``3(Nordril.Functional.Data.State{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.State`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.SelectMany``4(Nordril.Functional.Data.State{``0,``1},System.Func{``1,Nordril.Functional.Data.State{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.State`2"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.Get``1">
            <summary>
            Returns the current state.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.State.Get``1(Nordril.Functional.Data.StateCxt{``0})">
            <summary>
            Returns the current state.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.Put``1(``0)">
            <summary>
            Replaces the current state with a new one.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="value">The new state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.Put``1(Nordril.Functional.Data.StateCxt{``0},``0)">
            <summary>
            Replaces the current state with a new one.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="value">The new state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.Modify``1(System.Func{``0,``0})">
            <summary>
            Modifies the current state by running a function on it.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="f">The function to apply to the state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.Modify``1(Nordril.Functional.Data.StateCxt{``0},System.Func{``0,``0})">
            <summary>
            Modifies the current state by running a function on it.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="f">The function to apply to the state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.RunForResult``2(Nordril.Functional.Data.State{``0,``1},``0)">
            <summary>
            Runs the state function with an initial state and returns the result, discarding the final state.
            </summary>
            <param name="s">The state to run.</param>
            <param name="initialState">The initial state (the starting point of the computation).</param>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.State.RunForState``2(Nordril.Functional.Data.State{``0,``1},``0)">
            <summary>
            Runs the state function with an initial state and returns the final state, discarding the result.
            </summary>
            <param name="s">The state to run.</param>
            <param name="initialState">The initial state (the starting point of the computation).</param>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.State.RunStringBuilder``1(Nordril.Functional.Data.State{System.Text.StringBuilder,``0})">
            <summary>
            Runs the state function on a newly created <see cref="T:System.Text.StringBuilder"/> and returns the final string. This is a convenience method if one uses <see cref="T:Nordril.Functional.Data.State`2"/> to efficiently build up strings.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="s">The state to run.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.ToState``2(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.State`2"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="T">The type of the value contained in the functor.</typeparam>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="f">The functor to cast to a maybe.</param>
        </member>
        <member name="T:Nordril.Functional.Data.StateCxt`1">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.State`2"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods like <see cref="M:Nordril.Functional.Data.State.Get``1"/>. See <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> for examples
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Store`2">
            <summary>
            A store-monad which starts with an initial store and allows repeated extraction of values,
            but not change to the store itself.
            Store is the opposite/dual of <see cref="T:Nordril.Functional.Data.State`2"/>, which requires an initial state
            and can produce new states.
            </summary>
            <typeparam name="TStore">The type of the state.</typeparam>
            <typeparam name="TValue">The type value to be extracted.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Store`2.RunStore">
            <summary>
            Runs the store.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Store`2.InitialStore">
            <summary>
            The initial store which can be used to run the store.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.#ctor(System.Func{`0,`1},`0)">
            <summary>
            Creates a new store out for an extraction function and an initial state.
            </summary>
            <param name="runStore">The function to extract a value from the store.</param>
            <param name="initialStore">The initial state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.Extend``1(System.Func{Nordril.Functional.Category.IComonad{`1},``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.Extract">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Store">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Store`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Store.Select``3(Nordril.Functional.Data.Store{``0,``1},System.Func{``1,``2})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Store`2"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.GetStore``2(Nordril.Functional.Data.Store{``0,``1})">
            <summary>
            Extracts the store as a value.
            </summary>
            <typeparam name="TStore">The type type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation whose store to extract.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.SetStore``2(Nordril.Functional.Data.Store{``0,``1},``0)">
            <summary>
            Replaces the initial store with a new one.
            Note that this does not mean replacing a state on the fly; rather, this function
            replaces the starting point of the compuation.
            </summary>
            <typeparam name="TStore">The type type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation whose initial store to replace.</param>
            <param name="newStore">The new initial store.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Store.ModifyStore``2(Nordril.Functional.Data.Store{``0,``1},System.Func{``0,``0})">
            <summary>
            Replaces the initial store with a new one by modifiying it with a function.
            Note that this does not mean replacing a state on the fly; rather, this function
            replaces the starting point of the compuation.
            </summary>
            <typeparam name="TStore">The type type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation whose initial store to replace.</param>
            <param name="f">The function to apply to the store.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Store.WhatIfStore``2(Nordril.Functional.Data.Store{``0,``1},``0)">
            <summary>
            Returns the extracted value, if the initial store would be <paramref name="hypothetical"/>,
            without changing the store.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation to run.</param>
            <param name="hypothetical">The hypothetical initial store to use.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.WhatIfFunc``2(Nordril.Functional.Data.Store{``0,``1},System.Func{``0,``0})">
            <summary>
            Returns the extracted value, if <paramref name="f"/> would be applied to the initial store,
            without changing the store.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation to run.</param>
            <param name="f">The function to apply to the initial store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.WhatIfF``2(Nordril.Functional.Data.Store{``0,``1},System.Func{``0,Nordril.Functional.Category.IFunctor{``0}})">
            <summary>
            Returns the extracted value, if <paramref name="f"/> would be applied to the initial store. The
            <see cref="P:Nordril.Functional.Data.Store`2.RunStore"/> function is applied via
            <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/> to the functor-valued result.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation to run.</param>
            <param name="f">The functor-valued function to apply to the initial store.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Tagged`2">
            <summary>
            Tagged is like <see cref="T:Nordril.Functional.Data.Const`2"/>, but the first type-argument is the phantom one.
            You can think of Tagged as a "fake constant function", what takes a <typeparamref name="TPhantom"/> (on which it doesn't and can't depend) and returns
            an <typeparamref name="TReal"/>. <c>Tagged&lt;A,B&gt;</c> is thus the same as the function<c>(A _) =&gt; B</c>.
            It's basically only used for prisms, as a faked replacement for <see cref="T:System.Func`2"/>.
            </summary>
            <typeparam name="TPhantom">The phantom-type</typeparam>
            <typeparam name="TReal">The real-type.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Tagged`2.RealValue">
            <summary>
            Gets the real value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tagged`2.#ctor(`1)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="realValue">The real value to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tagged`2.ChooseLeft``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tagged`2.ChooseRight``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tagged`2.ContraMap``1(System.Func{``0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tagged`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tagged`2.Promap``2(System.Func{``0,`0},System.Func{`1,``1})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Tree`1">
            <summary>
            A rose tree, wherein each node has a single key and a list of children.
            </summary>
            <typeparam name="T">The type of the key.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.Key">
            <summary>
            The node's key.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.Children">
            <summary>
            The list of the node's children, if the node is an inner node.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.IsLeaf">
            <summary>
            Whether the node is a leaf. A leaf can have no children, though a node without children is not necessarily a leaf
            (an example being a directory without files in it).
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.IsInner">
            <summary>
            Whether the node is an inner node. This is the opposite of <see cref="P:Nordril.Functional.Data.Tree`1.IsLeaf"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.SetToLeaf">
            <summary>
            Sets the type of the node to a leaf.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.SetToInner(System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Tree{`0}})">
            <summary>
            Sets the type of the node to an inner node and optionally gives it children.
            </summary>
            <param name="children">The children of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.AddParent(`0)">
            <summary>
            Returns a new tree with <paramref name="newParent"/> as its root
            and this being its only child. The tree is not copied.
            </summary>
            <param name="newParent">The key that should be the new root of the tree.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.MakeInner(`0,System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Tree{`0}})">
            <summary>
            Creates an inner node.
            </summary>
            <param name="key">The key of the node.</param>
            <param name="children">The children of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.MakeLeaf(`0)">
            <summary>
            Creates a leaf.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.VisitBidirectional(Nordril.Functional.Data.IBidirectionalVisitor{Nordril.Functional.Data.Tree{`0},Nordril.Functional.Data.Tree{`0},System.Int32},Nordril.Functional.Data.TreeTraversal)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.VisitBidirectional(Nordril.Functional.Data.IBidirectionalVisitor{Nordril.Functional.Data.Tree{`0},Nordril.Functional.Data.Tree{`0},System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.VisitForward(Nordril.Functional.Data.IForwardVisitor{Nordril.Functional.Data.Tree{`0},System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.VisitBackward(Nordril.Functional.Data.IBackwardVisitor{Nordril.Functional.Data.Tree{`0},Nordril.Functional.Data.Tree{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Visit(Nordril.Functional.Data.IVisitor{Nordril.Functional.Data.Tree{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Traverse(Nordril.Functional.Data.TreeTraversal,System.Action{Nordril.Functional.Data.Tree{`0}},System.Action{Nordril.Functional.Data.Tree{`0},System.Int32},System.Action{Nordril.Functional.Data.Tree{`0}})">
            <summary>
            Traverses the tree in a certain order and yields the nodes.
            Uses the visitor pattern.
            </summary>
            <param name="traversal">The type of the traversal.</param>
            <param name="visit">The action to execute at each node, if any.</param>
            <param name="down">The action to execute when entering a node's children. The arguments are the current node and the index of the child node.</param>
            <param name="up">The action to execute when leaving a node. The argument is the node being left.</param>
            <returns>The nodes of the tree, and whether each node is a leaf.</returns>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.FoldMap``1(Nordril.Functional.Algebra.IMonoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Equals(Nordril.Functional.Data.Tree{`0})">
            <summary>
            Compares two trees structurally. Two trees are structurally equal if:
            <br />
            <list type="number">
                <item><see cref="P:Nordril.Functional.Data.Tree`1.IsLeaf"/> has the same value for both,</item>,
                <item>The keys are equal according to <see cref="M:System.Object.Equals(System.Object)"/>.</item>
                <item><see cref="P:Nordril.Functional.Data.Tree`1.Children"/>, if <see cref="P:Nordril.Functional.Data.Tree`1.IsInner"/> is true, are of the same number and are pairwise equal according to <see cref="M:Nordril.Functional.Data.Tree`1.Equals(Nordril.Functional.Data.Tree{`0})"/>.</item>
            </list>
            </summary>
            <param name="other">The other tree.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Tree">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Tree`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.Select``2(Nordril.Functional.Data.Tree{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Tree`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.MakeInner``1(``0,System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Tree{``0}})">
            <summary>
            Creates an inner node.
            </summary>
            <typeparam name="T">The type of the keys.</typeparam>
            <param name="key">The key of the node.</param>
            <param name="children">The children of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.MakeLeaf``1(``0)">
            <summary>
            Creates a leaf.
            </summary>
            <typeparam name="T">The type of the keys.</typeparam>
            <param name="key">The key of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.RetrieveDirectoryStructure(System.String,Nordril.Functional.Data.PathNameUsage,System.Func{System.String,System.Boolean})">
            <summary>
            Takes a directory and returns a tree representing that directory as its root and the sub-directories and files as child-nodes, recursively. An <see cref="M:Nordril.Functional.Data.Either.FromLeft``2(``0)"/> represents a directory and will always be an inner-node, and an <see cref="M:Nordril.Functional.Data.Either.FromRight``2(``1)"/> represents a file. No file will have a directory as a child.
            <br />
            This method uses direct recursion and thus required O(n) stack space, where n is the maximum depth of the directory structure. Symlinks are not traversed. As there are no filesystem-level locks, this method may fail if a file or directory is deleted partway through the computation.
            </summary>
            <param name="directory">The path to the directory.</param>
            <param name="fullName">Where to use the full names of filesystem-entries.</param>
            <param name="predicate">The optional predicate to which a path (except for the root-node) has to conform to be included as a node. The argument is always the full path of the filesystem-entry.</param>
            <exception cref="T:System.InvalidOperationException">If the directory <paramref name="directory"/> does not exist.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">A directory path is invalid, such as referring to an unmapped drive or having been deleted.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or combined exceed the system-defined maximum length.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
            <exception cref="T:System.StackOverflowException">If the maximum stack size has been exceeded.</exception>
        </member>
        <member name="T:Nordril.Functional.Data.TreeTraversal">
            <summary>
            A type of tree traversal.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TreeTraversal.PreOrder">
            <summary>
            First the node, then its children.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TreeTraversal.PostOrder">
            <summary>
            First the children, then the node.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.PathNameUsage">
            <summary>
            Where the full names of filesystem-entries should be used.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.PathNameUsage.Always">
            <summary>
            The full name should always be used.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.PathNameUsage.RootOnly">
            <summary>
            The full name should only be used at the root.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.PathNameUsage.Never">
            <summary>
            The full name should be used nowhere.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Unit">
            <summary>
            A unit-type containing no values and having just one instance.
            Forms the trivial, one-element commutative group and is a 0-tuple.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Inverse(Nordril.Functional.Data.Unit)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_Equality(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_Inequality(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns false.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_LessThan(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns false.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_GreaterThan(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns false.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_LessThanOrEqual(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_GreaterThanOrEqual(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Equals(System.Object)">
            <summary>
            Returns true iff the other object is a <see cref="T:Nordril.Functional.Data.Unit"/>.
            </summary>
            <param name="obj">The object to which to compare this.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.GetHashCode">
            <summary>
            Gets a hash code for a <see cref="T:Nordril.Functional.Data.Unit"/>. A constant.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Op(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Length">
            <summary>
            Always returns 0.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Item(System.Int32)">
            <summary>
            Always throws an <see cref="T:System.IndexOutOfRangeException"/>, since <see cref="T:Nordril.Functional.Data.Unit"/> is a 0-tuple.
            </summary>
            <param name="index">The index of the element to get.</param>
            <exception cref="T:System.IndexOutOfRangeException">Always thrown when this indexer is called.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.CompareTo(Nordril.Functional.Data.Unit)">
            <summary>
            Always returns 0.
            </summary>
            <param name="other">The other unit.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Equals(Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="other">The other unit.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Void">
            <summary>
            A void-type that cannot be constructed.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Void.#ctor">
            <summary>
            Constructs the void type (but you can't touch this).
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Writer`3">
            <summary>
            The writer-monad, which provides write-only access to a state, in addition to producing a result.
            The output can then be later extracted, but not by the computations within the writer-monad themselves.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TValue">The type of the result.</typeparam>
            <typeparam name="TMonoid">The monoid on <typeparamref name="TOutput"/> used to combine the outputs. This MUST be a type whose <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0,`0)"/>- and <see cref="P:Nordril.Functional.Algebra.INeutralElement`1.Neutral"/>-operations DO NOT use the this-pointer, i.e. NOT a generic <see cref="T:Nordril.Functional.Algebra.Monoid`1"/>-instance, but some user-made <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/>-instance.</typeparam>
            <remarks>
            The two main functions one can use with a writer are tell (which stores a new output in the state of the writer) and listen (which stores a new output in the state of the writer and also returns it as the writer's result).
            Due to limits of type-inference, using <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/> and <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/> are quite cumbersome; for this reason, specialized versions are provided in the form of <see cref="M:Nordril.Functional.Data.Writer.BindTell``3(Nordril.Functional.Data.Writer{``0,``1,``2},System.Func{``1,``0})"/> (as a specialized replacement for <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>; and <see cref="M:Nordril.Functional.Data.Writer`3.MapWriter``1(System.Func{`1,``0})"/> (as a specialized replacement for <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>).
            </remarks>
        </member>
        <member name="P:Nordril.Functional.Data.Writer`3.State">
            <summary>
            The write-only output of the computation.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Writer`3.Result">
            <summary>
            The result of the computation.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Writer`3.Monoid">
            <summary>
            The output monoid for combining outputs.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.#ctor(`1)">
            <summary>
            Creates a new writer from a result.
            </summary>
            <param name="result">The result to produce.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.#ctor(`1,`0)">
            <summary>
            Creates a new writer from a result, an initial output, and a monoid to combine successive outputs.
            </summary>
            <param name="state">The initial state of the writer.</param>
            <param name="result">The result to produce.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.#ctor(`1,`0,Nordril.Functional.Algebra.IMonoid{`0})">
            <summary>
            Creates a new writer from a result, an initial output, and a monoid to combine successive outputs.
            </summary>
            <param name="state">The initial state of the writer.</param>
            <param name="result">The result to produce.</param>
            <param name="monoid">The monoid on <typeparamref name="TOutput"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.#ctor(System.ValueTuple{`1,`0,Nordril.Functional.Algebra.IMonoid{`0}})">
            <summary>
            Creates a new writer from a result, an initial output, and a monoid to combine successive outputs.
            </summary>
            <param name="args">The initial state of the writer, the result to produce, and the monoid on <typeparamref name="TOutput"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.MapWriter``1(System.Func{`1,``0})">
            <summary>
            A specialized version of <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/> which preserves the type-information that the result is a <see cref="T:Nordril.Functional.Data.Writer`3"/>. Useful in oder to avoid having to specify types.
            </summary>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="f">The </param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`3.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Writer">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Writer`3"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Select``4(Nordril.Functional.Data.Writer{``0,``2,``1},System.Func{``2,``3})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Data.Writer`3"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TOutput">The type of the state.</typeparam>
            <typeparam name="TMonoid">The type of the output monoid.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.SelectMany``5(Nordril.Functional.Data.Writer{``0,``2,``1},System.Func{``2,Nordril.Functional.Data.Writer{``0,``3,``1}},System.Func{``2,``3,``4})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Data.Writer`3"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TOutput">The type of the state.</typeparam>
            <typeparam name="TMonoid">The type of the output monoid.</typeparam>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Tell``2(``0)">
            <summary>
            Stores a new output in the writer and returns no result.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> on <typeparamref name="TOutput"/>.</typeparam>
            <param name="state">The output to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Tell``2(Nordril.Functional.Data.WriterCxt{``0,``1},``0)">
            <summary>
            Stores a new output in the writer and returns no result.
            This is a convenience-method which does not require explicitly specifying the type arguments.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> on <typeparamref name="TOutput"/>.</typeparam>
            <param name="_cxt">The context to fix the type variables.</param>
            <param name="state">The output to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.BindTell``3(Nordril.Functional.Data.Writer{``0,``1,``2},System.Func{``1,``0})">
            <summary>
            Stores a new output in the writer.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TValue">The result of the writer.</typeparam>
            <typeparam name="TMonoid">The <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> on <typeparamref name="TOutput"/>.</typeparam>
            <param name="w">The writer.</param>
            <param name="f">The function which takes the writer's result and returns the output to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Listen``3(Nordril.Functional.Data.Writer{``1,``0,``2})">
            <summary>
            Returns the result of the computation as well as the write-output.
            </summary>
            <typeparam name="TValue">The result of the original writer.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> on <typeparamref name="TOutput"/>.</typeparam>
            <param name="w">The writer.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.ToWriter``3(Nordril.Functional.Category.IFunctor{``1})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Writer`3"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="TValue">The type of the value contained in the functor.</typeparam>
            <typeparam name="TOutput">The type of the writer's state.</typeparam>
            <typeparam name="TMonoid">The type of the writer's monoid.</typeparam>
            <param name="f">The functor to cast to a writer.</param>
        </member>
        <member name="T:Nordril.Functional.Data.WriterCxt`2">
            <summary>
            A type-tag for the <see cref="T:Nordril.Functional.Data.Writer`3"/>-monad. This class contains no data; it just supplies the type-arguments which do not vary inside a single monadic computation and thus eliminates the need to explicitly supply the type arguments to methods like <see cref="M:Nordril.Functional.Data.Writer.Tell``2(``0)"/>. See <see cref="T:Nordril.Functional.Data.RwsCxt`4"/> for examples.
            </summary>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <typeparam name="TMonoid">The type of the monoid used to combine outputs.</typeparam>
        </member>
        <member name="T:Nordril.Functional.EnumExtensions">
            <summary>
            Extension methods for <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.EnumExtensions.To``1(``0,``0)">
            <summary>
            Returns all values of <typeparamref name="T"/> which fall into the open interval bounded by <paramref name="from"/> and <paramref name="to"/>. O(n) in the number of all values in <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the enum.</typeparam>
            <param name="from">The first element to return.</param>
            <param name="to">The last element to return.</param>
        </member>
        <member name="T:Nordril.Functional.F">
            <summary>
            Functional extension methods for functions.
            </summary>
        </member>
        <member name="M:Nordril.Functional.F.Id``1">
            <summary>
            Returns the identity function for a given type.
            </summary>
            <typeparam name="T">The type of the identity function.</typeparam>
        </member>
        <member name="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})">
            <summary>
            Composes two functions. The second function is run with the result of the first.
            </summary>
            <typeparam name="TA">The input of the first function.</typeparam>
            <typeparam name="TB">The output of the first function and input of the second function.</typeparam>
            <typeparam name="TC">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.F.After``3(System.Func{``1,``2},System.Func{``0,``1})">
            <summary>
            Composes two functions. The first function is run with the result of the second.
            This is "traditional" function chaining.
            </summary>
            <typeparam name="TA">The input of the second function.</typeparam>
            <typeparam name="TB">The output of the first function and input of the second function.</typeparam>
            <typeparam name="TC">The output of the first function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Curry``3(System.Func{``0,``1,``2})">
            <summary>
            Curries a binary function, allowing it to take its arguments one by one.
            </summary>
            <typeparam name="TA">The first argument of the function.</typeparam>
            <typeparam name="TB">The second argument of the function.</typeparam>
            <typeparam name="TC">The output of the function.</typeparam>
            <param name="f">The function to curry.</param>
        </member>
        <member name="M:Nordril.Functional.F.Curry``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Curries a ternary function, allowing it to take its arguments one by one.
            </summary>
            <typeparam name="TA">The first argument of the function.</typeparam>
            <typeparam name="TB">The second argument of the function.</typeparam>
            <typeparam name="TC">The third argument of the function.</typeparam>
            <typeparam name="TD">The output of the function.</typeparam>
            <param name="f">The function to curry.</param>
        </member>
        <member name="M:Nordril.Functional.F.Curry``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Curries a quaternary function, allowing it to take its arguments one by one.
            </summary>
            <typeparam name="TA">The first argument of the function.</typeparam>
            <typeparam name="TB">The second argument of the function.</typeparam>
            <typeparam name="TC">The third argument of the function.</typeparam>
            <typeparam name="TD">The fourth argument of the function.</typeparam>
            <typeparam name="TE">The output of the function.</typeparam>
            <param name="f">The function to curry.</param>
        </member>
        <member name="M:Nordril.Functional.F.Uncurry``3(System.Func{``0,System.Func{``1,``2}})">
            <summary>
            Uncurries a binary function, requiring it to take its arguments all at once.
            The inverse of <see cref="M:Nordril.Functional.F.Curry``3(System.Func{``0,``1,``2})"/>.
            </summary>
            <typeparam name="TA">The first argument of the function.</typeparam>
            <typeparam name="TB">The second argument of the function.</typeparam>
            <typeparam name="TC">The output of the function.</typeparam>
            <param name="f">The curried function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Uncurry``4(System.Func{``0,System.Func{``1,System.Func{``2,``3}}})">
            <summary>
            Uncurries a ternary function, requiring it to take its arguments all at once.
            The inverse of <see cref="M:Nordril.Functional.F.Curry``4(System.Func{``0,``1,``2,``3})"/>.
            </summary>
            <typeparam name="TA">The first argument of the function.</typeparam>
            <typeparam name="TB">The second argument of the function.</typeparam>
            <typeparam name="TC">The third argument of the function.</typeparam>
            <typeparam name="TD">The output of the function.</typeparam>
            <param name="f">The curried function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Uncurry``5(System.Func{``0,System.Func{``1,System.Func{``2,System.Func{``3,``4}}}})">
            <summary>
            Uncurries a quaternary function, requiring it to take its arguments all at once.
            The inverse of <see cref="M:Nordril.Functional.F.Curry``5(System.Func{``0,``1,``2,``3,``4})"/>.
            </summary>
            <typeparam name="TA">The first argument of the function.</typeparam>
            <typeparam name="TB">The second argument of the function.</typeparam>
            <typeparam name="TC">The third argument of the function.</typeparam>
            <typeparam name="TD">The fourth argument of the function.</typeparam>
            <typeparam name="TE">The output of the function.</typeparam>
            <param name="f">The curried function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Set``1(``0,System.Action{``0})">
            <summary>
            Applies an action to an object and returns the object.
            Mostly a convenience method for executing setters.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="obj">The object to modify.</param>
            <param name="a">The action to apply.</param>
        </member>
        <member name="M:Nordril.Functional.F.Apply``2(``0,System.Func{``0,``1})">
            <summary>
            Applies a function to an object postfix.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">The object.</param>
            <param name="f">The function to apply to the object.</param>
        </member>
        <member name="T:Nordril.Functional.FE">
            <summary>
            Functional extension methods for function expressions and for metaprogramming.
            </summary>
            <remarks>
            <see cref="T:System.Linq.Expressions.Expression"/>, with the functions
            <list type="number">
                <item><see cref="M:Nordril.Functional.FE.Id``1"/>, </item>
                <item><see cref="M:Nordril.Functional.FE.LiftToExpression``2(System.Func{``0,``1})"/>, </item>
                <item><see cref="M:Nordril.Functional.FE.Then``3(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})"/>, </item>
                <item><see cref="M:Nordril.Functional.FE.First``3(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>, </item>
                <item><see cref="M:Nordril.Functional.FE.Both``4(System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}})"/> </item>
            </list>
            forms a category and an arrow. Arrows are composable computations.
            See http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html.
            </remarks>
        </member>
        <member name="M:Nordril.Functional.FE.Id``1">
            <summary>
            Returns the identity function expression for a given type.
            See <see cref="M:Nordril.Functional.F.Id``1"/>.
            </summary>
            <typeparam name="T">The type of the identity function.</typeparam>
        </member>
        <member name="M:Nordril.Functional.FE.LiftToExpression``2(System.Func{``0,``1})">
            <summary>
            Lifts a function into a function expression. Note that the returned function expression will simply invoke the given function, which will still be a black box, inaccessible to, e.g. LINQ.
            </summary>
            <typeparam name="TA">The input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Then``3(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
            Composes two function expressions. The second function is run with the result of the first.
            See <see cref="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})"/>.
            </summary>
            <typeparam name="TA">The input of the first function.</typeparam>
            <typeparam name="TB">The output of the first function and input of the second function.</typeparam>
            <typeparam name="TC">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.After``3(System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Composes two function expressions. The first function is run with the result of thesecond. This is "traditional" function chaining.
            See <see cref="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})"/>.
            </summary>
            <typeparam name="TA">The input of the first function.</typeparam>
            <typeparam name="TB">The output of the first function and input of the second function.</typeparam>
            <typeparam name="TC">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Binary``4(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2,``3}})">
            <summary>
            Takes two function expressions and returns a new function expression which runs the two function expressions and combines their results via a third, binary function expression. The typical usage is to have two predicates which are combined via a binary operator like <see cref="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)"/>.
            </summary>
            <typeparam name="TA">The input of the functions.</typeparam>
            <typeparam name="TB">The output of the first function and the first input of the combining function.</typeparam>
            <typeparam name="TC">The output of the second function and the second input of the combining function.</typeparam>
            <typeparam name="TD">The output of the binary combining function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
            <param name="combine">The combining function.</param>
            <returns>A function expression which runs <paramref name="f"/> and <paramref name="g"/> and combines their results via <paramref name="combine"/>.</returns>
        </member>
        <member name="M:Nordril.Functional.FE.First``3(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Returns a function expression which applies <paramref name="expr"/> to the first element of the tuple and leaves the second tuple element unchanged.
            </summary>
            <typeparam name="TA">The input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <typeparam name="TIgnored">The second input of the returned function, which is returned unchanged.</typeparam>
            <param name="expr">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Second``3(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Returns a function expression which applies <paramref name="expr"/> to the second element of the tuple and leaves the first tuple element unchanged.
            </summary>
            <typeparam name="TA">The input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <typeparam name="TIgnored">The first input of the returned function, which is returned unchanged.</typeparam>
            <param name="expr">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Both``4(System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}})">
            <summary>
            Takes two function expressions and returns one which executes both, taking and returning two values. Also known as <c>(***)</c>.
            </summary>
            <typeparam name="TA1">The input of the first function.</typeparam>
            <typeparam name="TA2">The input of the second function.</typeparam>
            <typeparam name="TB1">The output of the first function.</typeparam>
            <typeparam name="TB2">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Fanout``3(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
            <summary>
            Takes two function expressions and returns one which executes both with the same argument, returning two values. Also known as <c>(&amp;&amp;&amp;)</c>.
            </summary>
            <typeparam name="TA">The input of the functions.</typeparam>
            <typeparam name="TB">The output of the first function.</typeparam>
            <typeparam name="TC">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Left``3(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Takes a function expression and lifts it into a function expression taking and returning an <see cref="T:Nordril.Functional.Data.Either`2"/> which applies the original function to the <see cref="M:Nordril.Functional.Data.Either.FromLeft``2(``0)"/>, leaving the <see cref="M:Nordril.Functional.Data.Either.FromRight``2(``1)"/> unchanged.
            </summary>
            <typeparam name="TA">Rhe input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <typeparam name="TC">The right value of the <see cref="T:Nordril.Functional.Data.Either`2"/>, which is left unchanged.</typeparam>
            <param name="f">The function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Right``3(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Takes a function expression and lifts it into a function expression taking and returning an <see cref="T:Nordril.Functional.Data.Either`2"/> which applies the original function to the <see cref="M:Nordril.Functional.Data.Either.FromRight``2(``1)"/>, leaving the <see cref="M:Nordril.Functional.Data.Either.FromLeft``2(``0)"/> unchanged.
            </summary>
            <typeparam name="TA">Rhe input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <typeparam name="TC">The left value of the <see cref="T:Nordril.Functional.Data.Either`2"/>, which is left unchanged.</typeparam>
            <param name="f">The function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.EitherOr``4(System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}})">
            <summary>
            Takes two function expressions and lifts them into a function which take take &amp; produce the input/output of either. Also known as <c>(+++)</c>.
            </summary>
            <typeparam name="TA">Rhe input of the first function.</typeparam>
            <typeparam name="TB">The output of the first function.</typeparam>
            <typeparam name="TC">Rhe input of the second function.</typeparam>
            <typeparam name="TD">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Fanin``3(System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
            Takes two function expressions and returns one which takes the inputs of either and merges the result. Also known as <c>|||</c>.
            </summary>
            <typeparam name="TA">The input of the first function.</typeparam>
            <typeparam name="TB">The input of the second function.</typeparam>
            <typeparam name="TC">The outpu of the two functions.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.FE.SplitParameterAndBody``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Takes a one-parameter function expression and splits the parameter from the function-body.
            </summary>
            <typeparam name="TA">The input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <param name="expr">The function expression.</param>
            <returns>The parameter of the function expression and its open body.</returns>
        </member>
        <member name="M:Nordril.Functional.FE.SplitParameterAndBody``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Takes a two-parameter function expression and splits the parameter from the function-body.
            </summary>
            <typeparam name="TA">The first input of the function.</typeparam>
            <typeparam name="TB">The second input of the function.</typeparam>
            <typeparam name="TC">The output of the function.</typeparam>
            <param name="expr">The function expression.</param>
            <returns>The parameters of the function expression and its open body.</returns>
        </member>
        <member name="M:Nordril.Functional.FE.SplitParameterAndBody``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Takes a three-parameter function expression and splits the parameter from the function-body.
            </summary>
            <typeparam name="TA">The first input of the function.</typeparam>
            <typeparam name="TB">The second input of the function.</typeparam>
            <typeparam name="TC">The third input of the function.</typeparam>
            <typeparam name="TD">The output of the function.</typeparam>
            <param name="expr">The function expression.</param>
            <returns>The parameters of the function expression and its open body.</returns>
        </member>
        <member name="M:Nordril.Functional.FE.SplitParameterAndBody``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>
            Takes a three-parameter function expression and splits the parameter from the function-body.
            </summary>
            <typeparam name="TA">The first input of the function.</typeparam>
            <typeparam name="TB">The second input of the function.</typeparam>
            <typeparam name="TC">The third input of the function.</typeparam>
            <typeparam name="TD">The fourth input of the function.</typeparam>
            <typeparam name="TE">The output of the function.</typeparam>
            <param name="expr">The function expression.</param>
            <returns>The parameters of the function expression and its open body.</returns>
        </member>
        <member name="M:Nordril.Functional.FE.Beta``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression)">
            <summary>
            Replaces a parameter in a function expression with a new expression, performing beta-reduction.
            </summary>
            <param name="expr">The expression containing the parameter.</param>
            <param name="value">The value with which to replace the parameter.</param>
            <exception cref="T:System.ArgumentException">If the type of <paramref name="value"/> isn't a subtype of the type of the parameter of <paramref name="expr"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.FE.Beta``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Replaces a parameter in a function expression with a new expression, performing beta-reduction.
            </summary>
            <param name="expr">The expression containing the parameters.</param>
            <param name="value1">The value with which to replace the first parameter.</param>
            <param name="value2">The value with which to replace the second parameter.</param>
            <exception cref="T:System.ArgumentException">If the type of <paramref name="value1"/>/<paramref name="value2"/> isn't a subtype of the type of the first/second parameter of <paramref name="expr"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.FE.Beta(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Replaces two parameter in a function expression with new expressions, performing binary beta-reduction.
            </summary>
            <param name="expr">The expression containing the parameter.</param>
            <param name="param">The parameter to replace.</param>
            <param name="value">The value with which to replace the parameter.</param>
            <exception cref="T:System.ArgumentException">If the type of <paramref name="value"/> isn't a subtype of the type of <paramref name="param"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.FE.Beta(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Replaces a parameter in a function expression with a new expression, performing beta-reduction.
            </summary>
            <param name="expr">The expression containing the parameters.</param>
            <param name="param1">The first parameter to replace.</param>
            <param name="param2">The second parameter to replace.</param>
            <param name="value1">The value with which to replace the first parameter.</param>
            <param name="value2">The value with which to replace the second parameter.</param>
            <exception cref="T:System.ArgumentException">If the type of <paramref name="value1"/>/<paramref name="value2"/> isn't a subtype of the type of <paramref name="param1"/>/<paramref name="param2"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.FE.CastReturnType``3(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Returns a function expression whose return type is a supertype of the original function expression.
            </summary>
            <typeparam name="TA">The input of the function.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <typeparam name="TBSuper">The output of the returned function, which is a supertype of <typeparamref name="TB"/>.</typeparam>
            <param name="expr">The function expression.</param>
        </member>
        <member name="M:Nordril.Functional.FE.CastInputType``3(System.Linq.Expressions.Expression{System.Func{``0,``2}})">
            <summary>
            Returns a function expression whose input type is a subtype of the original function expression.
            </summary>
            <typeparam name="TA">The input of the function.</typeparam>
            <typeparam name="TASub">The input of the returned function, which is a subtype of <typeparamref name="TA"/>.</typeparam>
            <typeparam name="TB">The output of the function.</typeparam>
            <param name="expr">The function expression.</param>
        </member>
        <member name="M:Nordril.Functional.FE.Compile``1(System.Linq.Expressions.Expression)">
            <summary>
            Compiles a closed expression to a function returning <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the expression's return value.</typeparam>
            <param name="expr">The expression to compile.</param>
            <exception cref="T:System.ArgumentException">If the type of <paramref name="expr"/> isn't <typeparamref name="T"/>.</exception>
        </member>
        <member name="T:Nordril.Functional.FE.ParameterExpressionVisitor">
            <summary>
            A visitor which applies a function to a <see cref="T:System.Linq.Expressions.ParameterExpression"/>, replacing it with the function's result.
            </summary>
        </member>
        <member name="T:Nordril.Functional.FuncComparer`1">
            <summary>
            A comparer that uses a binary function to compare two objects.
            </summary>
            <typeparam name="T">The type of objects that this comparer can test for equality.</typeparam>
        </member>
        <member name="M:Nordril.Functional.FuncComparer`1.#ctor(System.Func{`0,`0,System.Int32},System.Func{`0,System.Int32})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1"/> out of a binary function.
            </summary>
            <param name="f">The binary function to lift.</param>
            <param name="getHashCode"></param>
        </member>
        <member name="M:Nordril.Functional.FuncComparer`1.Compare(`0,`0)">
            <summary>
            Uses the supplied binary function to compare two objects.
            </summary>
            <param name="x">The first object.</param>
            <param name="y">The second object.</param>
        </member>
        <member name="T:Nordril.Functional.FuncComparer">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.FuncComparer`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.FuncComparer.Make``1">
            <summary>
            Creates a <see cref="T:Nordril.Functional.FuncComparer`1"/> for a type implementing <see cref="T:System.IComparable`1"/>.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="M:Nordril.Functional.FuncComparer.Make``1(System.Func{``0,``0,System.Int32},System.Func{``0,System.Int32})">
            <summary>
            Create a <see cref="T:Nordril.Functional.FuncComparer`1"/> out of a comparison-function and a hash-function.
            </summary>
            <typeparam name="T">The type of object to compare.</typeparam>
            <param name="f">The comparison function.</param>
            <param name="getHashCode">The hash-function.</param>
        </member>
        <member name="T:Nordril.Functional.FuncEqualityComparer`1">
            <summary>
            An equality comparer that uses a binary predicate to compare two objects for equality.
            </summary>
            <typeparam name="T">The type of objects that this comparer can test for equality.</typeparam>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> out of a binary predicate.
            If two objects should be equal, be sure that their hashcodes are equal as well, otherwise you will get spurious inequalities. Per default, <see cref="M:System.Object.GetHashCode"/> will be used. See <see cref="M:Nordril.Functional.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})"/> for specifying the hash-function.
            </summary>
            <param name="f">The binary predicate to lift.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> out of a binary predicate.
            If two objects should be equal, be sure that their hashcodes are equal as well, otherwise you will get spurious inequalities.
            </summary>
            <param name="f">The binary predicate to lift.</param>
            <param name="getHashCode">The hashing-function for objects.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Uses the supplied binary predicate to compare two objects for equality.
            </summary>
            <param name="x">The first object.</param>
            <param name="y">The second object.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Uses the object's <see cref="M:System.Object.GetHashCode"/> function or the hashing-function passed in the constructor.
            </summary>
            <param name="obj">The object to hash.</param>
        </member>
        <member name="T:Nordril.Functional.FuncEqualityComparer">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.FuncEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer.Make``1(System.Func{``0,``0,System.Boolean})">
            <summary>
            Turns a binary predicate into a <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="f">The comparison function.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer.Make``1(System.Func{``0,``0,System.Boolean},System.Func{``0,System.Int32})">
            <summary>
            Turns a binary predicate into a <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="f">The comparison function.</param>
            <param name="getHashCode">The hash-function.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer.Make``1">
            <summary>
            Creates a <see cref="T:Nordril.Functional.FuncEqualityComparer`1"/> for a type implementing <see cref="T:System.IEquatable`1"/>.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
        </member>
        <member name="T:Nordril.Functional.ICopyable`1">
            <summary>
            A typed version of <see cref="T:System.ICloneable"/> which creates a deep copy of the object.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.ICopyable`1.Copy">
            <summary>
            Creates a deep copy of the object that can be modified independently of the original.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.Fold`2">
            <summary>
            A fold.
            </summary>
            <typeparam name="S"></typeparam>
            <typeparam name="A"></typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.Fold`2.#ctor(System.Func{System.Type,System.Func{System.Func{`1,Nordril.Functional.Category.IContravariantApplicative{`1}},System.Func{`0,Nordril.Functional.Category.IContravariantApplicative{`0}}}})">
            <summary>
            Creates a new fold.
            </summary>
            <param name="f">The fold-function.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.Fold`2.FoldFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Fold`2.FoldFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Fold`2.FoldFuncConst``2">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.Getter`2">
            <summary>
            A concrete getter.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="A">The type of the object to get in <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.Getter`2.FoldFuncConst``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Getter`2.FoldFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Getter`2.GetFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Getter`2.GetFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Getter`2.FoldFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.IFold`2">
            <summary>
            A folding-operation which allows us to get multiple results (or 0) from a data structure.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="A">The type of the objects to get in <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IFold`2.FoldFuncConst``2">
            <summary>
            Returns the fold in CPS-form, strongly tyed to <see cref="T:Nordril.Functional.Data.Const`3"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.IFold`2.FoldFunc``2">
            <summary>
            Returns the fold in CPS-form, strongly typed.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.IFold`2.FoldFunc(System.Type)">
            <summary>
            Returns the fold in CPS-form.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.IGetter`2">
            <summary>
            A getter which does not modify its input and returns some part of it.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="A">The type of the object to get in <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IGetter`2.GetFunc``2">
            <summary>
            Returns the getter in CPS-form.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.IGetter`2.GetFunc(System.Type)">
            <summary>
            Returns the getter in CPS-form.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.ILens`4">
            <summary>
            A setter which can also be used as a traversal.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.IMonoLens`2">
            <summary>
            A lens, which is a combined <see cref="T:Nordril.Functional.Lens.IGetter`2"/> and <see cref="T:Nordril.Functional.Lens.ISetter`4"/>.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="A">The type of the object to get/modify in <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IMonoLens`2.LensFunc``2">
            <summary>
            Returns the lens-function, which must work with any <see cref="T:Nordril.Functional.Category.IFunctor`1"/> for <typeparamref name="A"/> and <typeparamref name="S"/>.
            </summary>
            <typeparam name="FA">The concrete functor for <typeparamref name="A"/>.</typeparam>
            <typeparam name="FS">The concrete functor for <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IMonoLens`2.LensFunc(System.Type)">
            <summary>
            Returns the lens-function, which must work with any <see cref="T:Nordril.Functional.Category.IFunctor`1"/> for <typeparamref name="A"/> and <typeparamref name="S"/>.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.IMonoPrism`2">
            <summary>
            A getter that "may work" for some types of input (e.g. on the left-case of <see cref="T:Nordril.Functional.Data.Either`2"/> only), and which can always be turned around (e.g. one can always turn a left-value into an see cref="Either{TLeft, TRight}"/>).
            This is a special case of <see cref="T:Nordril.Functional.Lens.IPrism`4"/> that does not change the types of its inputs.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Lens.IMonoTraversal`2">
            <summary>
            A monomorphic traversal.
            </summary>
            <typeparam name="S">The type of the structure.</typeparam>
            <typeparam name="A">The type of the elements in the structure.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Lens.IPrism`4">
            <summary>
            A getter that "may work" for some types of input (e.g. on the left-case of <see cref="T:Nordril.Functional.Data.Either`2"/> only), and which can always be turned around (e.g. one can always turn a left-value into an see cref="Either{TLeft, TRight}"/>).
            N.B. Failure means "it returns Maybe.Nothing", not "throws an exception".
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IPrism`4.PrismFunc``4">
            <summary>
            Returns the prism-function, which must work with any <see cref="T:Nordril.Functional.Category.IApplicative`1"/> for <typeparamref name="B"/> and <typeparamref name="T"/>.
            </summary>
            <typeparam name="FB">The concrete functor for <typeparamref name="B"/>.</typeparam>
            <typeparam name="FT">The concrete functor for <typeparamref name="T"/>.</typeparam>
            <typeparam name="PAFB">The concrete profunctor from <typeparamref name="A"/> to <typeparamref name="FB"/>.</typeparam>
            <typeparam name="PSFT">The concrete profunctor from <typeparamref name="S"/> to <typeparamref name="FT"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IPrism`4.PrismFunc(System.Type)">
            <summary>
            Returns the prism-function, which must work with any <see cref="T:Nordril.Functional.Category.IApplicative`1"/> for <typeparamref name="B"/> and <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.ISetter`4">
            <summary>
            A setter which applies a function to some part of its input.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Lens.ISetter`4.SetFunc">
            <summary>
            Returns the setter in CPS-form.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.ITraversal`4">
            <summary>
            A setter which can read/update multiple fields.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.ITraversal`4.TraversalFunc``2">
            <summary>
            Returns the traversal-function, which must work with any <see cref="T:Nordril.Functional.Category.IApplicative`1"/> for <typeparamref name="B"/> and <typeparamref name="T"/>.
            </summary>
            <typeparam name="FB">The concrete functor for <typeparamref name="B"/>.</typeparam>
            <typeparam name="FT">The concrete functor for <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.ITraversal`4.TraversalFunc(System.Type)">
            <summary>
            Returns the traversal-function, which must work with any <see cref="T:Nordril.Functional.Category.IApplicative`1"/> for <typeparamref name="B"/> and <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.IWithering`4">
            <summary>
            A "filter" on values. Even though <see cref="T:Nordril.Functional.Category.IWitherable`1"/> is a subtype of <see cref="T:Nordril.Functional.Category.ITraversable`1"/>, an <see cref="T:Nordril.Functional.Lens.IWithering`4"/> is not, in general, a valid traversal or setter.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IWithering`4.WitherFunc``2">
            <summary>
            Returns the wither-function, which must work with any <see cref="T:Nordril.Functional.Category.IAlternative`1"/> for <typeparamref name="B"/> and <typeparamref name="T"/>.
            </summary>
            <typeparam name="FB">The concrete functor for <typeparamref name="B"/>.</typeparam>
            <typeparam name="FT">The concrete functor for <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.IWithering`4.WitherFunc(System.Type)">
            <summary>
            Returns the wither-function, which must work with any <see cref="T:Nordril.Functional.Category.IAlternative`1"/> for <typeparamref name="B"/> and <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Lens.L">
            <summary>
            Lenses; first-class getters, settings, and updaters.
            See the <see cref="M:Nordril.Functional.Lens.L.Make.Getter``2(System.Func{``0,``1})"/>-family of functions in creating lenses and <see cref="M:Nordril.Functional.Lens.L.Get``2(Nordril.Functional.Lens.IGetter{``0,``1},``0)"/>, <see cref="M:Nordril.Functional.Lens.L.Set``4(Nordril.Functional.Lens.ISetter{``0,``1,``2,``3},``0,``3)"/>, and <see cref="M:Nordril.Functional.Lens.L.Update``4(Nordril.Functional.Lens.ISetter{``0,``1,``2,``3},``0,System.Func{``2,``3})"/> on how to execute them.
            See the remarks and examples.
            </summary>
            <remarks>
            A lens is basically a function of the type <c>(a -> f&lt;b&gt;) -> s -> f&lt;t&gt;</c>, where the arrow denotes a function. <c>s</c> is an input data structure, like a list, <c>a</c> is the part of <c>s</c> to modify, say, a string inside the list, <c>b</c> is the result of the modification, like an integer that is the length of the string, and <c>t</c> is the resulting structure, in this example a list of integers. <c>f</c>, lastly, is an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> which defined what the "lens" does, exactly, and <c>f</c> defines whether a lens can work as a getter, setter, both, a traversal, etc. - it is the "added feature" or the lens.
            
            If we only want to create a setter, which can update a value but nothing else, we set <c>f</c> to <see cref="T:Nordril.Functional.Data.Identity`1"/>. <see cref="T:Nordril.Functional.Data.Identity`1"/> is just a featureless wrapper, meaning that we can use it to update the value <c>a</c>, but nothing else.
            If we want to create a getter, which can retrieve values, we set <c>f</c> to <see cref="T:Nordril.Functional.Data.Const`2"/>. Let's look at the function <c>a -> f&lt;b&gt;</c> which "updates" <c>a</c> and replace <c>f</c> with <see cref="T:Nordril.Functional.Data.Const`2"/>: <c>a -> Const&lt;a,a&gt;</c>. Here, we store the value of <c>a</c> in the real-part, and set the phantom-part (which is not present) to <c>a</c> as well. However, note that the whole lens becomes this: <c>(a -> Const&lt;a, b&gt;) -> s -> Const&lt;a, T&gt;</c>. The final <see cref="T:Nordril.Functional.Data.Const`2"/> contains <c>t</c> as the phantom-part, meaning it doesn't actually have a value of type <c>t</c>, but <c>a</c> as its real-part. We thus use <see cref="T:Nordril.Functional.Data.Const`2"/> to "smuggle out" the inner <c>a</c>.
            We can also create a lens which can work as both a getter and a setter via <see cref="T:Nordril.Functional.Lens.IMonoLens`2"/>, where <c>f</c> is any <see cref="T:Nordril.Functional.Category.IFunctor`1"/>. Here, <c>f</c> must be <em>universally quantified</em>, meaning it must be able to use and produce any functor that the caller desires.
            <h1>Using this class</h1>
            <para>
            All methods in this class are static and thread-safe, the class has no internal state. You can create lenses, getters, setters, etc. via the methods of the <see cref="T:Nordril.Functional.Lens.L.Make"/>-class and transform them using the methods of the <see cref="T:Nordril.Functional.Lens.L.Do"/>-class. Methods to consume lenses are in this class directly.
            </para>
            <h1>Lens laws</h1>
            A lens must obey the following laws:
            <code>
                //1. You get what you put in<br />
                Lens.Get(L, Lens.Set(L, X, V)) == X<br />
                //2. Putting back what you got doesn't change anything<br />
                Lens.Set(L, X, Lens.Get(L, X)) == X<br />
                //3. Setting twice is the same thing as setting once<br />
                Lens.Set(L, Lens.Set(L, X, V2), V1) == Lens.Set(L, X, V2)<br />
            </code>
            <h1>Hierarchy of lenses</h1>
            <para>
            The hierarchy of lenses is this:
            Fold &lt;- Getter, MonoTraversal<br />
            Setter &lt;- Traversal<br />
            Getter &lt;- MonoLens<br />
            Traversal &lt;- Lens, Prism<br />
            Lens &lt;- MonoLens<br />
            There are also Reviews, Isos and Equalities, but they are currently not implemented.
            </para>
            <para>
            <see cref="T:Nordril.Functional.Lens.IFold`2"/> can retrieve 0 to more values from a container. <see cref="T:Nordril.Functional.Lens.IFold`2"/>s mainly consume their inputs via TODO.
            A special case of <see cref="T:Nordril.Functional.Lens.IFold`2"/> is <see cref="T:Nordril.Functional.Lens.IGetter`2"/>, which retrieves exactly one value from a container.
            The opposite is an <see cref="T:Nordril.Functional.Lens.ISetter`4"/>, which replaces some part of its container with an updated value.
            The special case of an <see cref="T:Nordril.Functional.Lens.ISetter`4"/> is an <see cref="T:Nordril.Functional.Lens.ITraversal`4"/>, which can change multiple elements in its container, elementwise.
            An <see cref="T:Nordril.Functional.Lens.ILens`4"/> can serve as both an <see cref="T:Nordril.Functional.Lens.ITraversal`4"/> (and therefore an <see cref="T:Nordril.Functional.Lens.ISetter`4"/>) and, if it's an <see cref="T:Nordril.Functional.Lens.IMonoLens`2"/>, also an <see cref="T:Nordril.Functional.Lens.IGetter`2"/>. Thus, an <see cref="T:Nordril.Functional.Lens.IMonoLens`2"/> is a combined <see cref="T:Nordril.Functional.Lens.IGetter`2"/> and <see cref="T:Nordril.Functional.Lens.ISetter`4"/> which can, say, get and update a field in a class.
            We also have <see cref="T:Nordril.Functional.Lens.IPrism`4"/>, which is the "opposite" of an <see cref="T:Nordril.Functional.Lens.ILens`4"/>: whereas an <see cref="T:Nordril.Functional.Lens.ILens`4"/> can get a part from a whole, an <see cref="T:Nordril.Functional.Lens.IPrism`4"/> can assemble a part into a whole or, equivalently, try to get a part from the whole if it's the right type. An <see cref="T:Nordril.Functional.Lens.IPrism`4"/> is thus an <see cref="T:Nordril.Functional.Lens.ILens`4"/> which "may fail" in trying to get the part. To illustrate this, consider tuples and <see cref="T:Nordril.Functional.Data.Either`2"/>: we can write an <see cref="T:Nordril.Functional.Lens.ILens`4"/> for a tuple which gets and can change, say, the first element, but we can't write one for the left-case of <see cref="T:Nordril.Functional.Data.Either`2"/>, since the <see cref="T:Nordril.Functional.Data.Either`2"/> may contain a right-case. However, we can write an <see cref="T:Nordril.Functional.Lens.IPrism`4"/>, which tries to get the left-case (failing with <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if it's a right-case) and, in the opposite direction, can turn a value into an <see cref="T:Nordril.Functional.Data.Either`2"/> but creating a left-case.
            </para>
            <h1>Creating lenses</h1>
            <para>
            All lenses can be created via the methods of <see cref="T:Nordril.Functional.Lens.L.Make"/>, with the most common cases being:
            <list type="bullet">
                <item><see cref="M:Nordril.Functional.Lens.L.Make.Getter``2(System.Func{``0,``1})"/> to create a getter from a function which gets a part <c>A</c> from a hole <c>S</c>, </item>
                <item><see cref="M:Nordril.Functional.Lens.L.Make.Setter``2(System.Func{System.Func{``1,``1},System.Func{``0,``0}})"/> to create a setter from a function which takes an updater (<c>A to A</c>) and uses it to update the whole <c>S</c>, </item>
                <item><see cref="M:Nordril.Functional.Lens.L.Make.Lens``2(System.Func{``0,``1},System.Func{``0,``1,``0})"/> to create a lens from a getting-function and an updating-function which takes a whole <c>S</c>, the new value <c>A</c>, and returns a new <c>S</c>, </item>
                <item><see cref="M:Nordril.Functional.Lens.L.Make.Prism``3(System.Func{``2,``0},System.Func{``0,Nordril.Functional.Data.Maybe{``1}})"/> to create a prism from an compose-function which can turn a <c>B</c> into a whole <c>S</c>, and an extraction-function which tries to get a part <c>A</c> from a whole <c>S</c>, </item>
                <item><see cref="M:Nordril.Functional.Lens.L.Make.Traversal``2"/>, which create a traversal for a type which implements <see cref="T:Nordril.Functional.Category.ITraversable`1"/> with contents <c>A</c>, </item>
                <item><see cref="M:Nordril.Functional.Lens.L.Make.Folding``3(System.Func{``1,``0})"/> which creates a fold from a function which maps a whole <c>S</c> into an instance of <see cref="T:Nordril.Functional.Category.IFoldable`1"/> (<see cref="T:Nordril.Functional.Category.IFoldable`1"/> is basically the same as <see cref="T:System.Collections.Generic.IEnumerable`1"/>).</item>
            </list>
            </para>
            <h1>Composing lenses</h1>
            <para>Two lenses <c>L1</c> and <c>L2</c> can actually be composed using function composition, meaning <c>L1(L2(x))</c>. However, since the "raw" functions are not exposed for technical reasons, one can use the "Then"-methods of this class instead, which just perform function-composition in the background. To compose two getters into a single getter, where <c>L1</c> gets, for instance, a string from a list of strings, and where <c>L2</c> retrieves a substring from a string, one would write <c>var subStringFromStringList = L1.Then(L2)</c>.
            <h1>Mutating and well-behaved lenses</h1>
            Technically, lenses should not mutate their arguments but only return results that reflect changes, but as a matter of practicality, some lenses do. These are noted in this class as <em>mutating</em>, an example being <see cref="M:Nordril.Functional.Lens.L.Make.IndexSetter``3"/>, which mutates a dictionary in-place. We call lenses which obey the lens-laws and do not mutate their inputs <em>well-behaved</em>, and lenses which aren't explicitly said to be mutating in this class are well-behaved.
            </para>
            
            <h1>Executing lenses</h1>
            <para>todo</para>
            <h1>History</h1>
            <para>Lenses developed over time and the result of the work of Jeremy Gibbons, Luke Palmer, Twan van Laarhoven, Rossel O'Connor, and Edward Kmett, as detailed in https://github.com/ekmett/lens/wiki/History-of-Lenses .<br />
            The structure of the library is taken (with simplifications) from Edward Kmett's lens-library: https://github.com/ekmett/lens.
            </para>
            <h1>Technical background and additional information</h1>
            <para>
            Formally, a lenslike object (including folds, traversals, getters, lenses, etc.) is just a function of the following type:
            <code>
            type Lenslike&lt;p,f,s,t,a,b&gt; = Func&lt;p&lt;a,f&lt;b&gt;&gt;,p&lt;s,f&lt;t&gt;&gt;
            </code>
            Depending on the choice of <c>p</c> and <c>f</c>, we get a fold, traversal, getter, etc. Of course, this looks quite opaque, so let's insert concrete types: for <c>p</c>, which has to be a profunctor (<see cref="T:System.Func`2"/> is a profunctor, meaning you can prepend a function and append another to it), we insert <see cref="T:System.Func`2"/>, and for <c>f</c>, we insert <see cref="T:Nordril.Functional.Data.Identity`1"/>. This then becomes:
            <code>
            type Lenslike&lt;s,t,a,b&gt; = Func&lt;Func&lt;a, Identity&lt;b&gt;&gt;, Func&lt;s,Identity&lt;t&gt;&gt;&gt;
            </code>
            <see cref="T:Nordril.Functional.Data.Identity`1"/> does nothing and just stores a value, so conceptually, we can omit it and we have:
            <code>
            type Lenslike = Func&lt;Func&lt;a, b&gt;, Func&lt;s,t&gt;&gt;
            </code>
            So now we have a function which takes an "updater" (a function which takes an <c>a</c> and returns a <c>b</c>) and then gives us a function which takes an <c>s</c> and returns a <c>t</c>. Let's further say that <c>s = t = Person</c> and <c>a = b = string</c> (the person's name):
            <code>
            type Lenslike = Func&lt;Func&lt;string, string&lt;, Func&lt;Person, Person&gt;&gt;
            </code>
            This is a concrete setter which updates a person's name: we take an updating-function (which can do any update on the name and is chosen by <see cref="M:Nordril.Functional.Lens.L.Set``4(Nordril.Functional.Lens.ISetter{``0,``1,``2,``3},``0,``3)"/>), a <c>Person</c>, and returns a new <c>Person</c>.
            If we had chosen <see cref="T:Nordril.Functional.Data.Const`2"/> for <c>f</c> instead, we would have an <see cref="T:Nordril.Functional.Lens.IGetter`2"/>: with <c>Const&lt;A,B&gt;</c> and <c>Const&lt;A, T&gt;</c>we don't actually store a <c>b</c> or a <c>t</c>, but only have the <c>a</c> (the first type-variable) as a real value, which we "smuggle out" via the <see cref="T:Nordril.Functional.Data.Const`2"/>-functor. In general, different choices for <c>p</c> and <c>f</c> give us different types of lenslike objects, and often, we don't even have concrete <c>p</c> and <c>f</c>, but only generic type variables with constraints on them like <c>f : IFunctor</c> but we obviously cannot write a delegate like <c>Lenslike</c> in C#, since it's a <em>universally quantified rank-2 type</em>, meaning that, in the case of <see cref="T:Nordril.Functional.Lens.IMonoLens`2"/>, say, the lens must be able to return any functor that the called requests, not just some <see cref="T:Nordril.Functional.Category.IFunctor`1"/> of its choosing. Furthermore, the concrete <see cref="T:Nordril.Functional.Category.IFunctor`1"/>-type is not part of the type-signature of <see cref="T:Nordril.Functional.Lens.IMonoLens`2"/> (hence "rank-2").
            </para>
            <para>
            Lenses come from Haskell and the main source of information is the https://github.com/ekmett/lens repo, which also includes addition information. There is also a tutorial-package at https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html by Gabriel Gonzalez.
            </para>
            </remarks>
            <example>
            Suppose we have a class <c>Person</c> which contains a name and a list of names of friends.
            <code>
            public class Person
            {
               public string Name { get; set; }
               public FuncList&lt;string&gt; Friends { get; set; }
            }
            </code>
            <para>
            We now create a lens for the person's name and a fold and traversal for the person's list of friends. We create a well-behaved lens which does not update the original person when run.
            <code>
            var bill = new Person { Name = "bill", Friends = FuncList.Make("adam", "tiffany", "zack") };
            
            var nameLens = L.Make.Lens&lt;Person, string&gt;(p =&gt; p.Name, (p, n) =&gt; new Person { Name = n; Friends = Friends.MakeFunctList();
            var friendsFold = L.Make.Folding(p =&gt; p.Friends);
            var friendsTraversal = L.Make.Traversal&lt;FuncList&lt;string&gt;, int&gt;();
            //Usage:
            //We get the name of bill.
            Console.WriteLine(L.Get(nameLens, bill));
            
            //We change  bill's name to sophie and get it (the original bill remains unchanged).
            var sophie = L.Set(nameLens, bill, "sophie");
            Console.WriteLine(L.Get(nameLens, sophie));
            
            //We go through sophie's friends and fail if "big tom" is included, and we change each friend's name from "x" to "big x".
            var bigSophie = L.Traverse(friendsTraversal), f =&gt; Maybe.JustIf(f != "big tom", () =&gt; "big " + f), sophie).ToMaybe().Value();
            bigSophie.Friends.ForEach(f =&gt; Console.WriteLine(f));
            
            //We now add "big tom" to bigSophie's friends (FuncList.Add is not a pure operation, but for example's sake).
            L.Update(friendsTraversal, bigSophie, fs =&gt; fs.Add("big tom"));
            
            //We run the traversal again, but this time, we get no new person back, since it included "big tom":
            bigSophieFailed = L.Traverse(friendsTraversal), f =&gt; Maybe.JustIf(f != "big tom", () =&gt; "big " + f), sophie).ToMaybe();
            Console.WriteLine(bigSophieFailed.HasValue);
            
            //Output:
            bill
            sophie
            big adam
            big tiffany
            big zack
            false
            
            </code>
            </para>
            </example>
        </member>
        <member name="T:Nordril.Functional.Lens.L.Make">
            <summary>
            Contains methods for creating getters, setters, lenses, prisms, etc.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Just``2">
            <summary>
            Makes a prism that returns the value of a <see cref="T:Nordril.Functional.Data.Maybe`1"/>, if it exists.
            </summary>
            <typeparam name="A">The type of the contained value.</typeparam>
            <typeparam name="B">The type of the output value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.First``3">
            <summary>
            Makes a prism which returns the first value of an Either, if it exists.
            </summary>
            <typeparam name="A">The type of the input value</typeparam>
            <typeparam name="B">The type of the output value</typeparam>
            <typeparam name="T2">The type of the second value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Second``3">
            <summary>
            Makes a prism which returns the second value of an Either, if it exists.
            </summary>
            <typeparam name="A">The type of the input value</typeparam>
            <typeparam name="B">The type of the output value</typeparam>
            <typeparam name="T1">The type of the first value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Folding``3(System.Func{``1,``0})">
            <summary>
            Create an <see cref="T:Nordril.Functional.Lens.IFold`2"/> for a type which implements <see cref="T:Nordril.Functional.Category.IFoldable`1"/>
            </summary>
            <typeparam name="TFoldable">The result of the inner function, which is foldable.</typeparam>
            <typeparam name="S">The type of the data structure to fold.</typeparam>
            <typeparam name="A">The type of the resulting elements.</typeparam>
            <param name="toFoldable">The getter which returns an <see cref="T:Nordril.Functional.Category.IFoldable`1"/> from <typeparamref name="S"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Folding``2">
            <summary>
            Create an <see cref="T:Nordril.Functional.Lens.IFold`2"/> for a type which implements <see cref="T:Nordril.Functional.Category.IFoldable`1"/>
            </summary>
            <typeparam name="S">The type of the foldable data structure to fold.</typeparam>
            <typeparam name="A">The type of the resulting elements.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Getter``2(System.Func{``0,``1})">
            <summary>
            Creates a getter out of an accessing-function.
            </summary>
            <typeparam name="S">The type of the container.</typeparam>
            <typeparam name="A">The type of the retrieved value.</typeparam>
            <param name="get">The accessing-function.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Lens``2(System.Func{``0,``1},System.Func{``0,``1,``0})">
            <summary>
            Creates a lens (a combined getter/setter) out of a pair of accessing- and setting-functions.
            </summary>
            <typeparam name="S">The type of the container.</typeparam>
            <typeparam name="A">The type of the result.</typeparam>
            <param name="get">The accessing-function.</param>
            <param name="set">The setting-function.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.AtSetter``2(System.Int32)">
            <summary>
            Create a mutating lens for a given index <paramref name="index"/> which updates, removes, or adds an element in a list.
            </summary>
            <typeparam name="S">The type of the list-container.</typeparam>
            <typeparam name="A">The type of the value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.AtSetter``3(``2)">
            <summary>
            Create a mutating lens for a given key <paramref name="key"/> which updates, removes, or adds an element in a dictionary.
            </summary>
            <typeparam name="S">The type of the dictionary-container.</typeparam>
            <typeparam name="A">The type of the value.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Id``1">
            <summary>
            The identity lens.
            </summary>
            <typeparam name="S">The type of the data.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Func``2(System.Func{``0,``1},System.Func{``1,``0})">
            <summary>
            Turns a function into a lens.
            </summary>
            <typeparam name="S">The type of the input.</typeparam>
            <typeparam name="T">The type of the output.</typeparam>
            <param name="f">The function to get the output.</param>
            <param name="g">The function to get the input from the output.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Prism``4(System.Func{``3,``1},System.Func{``0,Nordril.Functional.Data.Either{``1,``2}})">
            <summary>
            Makes a prism from a <paramref name="get"/>-function which tries to get the value <typeparamref name="A"/> from <typeparamref name="S"/>,
            and a <paramref name="compose"/>-function, which puts the result <typeparamref name="B"/> back into a <typeparamref name="T"/> if <paramref name="get"/> succeeded.
            </summary>
            <typeparam name="S">The type of the input container.</typeparam>
            <typeparam name="T">The type of the output container.</typeparam>
            <typeparam name="A">The type of the value to get.</typeparam>
            <typeparam name="B">The type of the result inside <typeparamref name="T"/>.</typeparam>
            <param name="compose">The function which puts the result back into a structure and returns the result if <paramref name="get"/> was successful.</param>
            <param name="get">The function which tries to get part of the structure.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Prism``3(System.Func{``2,``0},System.Func{``0,Nordril.Functional.Data.Maybe{``1}})">
            <summary>
            Makes a prism from a <paramref name="get"/>-function which tries to get the value <typeparamref name="A"/> from <typeparamref name="S"/>,
            and a <paramref name="compose"/>-function, which puts the result <typeparamref name="B"/> back into a <typeparamref name="S"/> if <paramref name="get"/> succeeded.
            </summary>
            <typeparam name="S">The type of the container.</typeparam>
            <typeparam name="A">The type of the value to get.</typeparam>
            <typeparam name="B">The type of the result inside <typeparamref name="S"/>.</typeparam>
            <param name="compose">The function which puts the result back into a structure and returns the result if <paramref name="get"/> was successful.</param>
            <param name="get">The function which tries to get part of the structure.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Setter``4(System.Func{System.Func{``2,``3},System.Func{``0,``1}})">
            <summary>
            Creates a setter out of a setting-function.
            If you do not need to change the type of the value and the container, see <see cref="M:Nordril.Functional.Lens.L.Make.Setter``2(System.Func{System.Func{``1,``1},System.Func{``0,``0}})"/>.
            </summary>
            <typeparam name="S">The type of the input container.</typeparam>
            <typeparam name="T">The type of the output container.</typeparam>
            <typeparam name="A">The type of the value to set.</typeparam>
            <typeparam name="B">The type of the result of the setting.</typeparam>
            <param name="set">The function which takes a function that modifies a value of type <typeparamref name="A"/>, an input-container of type <typeparamref name="S"/>, and which returns an output-container of type <typeparamref name="T"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Setter``2(System.Func{System.Func{``1,``1},System.Func{``0,``0}})">
            <summary>
            Creates a setter out of a setting-function which does not change the type of the value or its container.
            </summary>
            <typeparam name="S">The type of the input container.</typeparam>
            <typeparam name="A">The type of the value to set.</typeparam>
            <param name="set">The function which takes a function that modifies a value of type <typeparamref name="A"/>, an input-container of type <typeparamref name="S"/>, and which returns an output-container of type <typeparamref name="S"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.MappedSetter``4">
            <summary>
            Creates a setter which applies a function to each element of an <see cref="T:Nordril.Functional.Category.IFunctor`1"/>.
            </summary>
            <typeparam name="S">The type of the input container.</typeparam>
            <typeparam name="T">The type of the output container.</typeparam>
            <typeparam name="A">The type of the value to set.</typeparam>
            <typeparam name="B">The type of the result of the setting.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.KeyedMappedSetter``5">
            <summary>
            Creates a setter which applies a function to each element of an <see cref="T:Nordril.Functional.Category.IKeyedFunctor`2"/>, also accessing the element's index.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.IndexSetter``2">
            <summary>
            Creates a mutating setter which sets an element in a collection with a given index.
            If the index does not fall into the list, nothing is done.
            </summary>
            <typeparam name="A">The type of the value.</typeparam>
            <typeparam name="S">The type of the list.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.IndexSetter``3">
            <summary>
            Creates a mutating setter which sets an element in a collection with a given index.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="A">The type of the value.</typeparam>
            <typeparam name="S">The type of the dictionary.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Traversal``4">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Lens.ITraversal`4"/> for a type <typeparamref name="S"/> which is <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.
            </summary>
            <typeparam name="S">The type of the <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.</typeparam>
            <typeparam name="T">The type of the resulting <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.</typeparam>
            <typeparam name="B">The type of the result of the inner function.</typeparam>
            <typeparam name="A">The type of the contained elements.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Traversal``2">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Lens.IMonoTraversal`2"/> for a type <typeparamref name="S"/> which is <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.
            </summary>
            <typeparam name="S">The type of the <see cref="T:Nordril.Functional.Category.ITraversable`1"/>.</typeparam>
            <typeparam name="A">The type of the contained elements.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``2">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``3">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``4">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``5">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``6">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``7">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item1``8">
            <summary>
            Makes a lens for the first element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``2">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``3">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``4">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``5">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``6">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``7">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item2``8">
            <summary>
            Makes a lens for the second element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item3``3">
            <summary>
            Makes a lens for the third element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item3``4">
            <summary>
            Makes a lens for the third element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item3``5">
            <summary>
            Makes a lens for the third element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item3``6">
            <summary>
            Makes a lens for the third element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item3``7">
            <summary>
            Makes a lens for the third element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item3``8">
            <summary>
            Makes a lens for the third element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item4``4">
            <summary>
            Makes a lens for the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item4``5">
            <summary>
            Makes a lens for the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item4``6">
            <summary>
            Makes a lens for the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item4``7">
            <summary>
            Makes a lens for the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item4``8">
            <summary>
            Makes a lens for the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item5``5">
            <summary>
            Makes a lens for the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item5``6">
            <summary>
            Makes a lens for the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item5``7">
            <summary>
            Makes a lens for the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item5``8">
            <summary>
            Makes a lens for the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item6``6">
            <summary>
            Makes a lens for the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item6``7">
            <summary>
            Makes a lens for the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item6``8">
            <summary>
            Makes a lens for the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item7``7">
            <summary>
            Makes a lens for the seventh element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Item7``8">
            <summary>
            Makes a lens for theseventh element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Rest``8">
            <summary>
            Makes a lens for the rest of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TRest">The type of the rest.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Withering``4">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Lens.IWithering`4"/> for a type <typeparamref name="S"/> which is <see cref="T:Nordril.Functional.Category.IWitherable`1"/>.
            </summary>
            <typeparam name="S">The type of the <see cref="T:Nordril.Functional.Category.IWitherable`1"/>.</typeparam>
            <typeparam name="T">The type of the resulting <see cref="T:Nordril.Functional.Category.IWitherable`1"/>.</typeparam>
            <typeparam name="B">The type of the result of the inner function.</typeparam>
            <typeparam name="A">The type of the contained elements.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Make.Withering``2">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Lens.IWithering`4"/> for a type <typeparamref name="S"/> which is <see cref="T:Nordril.Functional.Category.IWitherable`1"/>.
            </summary>
            <typeparam name="S">The type of the <see cref="T:Nordril.Functional.Category.IWitherable`1"/>.</typeparam>
            <typeparam name="A">The type of the contained elements.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Lens.L.Do">
            <summary>
            Contains methods for transforming lenses.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``4(Nordril.Functional.Lens.IMonoLens{``0,``2},Nordril.Functional.Lens.IMonoLens{``1,``3})">
            <summary>
            Combines 2 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``6(Nordril.Functional.Lens.IMonoLens{``0,``3},Nordril.Functional.Lens.IMonoLens{``1,``4},Nordril.Functional.Lens.IMonoLens{``2,``5})">
            <summary>
            Combines 3 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TA3">The type of the third input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <typeparam name="TB3">The type of the third output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
            <param name="l3">The third lens.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``8(Nordril.Functional.Lens.IMonoLens{``0,``4},Nordril.Functional.Lens.IMonoLens{``1,``5},Nordril.Functional.Lens.IMonoLens{``2,``6},Nordril.Functional.Lens.IMonoLens{``3,``7})">
            <summary>
            Combines 4 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TA3">The type of the third input.</typeparam>
            <typeparam name="TA4">The type of the fourth input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <typeparam name="TB3">The type of the third output.</typeparam>
            <typeparam name="TB4">The type of the fourth output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
            <param name="l3">The third lens.</param>
            <param name="l4">The fourth lens.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``10(Nordril.Functional.Lens.IMonoLens{``0,``5},Nordril.Functional.Lens.IMonoLens{``1,``6},Nordril.Functional.Lens.IMonoLens{``2,``7},Nordril.Functional.Lens.IMonoLens{``3,``8},Nordril.Functional.Lens.IMonoLens{``4,``9})">
            <summary>
            Combines 5 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TA3">The type of the third input.</typeparam>
            <typeparam name="TA4">The type of the fourth input.</typeparam>
            <typeparam name="TA5">The type of the fifth input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <typeparam name="TB3">The type of the third output.</typeparam>
            <typeparam name="TB4">The type of the fourth output.</typeparam>
            <typeparam name="TB5">The type of the fifth output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
            <param name="l3">The third lens.</param>
            <param name="l4">The fourth lens.</param>
            <param name="l5">The fifth lens.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``12(Nordril.Functional.Lens.IMonoLens{``0,``6},Nordril.Functional.Lens.IMonoLens{``1,``7},Nordril.Functional.Lens.IMonoLens{``2,``8},Nordril.Functional.Lens.IMonoLens{``3,``9},Nordril.Functional.Lens.IMonoLens{``4,``10},Nordril.Functional.Lens.IMonoLens{``5,``11})">
            <summary>
            Combines 6 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TA3">The type of the third input.</typeparam>
            <typeparam name="TA4">The type of the fourth input.</typeparam>
            <typeparam name="TA5">The type of the fifth input.</typeparam>
            <typeparam name="TA6">The type of the sixth input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <typeparam name="TB3">The type of the third output.</typeparam>
            <typeparam name="TB4">The type of the fourth output.</typeparam>
            <typeparam name="TB5">The type of the fifth output.</typeparam>
            <typeparam name="TB6">The type of the sixth output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
            <param name="l3">The third lens.</param>
            <param name="l4">The fourth lens.</param>
            <param name="l5">The fifth lens.</param>
            <param name="l6">The sixth lens.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``14(Nordril.Functional.Lens.IMonoLens{``0,``7},Nordril.Functional.Lens.IMonoLens{``1,``8},Nordril.Functional.Lens.IMonoLens{``2,``9},Nordril.Functional.Lens.IMonoLens{``3,``10},Nordril.Functional.Lens.IMonoLens{``4,``11},Nordril.Functional.Lens.IMonoLens{``5,``12},Nordril.Functional.Lens.IMonoLens{``6,``13})">
            <summary>
            Combines 7 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TA3">The type of the third input.</typeparam>
            <typeparam name="TA4">The type of the fourth input.</typeparam>
            <typeparam name="TA5">The type of the fifth input.</typeparam>
            <typeparam name="TA6">The type of the sixth input.</typeparam>
            <typeparam name="TA7">The type of the seventh input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <typeparam name="TB3">The type of the third output.</typeparam>
            <typeparam name="TB4">The type of the fourth output.</typeparam>
            <typeparam name="TB5">The type of the fifth output.</typeparam>
            <typeparam name="TB6">The type of the sixth output.</typeparam>
            <typeparam name="TB7">The type of the seventh output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
            <param name="l3">The third lens.</param>
            <param name="l4">The fourth lens.</param>
            <param name="l5">The fifth lens.</param>
            <param name="l6">The sixth lens.</param>
            <param name="l7">The seventh lens.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Do.Zip``16(Nordril.Functional.Lens.IMonoLens{``0,``8},Nordril.Functional.Lens.IMonoLens{``1,``9},Nordril.Functional.Lens.IMonoLens{``2,``10},Nordril.Functional.Lens.IMonoLens{``3,``11},Nordril.Functional.Lens.IMonoLens{``4,``12},Nordril.Functional.Lens.IMonoLens{``5,``13},Nordril.Functional.Lens.IMonoLens{``6,``14},Nordril.Functional.Lens.IMonoLens{``7,``15})">
            <summary>
            Combines 8 lenses and into one tuple-lens.
            </summary>
            <typeparam name="TA1">The type of the first input.</typeparam>
            <typeparam name="TA2">The type of the second input.</typeparam>
            <typeparam name="TA3">The type of the third input.</typeparam>
            <typeparam name="TA4">The type of the fourth input.</typeparam>
            <typeparam name="TA5">The type of the fifth input.</typeparam>
            <typeparam name="TA6">The type of the sixth input.</typeparam>
            <typeparam name="TA7">The type of the seventh input.</typeparam>
            <typeparam name="TARest">The type of the rest of the input.</typeparam>
            <typeparam name="TB1">The type of the first output.</typeparam>
            <typeparam name="TB2">The type of the second output.</typeparam>
            <typeparam name="TB3">The type of the third output.</typeparam>
            <typeparam name="TB4">The type of the fourth output.</typeparam>
            <typeparam name="TB5">The type of the fifth output.</typeparam>
            <typeparam name="TB6">The type of the sixth output.</typeparam>
            <typeparam name="TB7">The type of the seventh output.</typeparam>
            <typeparam name="TBRest">The type of the rest of the output.</typeparam>
            <param name="l1">The first lens.</param>
            <param name="l2">The second lens.</param>
            <param name="l3">The third lens.</param>
            <param name="l4">The fourth lens.</param>
            <param name="l5">The fifth lens.</param>
            <param name="l6">The sixth lens.</param>
            <param name="l7">The seventh lens.</param>
            <param name="lRest">The lens for thr rest.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``3(Nordril.Functional.Lens.IGetter{``0,``1},Nordril.Functional.Lens.IGetter{``1,``2})">
            <summary>
            Composes two getters. The second getter drills further into the result of the first.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="A">The type of the outer result/inner container.</typeparam>
            <typeparam name="AInner">The type of the inner result.</typeparam>
            <param name="lens">The outer getter.</param>
            <param name="then">The inner getter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``6(Nordril.Functional.Lens.ISetter{``0,``1,``2,``3},Nordril.Functional.Lens.ISetter{``2,``3,``4,``5})">
            <summary>
            Composes two setters. The second setter drills further into the result of the first.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="T">The type of the resulting outer container.</typeparam>
            <typeparam name="A">The type of the outer value.</typeparam>
            <typeparam name="AInner">The type of the inner outer value/inner container.</typeparam>
            <typeparam name="B">The type outer result value.</typeparam>
            <typeparam name="BInner">The type of the inner result value.</typeparam>
            <param name="lens">The outer setter.</param>
            <param name="then">The inner setter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``3(Nordril.Functional.Lens.IMonoLens{``0,``1},Nordril.Functional.Lens.IMonoLens{``1,``2})">
            <summary>
            Composes two lenses. The second lens drills further into the result of the first.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="AOuter">The type of the outer result/inner container.</typeparam>
            <typeparam name="AInner">The type of the inner result.</typeparam>
            <param name="lens">The outer getter.</param>
            <param name="then">The inner getter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``6(Nordril.Functional.Lens.IPrism{``0,``1,``2,``3},Nordril.Functional.Lens.IPrism{``2,``3,``4,``5})">
            <summary>
            Composes two prisms. The second prism drills further into the result of the first, if it exists.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="T">The type of the resulting outer container.</typeparam>
            <typeparam name="A">The type of the outer value.</typeparam>
            <typeparam name="AInner">The type of the inner outer value/inner container.</typeparam>
            <typeparam name="B">The type outer result value.</typeparam>
            <typeparam name="BInner">The type of the inner result value.</typeparam>
            <param name="lens">The outer setter.</param>
            <param name="then">The inner setter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``3(Nordril.Functional.Lens.IFold{``0,``1},Nordril.Functional.Lens.IFold{``1,``2})">
            <summary>
            Composes two folds. The second folds drills further into the result of the first.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="AOuter">The type of the outer value.</typeparam>
            <typeparam name="AInner">The type of the inner outer value/inner container.</typeparam>
            <param name="lens">The outer setter.</param>
            <param name="then">The inner setter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``6(Nordril.Functional.Lens.ITraversal{``0,``1,``2,``3},Nordril.Functional.Lens.ITraversal{``2,``3,``4,``5})">
            <summary>
            Composes two traversals. The second traversal drills further into the result of the first.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="T">The type of the resulting outer container.</typeparam>
            <typeparam name="A">The type of the outer value.</typeparam>
            <typeparam name="AInner">The type of the inner outer value/inner container.</typeparam>
            <typeparam name="B">The type outer result value.</typeparam>
            <typeparam name="BInner">The type of the inner result value.</typeparam>
            <param name="lens">The outer setter.</param>
            <param name="then">The inner setter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Then``6(Nordril.Functional.Lens.IWithering{``0,``1,``2,``3},Nordril.Functional.Lens.IWithering{``2,``3,``4,``5})">
            <summary>
            Composes two witherings. The second withering drills further into the result of the first.
            </summary>
            <typeparam name="S">The type of the outer container.</typeparam>
            <typeparam name="T">The type of the resulting outer container.</typeparam>
            <typeparam name="A">The type of the outer value.</typeparam>
            <typeparam name="AInner">The type of the inner outer value/inner container.</typeparam>
            <typeparam name="B">The type outer result value.</typeparam>
            <typeparam name="BInner">The type of the inner result value.</typeparam>
            <param name="lens">The outer setter.</param>
            <param name="then">The inner setter.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Set``4(Nordril.Functional.Lens.ISetter{``0,``1,``2,``3},``0,``3)">
            <summary>
            Runs a setter on an input and returns the modified input.
            Also known as <em>set</em>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Update``4(Nordril.Functional.Lens.ISetter{``0,``1,``2,``3},``0,System.Func{``2,``3})">
            <summary>
            Runs a setter with an update-function on an input, returns the modified input.
            Also known as <em>over</em>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Get``2(Nordril.Functional.Lens.IGetter{``0,``1},``0)">
            <summary>
            Runs a getter on an input and returns the result.
            Also known as <em>view</em>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.L.TryGet``2(Nordril.Functional.Lens.IPrism{``0,``0,``1,``1},``0)">
            <summary>
            Tries to get the result of a prism from an input.
            Also known an <em>preview</em>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="A">The type of the part to get.</typeparam>
            <param name="lens">The lens to run.</param>
            <param name="input">The input.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Review``2(Nordril.Functional.Lens.IPrism{``1,``1,``0,``0},``0)">
            <summary>
            The opposite of <see cref="M:Nordril.Functional.Lens.L.TryGet``2(Nordril.Functional.Lens.IPrism{``0,``0,``1,``1},``0)"/> (if it succeeds); this function composes a part <typeparamref name="B"/> into a whole <typeparamref name="T"/>. With this function, one can use a <see cref="T:Nordril.Functional.Lens.IPrism`4"/> as a constructor for, say, <see cref="T:Nordril.Functional.Data.Either`2"/>. In fact:
            <code>
            if (Lens.TryGet(L, T).HasValue) then Lens.Review(L, Lens.TryGet(L, T).Value()) == T
            </code>
            </summary>
            <typeparam name="B">The type of the value to pipe backwards.</typeparam>
            <typeparam name="T">The type of the resulting object, from which the prism normally tries to extract <typeparamref name="B"/> via <see cref="M:Nordril.Functional.Lens.L.TryGet``2(Nordril.Functional.Lens.IPrism{``0,``0,``1,``1},``0)"/>.</typeparam>
            <param name="lens">The prism.</param>
            <param name="input">The object which should be assembled into <typeparamref name="T"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Traverse``5(Nordril.Functional.Lens.ITraversal{``1,``2,``3,``4},System.Func{``3,``0},``1)">
            <summary>
            Runs an <see cref="T:Nordril.Functional.Lens.ITraversal`4"/> on <paramref name="input"/>.
            </summary>
            <typeparam name="TApplicative">The type of the applicative result of the inner function.</typeparam>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="T">The type of the resultant structure.</typeparam>
            <typeparam name="A">The type of the part to get.</typeparam>
            <typeparam name="B">The type of the result of the inner function.</typeparam>
            <param name="lens">The traversal to run.</param>
            <param name="f">The function to apply to each element.</param>
            <param name="input">The input.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Traverse``4(Nordril.Functional.Lens.ITraversal{``0,``1,``2,``3},System.Type,System.Func{``2,Nordril.Functional.Category.IApplicative{``3}},``0)">
            <summary>
            Runs an <see cref="T:Nordril.Functional.Lens.ITraversal`4"/> on <paramref name="input"/>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="T">The type of the resultant structure.</typeparam>
            <typeparam name="A">The type of the part to get.</typeparam>
            <typeparam name="B">The type of the result of the inner function.</typeparam>
            <param name="applicative">The type of the applicative result of the inner function.</param>
            <param name="lens">The traversal to run.</param>
            <param name="f">The function to apply to each element.</param>
            <param name="input">The input.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.TraverseMaybe``5(Nordril.Functional.Lens.IWithering{``1,``2,``3,``4},System.Func{``3,Nordril.Functional.Category.IAlternative{``4}},``1)">
            <summary>
            Runs an <see cref="T:Nordril.Functional.Lens.IWithering`4"/> on <paramref name="input"/>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="T">The type of the resultant structure.</typeparam>
            <typeparam name="A">The type of the part to get.</typeparam>
            <typeparam name="B">The type of the result of the inner function.</typeparam>
            <typeparam name="TAlternative">The type of the alternative result of the inner function.</typeparam>
            <param name="lens">The traversal to run.</param>
            <param name="f">The function to apply to each element.</param>
            <param name="input">The input.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.TraverseMaybe``4(Nordril.Functional.Lens.IWithering{``0,``1,``2,``3},System.Type,System.Func{``2,Nordril.Functional.Category.IAlternative{``3}},``0)">
            <summary>
            Runs an <see cref="T:Nordril.Functional.Lens.IWithering`4"/> on <paramref name="input"/>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="T">The type of the resultant structure.</typeparam>
            <typeparam name="A">The type of the part to get.</typeparam>
            <typeparam name="B">The type of the result of the inner function.</typeparam>
            <param name="alternative">The type of the alternative result of the inner function.</param>
            <param name="lens">The traversal to run.</param>
            <param name="f">The function to apply to each element.</param>
            <param name="input">The input.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.ToList``2(Nordril.Functional.Lens.IFold{``0,``1},``0)">
            <summary>
            Turns the element(s) retrieved by an <see cref="T:Nordril.Functional.Lens.IGetter`2"/> into a list.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="A">The type of the part to get.</typeparam>
            <param name="lens">The getter.</param>
            <param name="input">The input structure.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Fold``3(Nordril.Functional.Lens.IFold{``0,``1},System.Func{``1,``2,``2},``2,``0)">
            <summary>
            Folds the elements of a container using <paramref name="f"/> as the combining-function and <paramref name="acc"/> as the initial accumulator.
            Also known as <em>foldrOf</em>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="A">The type of the elements.</typeparam>
            <typeparam name="TResult">The type of the monoidal result.</typeparam>
            <param name="lens">The fold to run.</param>
            <param name="f">The function to combine two elements.</param>
            <param name="acc">The initial accumulator value.</param>
            <param name="input">The input structure.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Fold``3(Nordril.Functional.Lens.IFold{``0,``1},System.Func{``1,``2},``0)">
            <summary>
            Maps the elements in a container <typeparamref name="S"/> to an <see cref="T:Nordril.Functional.Algebra.IHasMonoid`1"/> and uses the monoid-logic to combine the results.
            Also known as <em>foldMapOf</em>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="A">The type of the elements.</typeparam>
            <typeparam name="TResult">The type of the monoidal result.</typeparam>
            <param name="lens">The fold to run.</param>
            <param name="f">The function to map each element to a monoid.</param>
            <param name="input">The input structure.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.L.Fold``4(Nordril.Functional.Lens.IFold{``0,``1},System.Func{``1,``2},``0)">
            <summary>
            Maps the elements in a container <typeparamref name="S"/> to an value which has an associated monoid <typeparamref name="TMonoid"/> and uses the monoid-logic to combine the results.
            Also known as <em>foldMapOf</em>.
            </summary>
            <typeparam name="S">The type of the input structure.</typeparam>
            <typeparam name="A">The type of the elements.</typeparam>
            <typeparam name="TResult">The type of the monoidal result.</typeparam>
            <typeparam name="TMonoid">The type of the monoid.</typeparam>
            <param name="lens">The fold to run.</param>
            <param name="f">The function to map each element to a monoid.</param>
            <param name="input">The input structure.</param>
        </member>
        <member name="T:Nordril.Functional.Lens.MonoLens`2">
            <summary>
            A lens, which is a combined <see cref="T:Nordril.Functional.Lens.IGetter`2"/> and <see cref="T:Nordril.Functional.Lens.ISetter`4"/>.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="A">The type of the object to get/modify in <typeparamref name="S"/>.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Lens.MonoLens`2.SetFunc">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Lens.MonoLens`2.Func">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.MonoLens`2.#ctor(System.Func{System.Type,System.Func{System.Func{`1,Nordril.Functional.Category.IFunctor{`1}},System.Func{`0,Nordril.Functional.Category.IFunctor{`0}}}})">
            <summary>
            Creates a new lens.
            </summary>
            <param name="f">The lens-function. This uses the functor returned by its first input-function, though the compiler can't check this.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.MonoLens`2.LensFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.MonoLens`2.LensFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.MonoPrism`2">
            <summary>
            A prism, which is a setter that "may work" depending on its input.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.MonoPrism`2.#ctor(System.Func{System.Type,System.Func{Nordril.Functional.Category.IChoice{`1,Nordril.Functional.Category.IApplicative{`1}},Nordril.Functional.Category.IChoice{`0,Nordril.Functional.Category.IApplicative{`0}}}})">
            <summary>
            Creates a new prism.
            </summary>
            <param name="f">The prism-function. This uses the applicative returned by its first input-function, though the compiler can't check this.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.MonoPrism`2.PrismFunc``4">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.MonoPrism`2.PrismFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.Prism`4">
            <summary>
            A prism, which is a setter that "may work" depending on its input.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Lens.Prism`4.#ctor(System.Func{System.Type,System.Func{Nordril.Functional.Category.IChoice{`2,Nordril.Functional.Category.IApplicative{`3}},Nordril.Functional.Category.IChoice{`0,Nordril.Functional.Category.IApplicative{`1}}}})">
            <summary>
            Creates a new prism.
            </summary>
            <param name="f">The prism-function. This uses the applicative returned by its first input-function, though the compiler can't check this.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.Prism`4.PrismFunc``4">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Prism`4.PrismFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Prism`4.TraversalFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Prism`4.TraversalFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.Setter`4">
            <summary>
            A setter which applies a function to some part of its input.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Lens.Setter`4.SetFunc">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.Traversal`4">
            <summary>
            A setter which can read/update multiple fields.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Lens.Traversal`4.SetFunc">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Traversal`4.#ctor(System.Func{System.Type,System.Func{System.Func{`2,Nordril.Functional.Category.IApplicative{`3}},System.Func{`0,Nordril.Functional.Category.IApplicative{`1}}}})">
            <summary>
            Creates a traversal.
            </summary>
            <param name="f">The traversal-function. This uses the applicative returned by its first input-function, though the compiler can't check this.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.Traversal`4.TraversalFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Traversal`4.TraversalFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Lens.Withering`4">
            <summary>
            A setter which can read/update multiple fields.
            </summary>
            <typeparam name="S">The type of the input data structure.</typeparam>
            <typeparam name="T">The type of the output data structure.</typeparam>
            <typeparam name="A">The type of the input-object in <typeparamref name="S"/>.</typeparam>
            <typeparam name="B">The type of the result-object in <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Lens.Withering`4.#ctor(System.Func{System.Type,System.Func{System.Func{`2,Nordril.Functional.Category.IAlternative{`3}},System.Func{`0,Nordril.Functional.Category.IAlternative{`1}}}})">
            <summary>
            Creates a traversal.
            </summary>
            <param name="f">The traversal-function. This uses the applicative returned by its first input-function, though the compiler can't check this.</param>
        </member>
        <member name="M:Nordril.Functional.Lens.Withering`4.WitherFunc``2">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Lens.Withering`4.WitherFunc(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Mapping.IIsomorphism`2">
            <summary>
            A type which can convert objects of type <typeparamref name="TFrom"/> to objects of type <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Mapping.IsomorphismExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Mapping.IIsomorphism`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Mapping.IsomorphismExtensions.ConvertBack``2(Nordril.Functional.Mapping.IIsomorphismWith{Nordril.Functional.Data.Unit,``0,``1},``1)">
            <summary>
            Converts an object back from <typeparamref name="TTo"/> to <typeparamref name="TFrom"/>.
            </summary>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
            <param name="iso">The isomorphism.</param>
            <param name="from">The object to convert.</param>
        </member>
        <member name="T:Nordril.Functional.Mapping.IIsomorphismWith`3">
            <summary>
            A type which can convert objects of type <typeparamref name="TFrom"/> to objects of type <typeparamref name="TTo"/>, with the help of an environment-variable <typeparamref name="TEnv"/>.
            </summary>
            <typeparam name="TEnv">The environment.</typeparam>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Mapping.IIsomorphismWith`3.ConvertBackWith(`0,`2)">
            <summary>
            Converts an object back from <typeparamref name="TTo"/> to <typeparamref name="TFrom"/>.
            The following holds for all <c>x</c>:
            <code>
                ConvertBack(env, Convert(env, x)) == x
            </code>
            </summary>
            <param name="env">The environment.</param>
            <param name="from">The object to convert.</param>
        </member>
        <member name="T:Nordril.Functional.Mapping.IMorphism`2">
            <summary>
            A type which can convert objects of type <typeparamref name="TFrom"/> to objects of type <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Mapping.IMorphismExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Mapping.IMorphism`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Mapping.IMorphismExtensions.Convert``2(Nordril.Functional.Mapping.IIsomorphismWith{Nordril.Functional.Data.Unit,``0,``1},``0)">
            <summary>
            Converts an object from <typeparamref name="TFrom"/> to <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
            <param name="iso">The isomorphism.</param>
            <param name="from">The object to convert.</param>
        </member>
        <member name="T:Nordril.Functional.Mapping.IMorphismWith`3">
            <summary>
            type which can convert objects of type <typeparamref name="TFrom"/> to objects of type <typeparamref name="TTo"/>., with the help of an environment-variable <typeparamref name="TEnv"/>.
            </summary>
            <typeparam name="TEnv">The environment.</typeparam>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Mapping.IMorphismWith`3.ConvertWith(`0,`1)">
            <summary>
            Converts an object.
            </summary>
            <param name="env">The environment.</param>
            <param name="from">The object to convert.</param>
        </member>
        <member name="T:Nordril.Functional.ObjectExtensions">
            <summary>
            Extension methods for <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.DefaultHash(System.Object,System.Object[])">
            <summary>
            A default hashing function which hashes all given fields, plus the full name of the object's type.
            <see cref="T:System.String"/>-fields are hashed with the option <see cref="F:System.StringComparison.InvariantCulture"/>.
            This hashing function is well-suited to hashing according to structural equality in complex objects like trees and dictionaries.
            </summary>
            <param name="obj">The object for which to get the hash.</param>
            <param name="fields">The fields of the object.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.DefaultHash``1(System.Object,System.Object[])">
            <summary>
            A default hashing function which hashes all given fields, plus the full name of the object's type.
            <see cref="T:System.String"/>-fields are hashed with the option <see cref="F:System.StringComparison.InvariantCulture"/>.
            This hashing function is well-suited to hashing according to structural equality in complex objects like trees and dictionaries.
            </summary>
            <typeparam name="T">The type to incorporate into the hash.</typeparam>
            <param name="obj">The object for which to get the hash.</param>
            <param name="fields">The fields of the object.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.GetBaseName(System.Type)">
            <summary>
            Gets the type's base name, i.e. its name without any generic parameters.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.GetBaseFullName(System.Type)">
            <summary>
            Gets the type's base full name, i.e. its full name (namespace-qualified) name without any generic parameters.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.GetGenericName(System.Type,System.Boolean)">
            <summary>
            Gets the type's generic name, which is equal to its base name for non-generic types,
            and equal to the angle-bracket-syntax in C#.
            </summary>
            <param name="type">The type.</param>
            <param name="useFullName">If true, the type's full (namespace-qualified) name will be used, otherwise the type's name.</param>
        </member>
        <member name="T:Nordril.Functional.Pattern">
            <summary>
            A constructor for a first-class pattern.
            </summary>
            <remarks>
            Using a <see cref="T:Nordril.Functional.Pattern"/> consists of two stages:
            <list type="number">
                <item>Constructing a list of cases which are checked in-order, and</item>
                <item>running the pattern against an input object.</item>
            </list>
            Constructing a case-list is a safe operation in that none of the cases are evaluated, though be advised that the <see cref="T:Nordril.Functional.Pattern`2"/>-object is not thread-safe and <see cref="M:Nordril.Functional.ICopyable`1.Copy"/> should be used prior to sharing it across threads. Each case consists of a predicate which has to evaluate to true if the case is to apply, and an action which is run on the input object if the case applies.
            <br />
            Cases can be added via a fluent-API, all at once or at different times. <see cref="T:Nordril.Functional.Pattern`2"/>s, being first-class objects, can be passed in as arguments or be returned by functions.
            <br />
            The second stage is the exection: via <see cref="M:Nordril.Functional.Pattern`2.Run(`0)"/>, and input-object is passed in and the previously registered cases are evaluated in order of their addition. The first case which evaluates to true is applied and result of its action returned; if no cases applies, the default pattern is applied, which can be set via <see cref="M:Nordril.Functional.Pattern`2.WithDefault(System.Func{`0,`1})"/>. If no default pattern was set and no case applies, a <see cref="T:Nordril.Functional.PatternMatchException"/> is thrown.
            <br />
            It is considered good form to always specify a default pattern unless one is absolutely sure that the disjunction of the registered cases all possible values of the input object.
            </remarks>
            <example>
            Below we create a sign-pattern which returns 1 for postive numbers, -1 for negative ones, and 0 for 0. The <see cref="T:System.Int32"/> type annotation in the first case disambiguates the type of the input object.
            <code>
            var pat = Pattern
               .Match((int x) => x &gt; 0, _ =&gt; 1)
               .Match(x => x &lt; 0, =&gt; -1)
               .WithDefault(_ =&gt; 0);
               
            var sign = pat.Run(5); //1
            sign = pat.Run(-4); //-1
            sign = pat.Run(0); //0
            </code>
            We can also create recursive patterns. Below we have an implementation of the Collatz "algorithm" which does the following:
            <list type="number">
                <item>If a number is even, divide it by two and repeat, or</item>
                <item>if a number is odd, multiply by three and add 1, and repeat.</item>
            </list>
            The local function <c>go</c> is used to create the recursion. We first declare it to have the name available in the <c>collatz</c>-<see cref="T:Nordril.Functional.Pattern`2"/>, then we tie the know by running the pattern in <c>go</c>. Note that we insert the terminating pattern (<c>&lt;=1</c>) as the first, to avoid infinite recursion.
            <br />
            Per the Collatz-conjecture, every number eventually reaches one.
            <code>
            public int Collatz(int num)
            {
               //Create the referancable name "go".
               Func&lt;int, int&gt; go(int x) = null;
               
               //Create the pattern (only once).
               var collatz = Pattern
                  .Match((int x) => x &lt; 1, x => 1)
                  .Match(x => x % 2 == 0, x => go(x/2))
                  .WithDefault(x => go(x*3 + 1));
                  
               //Tie the know but instantiating "go" with running the pattern.
               go = x => collatz.Run(x);
               
               //Run the pattern. We either return 1 or we don't terminate.
               return go(num);
            }
            </code>
            One can also carry state in patterns through the input-object. For instance, we can calculate the factorial tail-recursively thus:
            <code>
            var n = 15;
            var fac = Pattern
               .Match(((int n, long sum) x) =&gt; x.n &lt;= 1, x =&gt; x.sum)
               .MatchTailRec(x =&gt; x.n &gt; 1, x =&gt; (x.n-1, (x.n* x.sum)))
               .Run((n, 1));
            </code>
            Here, we pass a tuple consisting of the current number (n) and the sum so far (sum) into the pattern-match, and in the second case, we decrement n while multiplying the previous sum with n. We get the final number instead of the tuple because the terminating, first case discards the tuple and just returns the sum.
            </example>
        </member>
        <member name="M:Nordril.Functional.Pattern.Match``2(System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Creates a pattern-match on an input object <typeparamref name="TIn"/>, starting with a single case.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchMany``2(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Func{``0,System.Boolean},System.Func{``0,``1}}})">
            <summary>
            Creates a pattern-match on an input object <typeparamref name="TIn"/>, starting with a list of cases.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="cases">The list of cases, consisting of predicates and functions to be applied to the input if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``2(Nordril.Functional.Pattern{``0,Nordril.Functional.Data.FuncList{``1}},System.Func{``0,System.Boolean},System.Func{``0,``1},System.Func{``0,``0})">
            <summary>
            Appends a new, tail-recursive case modulo cons to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned. <em>This function has poor performance for large lists.</em>
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="p">The pattern to which to append.</param>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="head">The function which is applied to each element created by this pattern.</param>
            <param name="tail">The function which iterates through the output.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``3(Nordril.Functional.Pattern{Nordril.Functional.Data.Lst{``0},``2},System.Func{Nordril.Functional.Data.Lst{``0},System.Boolean},System.Func{``0,``1},System.Func{Nordril.Functional.Data.Lst{``0},Nordril.Functional.Data.Lst{``0}},System.Func{``1,``2},System.Func{``1,``2,``2},System.Func{``2,``2,``2})">
            <summary>
            Appends a new, tail-recursive case modulo cons to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned. If iterating through a list elementwise, this function performs much faster than getting the tail of a list via <see cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)"/>, since it doesn't create shallow copies of the whole list each iteration. If you want to build consume <em>and</em> build up a list during the iteration, use <see cref="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``2(Nordril.Functional.Pattern{Nordril.Functional.Data.Lst{``0},System.Collections.Generic.Queue{``1}},System.Func{``0,``1})"/> or <see cref="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``2(Nordril.Functional.Pattern{Nordril.Functional.Data.Lst{``0},System.Collections.Generic.Queue{``1}},System.Func{Nordril.Functional.Data.Lst{``0},System.Boolean},System.Func{``0,``1})"/>.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <typeparam name="TOutSemi">The type of the result of the <paramref name="head"/>-function.</typeparam>
            <param name="p">The pattern to which to append.</param>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="head">The function which is applied to each element created by this pattern.</param>
            <param name="tail">The function which should be applied to the tail of the output.</param>
            <param name="addResult">The function to append a single result to the previously generated ones.</param>
            <param name="mkResult">The function to create a single result.</param>
            <param name="combineResults">The function to append new results to the previously generated ones.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``2(Nordril.Functional.Pattern{Nordril.Functional.Data.Lst{``0},System.Collections.Generic.Queue{``1}},System.Func{Nordril.Functional.Data.Lst{``0},System.Boolean},System.Func{``0,``1})">
            <summary>
            Appends a new, tail-recursive case modulo cons to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned. If iterating through a list elementwise, this function performs much faster than getting the tail of a list via <see cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)"/>, since it doesn't create shallow copies of the whole list each iteration.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="p">The pattern to which to append.</param>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="head">The function which is applied to each element created by this pattern.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``2(Nordril.Functional.Pattern{Nordril.Functional.Data.Lst{``0},System.Collections.Generic.Queue{``1}},System.Func{``0,``1})">
            <summary>
            Appends a new, tail-recursive case modulo cons to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned. The case has the predicate <c>xs.Count &gt; 0</c>. If iterating through a list elementwise, this function performs much faster than getting the tail of a list via <see cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)"/>, since it doesn't create shallow copies of the whole list each iteration.
            A case like this generally means that the overall pattern is a generalization of <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="p">The pattern to which to append.</param>
            <param name="head">The function which is applied to each element created by this pattern.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchTailRecModuloCons``3(Nordril.Functional.Pattern{``0,``2},System.Func{``0,System.Boolean},System.Func{``0,``1},System.Func{``0,``0},System.Func{``1,``2},System.Func{``1,``2,``2},System.Func{``2,``2,``2})">
            <summary>
            Appends a new, tail-recursive case modulo cons to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            The returned structure <typeparamref name="TOutSemi"/> must form a semigroup under <paramref name="combineResults"/>.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <typeparam name="TOutSemi">The type of the result of the <paramref name="head"/>-function.</typeparam>
            <param name="p">The pattern to which to append.</param>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="head">The function which is applied to each element created by this pattern.</param>
            <param name="tail">The function which iterates through the output.</param>
            <param name="addResult">The function to append a single result to the previously generated ones.</param>
            <param name="mkResult">The function to create a single result.</param>
            <param name="combineResults">The function to append new results to the previously generated ones.</param>
        </member>
        <member name="T:Nordril.Functional.Pattern`2">
            <summary>
            A list of cases which is checked top-down when the pattern is run.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.#ctor(System.Collections.Generic.IEnumerable{System.Func{`0,System.Boolean}},System.Collections.Generic.IEnumerable{System.Func{`0,`1}},System.Collections.Generic.IEnumerable{System.Func{`0,`0}},System.Func{`0,`1})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Pattern`2"/> out of a list of predicates an actions. The caller must ensure that both lists have the same number of elements.
            </summary>
            <param name="predicates">The list of predicates for the cases.</param>
            <param name="actions">The list of actions for the cases.</param>
            <param name="tailRecActions">The list of tail-recursive actions. This list must have the same number of entries as <paramref name="actions"/>, but with the values at the indexes of the non-tail-recursive actions being null.</param>
            <param name="defaultPattern">The default pattern. If null is passed, the default pattern which throws a <see cref="T:System.NullReferenceException"/> will be used.</param>
            <exception cref="T:System.ArgumentException">If the lengths of <paramref name="predicates"/>, <paramref name="actions"/>, and <paramref name="tailRecActions"/> do not agree.</exception>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.StartMatch(System.Func{`0,System.Boolean},System.Func{`0,`1})">
            <summary>
            Creates a <see cref="T:Nordril.Functional.Pattern`2"/> out of a single case.
            </summary>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.StartMatch(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Func{`0,System.Boolean},System.Func{`0,`1}}})">
            <summary>
            Creates a <see cref="T:Nordril.Functional.Pattern`2"/> out of a sequence of cases.
            </summary>
            <param name="cases">The list of cases, consisting of predicates and functions to be applied to the input if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Match(System.Func{`0,System.Boolean},System.Func{`0,`1})">
            <summary>
            Appends a new case to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            </summary>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Match(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Func{`0,System.Boolean},System.Func{`0,`1}}})">
            <summary>
            Appends a list of new cases to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            </summary>
            <param name="cases">The list of cases, consisting of predicates and functions to be applied to the input if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.MatchTailRec(System.Func{`0,System.Boolean},System.Func{`0,`0})">
            <summary>
            Appends a new, tail-recursive case to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            Note that a tail-recursive case <em>cannot</em> be a terminating case and if the input-object always matches a tail-recursive case, <see cref="M:Nordril.Functional.Pattern`2.Run(`0)"/> will not terminate.
            <br />
            Instead of <paramref name="action"/> returning an output, it returns an <typeparamref name="TIn"/>-object with which the pattern-match will be called tail-recursively. This means that no new stack-frame will be allocated for the recursive call. Think of this like running a pattern-match in a loop. For general recursion (which runs the risk of stack overflows), see the examples in <see cref="T:Nordril.Functional.Pattern`2"/>.
            </summary>
            <remarks>
            If tail-recursion is all you need, using <see cref="M:Nordril.Functional.Pattern`2.MatchTailRec(System.Func{`0,System.Boolean},System.Func{`0,`0})"/> is actually superior to a native <c>switch</c>-expression with a recursive call in it (w.r.t. the consumption of stack-memory) because the C# runtime does not support tail-recursion. Of course, any tail-recursive <c>switch</c>-expression can be easily transformed into one which does not run into a stack overflow (becsause of the recursion alone) by floating out the recursion into a loop around the the <c>switch</c>.</remarks>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.MatchTailRec``1(Nordril.Functional.Pattern{`0,``0},System.Func{`0,System.Boolean},System.Func{`1,``0},System.Func{`1,``0,``0},System.Func{``0,``0,``0},System.Func{`0,`1},System.Func{`0,`0})">
            <summary>
            Appends a new, tail-recursive case modulo cons to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            The returned structure <typeparamref name="TOutSemi"/> must form a semigroup under <paramref name="combineResults"/>.
            </summary>
            <typeparam name="TOutSemi">The type of the result of the <paramref name="head"/>-function.</typeparam>
            <param name="pattern">The pattern to which to append.</param>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="head">The function which is applied to each element created by this pattern.</param>
            <param name="tail">The function which iterates through the output.</param>
            <param name="addResult">The function to append a single result to the previously generated ones.</param>
            <param name="mkResult">The function to create a single result.</param>
            <param name="combineResults">The function to append new results to the previously generated ones.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.WithDefault(System.Func{`0,`1})">
            <summary>
            Sets the default pattern which always applies after all other cases. This call overwrites any previously set default pattern, except if null is passed in <paramref name="defaultPattern"/>, in which case nothing is done.
            </summary>
            <param name="defaultPattern"></param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Run(`0)">
            <summary>
            Runs a pattern against an input object <paramref name="arg"/> and returns the result of the first case that applies, or the result of the default pattern is none applies.
            </summary>
            <param name="arg">The input object.</param>
            <returns>The result of the first case which applies to the input object, with that case's action run against the input object.</returns>
            <exception cref="T:Nordril.Functional.PatternMatchException">If no case applies and no alternative default pattern was set via <see cref="M:Nordril.Functional.Pattern`2.WithDefault(System.Func{`0,`1})"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Copy">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.PatternMatchException">
            <summary>
            The object didn't correspond to the asked-for pattern. An example would be <see cref="T:Nordril.Functional.Data.Maybe`1"/> whose value
            was requested but which contained nothing.
            </summary>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/> with a standard message.
            </summary>
            <param name="requested">The requested member.</param>
            <param name="className">The name of the class.</param>
            <param name="actualPattern">The pattern that was actually present. This should be the name of a member whose call would've succeeded.</param>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/> with a custom message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/> with a custom message an an inner exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Nordril.Functional.Results.Error">
            <summary>
            Represents an error in the application, with a message and a target, plus an optional system-exception.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Results.Error.Code">
            <summary>
            The unique code of the error.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Results.Error.InnerException">
            <summary>
            The underlying system exception, if applicable.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Results.Error.Message">
            <summary>
            The human-readable error message.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Results.Error.Target">
            <summary>
            The target of the error; i.e. the thing that was faulty (like a property or the name of an API method).
            </summary>
        </member>
        <member name="M:Nordril.Functional.Results.Error.#ctor(System.String,System.Enum,System.String,System.Exception)">
            <summary>
            Creates a new error out of a message and an optional code, target and exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="code">The unique error code; null if not present.</param>
            <param name="target">The target; null if not present.</param>
            <param name="exception">The exception; null if not present.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Error.#ctor(System.String,System.Int32,System.String,System.Exception)">
            <summary>
            Creates a new error out of a message and an optional code, target and exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="code">The unique error code.</param>
            <param name="target">The target; null if not present.</param>
            <param name="exception">The exception; null if not present.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Error.#ctor(System.String,System.String,System.String,System.Exception)">
            <summary>
            Creates a new error out of a message and an optional code, target and exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="code">The unique error code; null if not present.</param>
            <param name="target">The target; null if not present.</param>
            <param name="exception">The exception; null if not present.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Error.#ctor(System.ValueTuple{System.String,System.Enum},System.String,System.Exception)">
            <summary>
            Creates a new error out of a message and an optional code, target and exception.
            </summary>
            <param name="msg">The tuple of error message and code.</param>
            <param name="target">The target; null if not present.</param>
            <param name="exception">The exception; null if not present.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Error.Equals(System.Object)">
            <summary>
            Determines equality based on <see cref="P:Nordril.Functional.Results.Error.Code"/>, <see cref="P:Nordril.Functional.Results.Error.Message"/>, <see cref="P:Nordril.Functional.Results.Error.InnerException"/>, and <see cref="P:Nordril.Functional.Results.Error.Target"/>.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Error.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Error.op_Equality(Nordril.Functional.Results.Error,Nordril.Functional.Results.Error)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Error.op_Inequality(Nordril.Functional.Results.Error,Nordril.Functional.Results.Error)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Error.Equals(Nordril.Functional.Results.Error)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Error.ToString">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Results.Result`1">
            <summary>
            The result of a service call; a container for <see cref="T:Nordril.Functional.Data.Either`2"/>, containing either a list of errors or a result <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the result, if the call was successful.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Results.Result`1.InnerResult">
            <summary>
            The underlying either.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Results.Result`1.ResultClass">
            <summary>
            Gets or sets the general class of result, which allows a rough categorization.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Results.Result`1.IsOk">
            <summary>
            Returns true iff there is a result, i.e. if the underlying <see cref="P:Nordril.Functional.Data.Either`2.IsRight"/> is true.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Value">
            <summary>
            Returns the value of the result, if present. If there's no result, a <see cref="T:Nordril.Functional.PatternMatchException"/> is thrown.
            </summary>
            <exception cref="T:Nordril.Functional.PatternMatchException">If there's no result and only errors.</exception>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.TryGetValue(`0@)">
            <summary>
            Tries to get the value of this <see cref="T:Nordril.Functional.Results.Result`1"/>, if it exists. The result is true iff the <see cref="T:Nordril.Functional.Results.Result`1"/> contains a value.
            </summary>
            <param name="value">The value of the result if present, <c>default</c> otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Errors">
            <summary>
            Returns the errors, if present. If there are no errors, a <see cref="T:Nordril.Functional.PatternMatchException"/> is thrown.
            </summary>
            <exception cref="T:Nordril.Functional.PatternMatchException">If there are no errors.</exception>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.HasError``1(Nordril.Functional.Results.Error@)">
            <summary>
            Returns true if <see cref="P:Nordril.Functional.Results.Result`1.IsOk"/> is false and if <see cref="M:Nordril.Functional.Results.Result`1.Errors"/> contains an error with an inner exception of type <typeparamref name="TError"/>. This is a useful analogue for <c>catch</c>.
            </summary>
            <typeparam name="TError">The type of the exception to search for.</typeparam>
            <param name="error">The first occurrence of an <see cref="T:Nordril.Functional.Results.Error"/> which has an inner exception of type <typeparamref name="TError"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.HasErrorCode``1(``0,Nordril.Functional.Results.Error@)">
            <summary>
            Returns true if <see cref="P:Nordril.Functional.Results.Result`1.IsOk"/> is false and if <see cref="M:Nordril.Functional.Results.Result`1.Errors"/> contains an error with error code <paramref name="code"/>. This is a useful analogue for <c>catch</c>.
            </summary>
            <typeparam name="TCode">The type of the error code enumeration.</typeparam>
            <param name="code">The error code to search for.</param>
            <param name="error">The first occurrence of an <see cref="T:Nordril.Functional.Results.Error"/> which has an error code <paramref name="code"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.HasErrorCode(System.String,Nordril.Functional.Results.Error@)">
            <summary>
            Returns true if <see cref="P:Nordril.Functional.Results.Result`1.IsOk"/> is false and if <see cref="M:Nordril.Functional.Results.Result`1.Errors"/> contains an error with error code <paramref name="code"/>. This is a useful analogue for <c>catch</c>.
            </summary>
            <param name="code">The error code to search for.</param>
            <param name="error">The first occurrence of an <see cref="T:Nordril.Functional.Results.Error"/> which has an error code <paramref name="code"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.#ctor(Nordril.Functional.Data.Either{System.Collections.Generic.IList{Nordril.Functional.Results.Error},`0},Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Results.Result`1"/> from an <see cref="T:Nordril.Functional.Data.Either`2"/>.
            If <paramref name="resultClass"/> is <see cref="F:Nordril.Functional.Results.ResultClass.Ok"/>, <paramref name="innerResult"/> MUST contain a right-value, otherwise, an exception is thrown.
            </summary>
            <param name="innerResult">The underlying data.</param>
            <param name="resultClass">The result class.</param>
            <exception cref="T:System.ArgumentException">If <paramref name="resultClass"/> is <see cref="F:Nordril.Functional.Results.ResultClass.Ok"/>, but <paramref name="innerResult"/> contains no value.</exception>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Ok(`0)">
            <summary>
            Creates an OK-result from a value.
            </summary>
            <param name="result">The value.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.WithErrors(System.Collections.Generic.IEnumerable{Nordril.Functional.Results.Error},Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates an error-result from a list of errors.
            </summary>
            <param name="errors">The list of errors.</param>
            <param name="resultClass">The class of the result.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.WithError(Nordril.Functional.Results.Error,Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates an error-result from an error.
            </summary>
            <param name="error">The error.</param>
            <param name="resultClass">The class of the result.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.OkIf(System.Boolean,System.Func{`0},System.Collections.Generic.IEnumerable{Nordril.Functional.Results.Error},Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates a <see cref="M:Nordril.Functional.Results.Result.Ok``1(``0)"/> if <paramref name="isOk"/> is true, using <paramref name="factory"/>,
            and <see cref="M:Nordril.Functional.Results.Result.WithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Functional.Results.Error},Nordril.Functional.Results.ResultClass)"/> otherwise.
            </summary>
            <param name="isOk">Whether the result is OK.</param>
            <param name="factory">The value-factory for the return-value if <paramref name="isOk"/> is true.</param>
            <param name="errors">The list of errors if <paramref name="isOk"/> is false.</param>
            <param name="resultClassIfError">The <see cref="P:Nordril.Functional.Results.Result`1.ResultClass"/> if <paramref name="isOk"/> is false.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.op_Equality(Nordril.Functional.Results.Result{`0},Nordril.Functional.Results.Result{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.op_Inequality(Nordril.Functional.Results.Result{`0},Nordril.Functional.Results.Result{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Equals(Nordril.Functional.Results.Result{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.MonoMap(System.Func{`0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.BindAsync``1(System.Func{`0,System.Threading.Tasks.Task{Nordril.Functional.Category.IAsyncMonad{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.PureAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.ApAsync``1(Nordril.Functional.Category.IApplicative{System.Func{`0,System.Threading.Tasks.Task{``0}}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Results.Result`1.MapAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Results.Result">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Results.Result`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Results.Result.Select``2(Nordril.Functional.Results.Result{``0},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to <see cref="T:Nordril.Functional.Results.Result`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.SelectMany``3(Nordril.Functional.Results.Result{``0},System.Func{``0,Nordril.Functional.Results.Result{``1}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to <see cref="T:Nordril.Functional.Results.Result`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.Select``2(System.Threading.Tasks.Task{Nordril.Functional.Results.Result{``0}},System.Func{``0,``1})">
            <summary>
            Equivalent to <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Results.Result`1"/>. Offers LINQ query support with one <c>from</c>-clause.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.SelectMany``3(System.Threading.Tasks.Task{Nordril.Functional.Results.Result{``0}},System.Func{``0,System.Threading.Tasks.Task{Nordril.Functional.Results.Result{``1}}},System.Func{``0,``1,``2})">
            <summary>
            Equivalent to <see cref="T:Nordril.Functional.Category.IMonad`1"/>, but restricted to asynchronous <see cref="T:Nordril.Functional.Results.Result`1"/>. Offers LINQ query support with multiple <c>from</c>-clauses.
            </summary>
            <typeparam name="TSource">The type of the source's value.</typeparam>
            <typeparam name="TMiddle">The type of the selector's result.</typeparam>
            <typeparam name="TResult">The type of the result's value.</typeparam>
            <param name="source">The source.</param>
            <param name="f">The function to apply.</param>
            <param name="resultSelector">The result-selector.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.Ok``1(``0)">
            <summary>
            Creates an OK-result from a value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="result">The result.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.Ok``1">
            <summary>
            Creates an OK-result, invoking the parameterless constructor of <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Results.Result.WithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Functional.Results.Error},Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates an error-result from a list of errors.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="errors">The list of errors.</param>
            <param name="resultClass">The result class.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.WithError``1(Nordril.Functional.Results.Error,Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates an error-result from an error.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="error">The error.</param>
            <param name="resultClass">The class of the result.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.OkIf``1(System.Boolean,System.Func{``0},System.Collections.Generic.IEnumerable{Nordril.Functional.Results.Error},Nordril.Functional.Results.ResultClass)">
            <summary>
            Creates a <see cref="M:Nordril.Functional.Results.Result.Ok``1(``0)"/> if <paramref name="isOk"/> is true, using <paramref name="factory"/>,
            and <see cref="M:Nordril.Functional.Results.Result.WithErrors``1(System.Collections.Generic.IEnumerable{Nordril.Functional.Results.Error},Nordril.Functional.Results.ResultClass)"/> otherwise.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="isOk">Whether the result is OK.</param>
            <param name="factory">The value-factory for the return-value if <paramref name="isOk"/> is true.</param>
            <param name="errors">The list of errors if <paramref name="isOk"/> is false.</param>
            <param name="resultClassIfError">The <see cref="T:Nordril.Functional.Results.ResultClass"/> if <paramref name="isOk"/> is false.</param>
        </member>
        <member name="M:Nordril.Functional.Results.Result.ToResult``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Results.Result`1"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="T">The type of the value contained in the functor.</typeparam>
            <param name="f">The functor to cast to a maybe.</param>
        </member>
        <member name="T:Nordril.Functional.Results.ResultClass">
            <summary>
            Indicates the general class of the result. Roughly equivalent to HTTP status codes.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.AlreadyPresent">
            <summary>
            The resource was already present and couldn't be inserted. Roughly equivalent to HTTP 409 (Conflict).
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.BadRequest">
            <summary>
            The request cannot be fulfilled because it is syntactically invalid.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.DataConflict">
            <summary>
            There was a conflict in the requested data, such as when multiple results were found but only one was expected. Equivalent to HTTP 409 (Conflict).
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.EditConflict">
            <summary>
            There was a conflict with another request when trying to update the resource. Equivalent to HTTP 409 (Conflict).
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.Forbidden">
            <summary>
            The request was not allowed because the user wasn't authorized to perform it. Equivalent to HTTP 403.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.InternalException">
            <summary>
            There was an internal exception. Equivalent to HTTP 500.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.Ok">
            <summary>
            The request was successful and there were no errors.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.NotFound">
            <summary>
            The requested resource was not found. Equivalent to HTTP 404.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.NotImplemented">
            <summary>
            The method has not been implemented. Equivalent to HTTP 501 (Not implemented).
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.ResourceGone">
            <summary>
            The resource is gone. Equivalent to HTTP 410 (Gone) and similar to HTTP 404.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.UnprocessableEntity">
            <summary>
            The request couldn't be processed because it was semantically invalid in a way not described by other <see cref="T:Nordril.Functional.Results.ResultClass"/>-members. This is the default <see cref="T:Nordril.Functional.Results.ResultClass"/> for input error.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.Cancelled">
            <summary>
            The request was cancelled.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Results.ResultClass.Unspecified">
            <summary>
            Unspecified error result, indicating that there was an error, but that we were not able to specify which kind. Should be avoided.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Results.ResultClassExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Results.ResultClass"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Results.ResultClassExtensions.ToHttpStatusCode(Nordril.Functional.Results.ResultClass)">
            <summary>
            Converts a <see cref="T:Nordril.Functional.Results.ResultClass"/> to the nearest approximate HTTP status code.
            </summary>
            <param name="r">The result class to convert.</param>
        </member>
        <member name="T:Nordril.Functional.TupleExtensions">
            <summary>
            Extension methods for <see cref="T:System.ValueTuple"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Flip``2(System.ValueTuple{``0,``1})">
            <summary>
            Flips the items of a 2-tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <param name="t">The tuple to flip.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``2(System.ValueTuple{``0},System.Func{``0,``1})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``3(System.ValueTuple{``0,``1},System.Func{``0,``2})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``4(System.ValueTuple{``0,``1,``2},System.Func{``0,``3})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``0,``4})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``0,``5})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``0,``6})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``0,``7})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``0,``8})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``3(System.ValueTuple{``0,``1},System.Func{``1,``2})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``4(System.ValueTuple{``0,``1,``2},System.Func{``1,``3})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``1,``4})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``1,``5})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``1,``6})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``1,``7})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``1,``8})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``4(System.ValueTuple{``0,``1,``2},System.Func{``2,``3})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``2,``4})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``2,``5})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``2,``6})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``2,``7})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``2,``8})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``3,``4})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``3,``5})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``3,``6})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``3,``7})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``3,``8})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``4,``5})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``4,``6})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``4,``7})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``4,``8})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Sixth``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``5,``6})">
            <summary>
            Applies a function to the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Sixth``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``5,``7})">
            <summary>
            Applies a function to the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Sixth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``5,``8})">
            <summary>
            Applies a function to the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Seventh``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``6,``7})">
            <summary>
            Applies a function to the seventh element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Seventh``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``6,``8})">
            <summary>
            Applies a function to the seventh element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Eighth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``7,``8})">
            <summary>
            Applies a function to the eigth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Both``4(System.ValueTuple{``0,``1},System.Func{``0,``2},System.Func{``1,``3})">
            <summary>
            Applies two functions to the two elements of the tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TResult1">The result of the first function.</typeparam>
            <typeparam name="TResult2">The result of the second function.</typeparam>
            <param name="t">The tuple to which to apply the functions.</param>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0,``0},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0,``0,``0},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0,``0,``0,``0},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0,``0,``0,``0,``0},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0,``0,``0,``0,``0,``0},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.All``2(System.ValueTuple{``0,``0,``0,``0,``0,``0,``0,System.ValueTuple{``0}},System.Func{``0,``1})">
            <summary>
            Applies the same function to all elements of a tuple.
            </summary>
            <typeparam name="T">The type of the tuple's elements.</typeparam>
            <typeparam name="TResult">The type of the function's result.</typeparam>
            <param name="t">The tuple to the elements of which to apply the function.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``3(System.ValueTuple{``0,``1},System.Func{``0,``1,``2})">
            <summary>
            Applies a binary function to the two elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``4(System.ValueTuple{``0,``1,``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Applies a ternary function to the three elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Applies a quaternary function to the four elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Applies a quinary function to the five elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The five element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Applies a senary function to the six elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Applies a septenary function to the seven elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Applies a octonary function to the seven elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``2(System.ValueTuple{``0},``1)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``3(System.ValueTuple{``0,``1},``2)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``4(System.ValueTuple{``0,``1,``2},``3)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``5(System.ValueTuple{``0,``1,``2,``3},``4)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``6(System.ValueTuple{``0,``1,``2,``3,``4},``5)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},``6)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Extend``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},``7)">
            <summary>
            Adds another element to a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="TNew">The type of the element to add.</typeparam>
            <param name="tuple">The tuple to extend.</param>
            <param name="x">The element to add to the tuple.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``2(System.ValueTuple{``0,``1})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``3(System.ValueTuple{``0,``1,``2})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``4(System.ValueTuple{``0,``1,``2,``3})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``5(System.ValueTuple{``0,``1,``2,``3,``4})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``6(System.ValueTuple{``0,``1,``2,``3,``4,``5})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``7(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Contract``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}})">
            <summary>
            Removes the last element of a tuple.
            </summary>
            <typeparam name="T1">The type of the first element.</typeparam>
            <typeparam name="T2">The type of the second element.</typeparam>
            <typeparam name="T3">The type of the third element.</typeparam>
            <typeparam name="T4">The type of the fourth element.</typeparam>
            <typeparam name="T5">The type of the fifth element.</typeparam>
            <typeparam name="T6">The type of the sixth element.</typeparam>
            <typeparam name="T7">The type of the seventh element.</typeparam>
            <typeparam name="T8">The type of the eigth element.</typeparam>
            <param name="tuple">The tuple to contract.</param>
        </member>
        <member name="T:Nordril.Functional.TypeClasses.IRead`2">
            <summary>
            Types which can be parsed from a character-sequence, e.g. a string
            </summary>
            <typeparam name="T">The type to parse.</typeparam>
            <typeparam name="TOptions">The type of the options.</typeparam>
        </member>
        <member name="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)">
            <summary>
            Tries to parse a value of type <typeparamref name="T"/> from a character-sequence, using options of type <typeparamref name="TOptions"/>.
            Implementors MUST NOT use the <c>this</c>-pointer during this operation.
            </summary>
            <param name="source">The character-sequence to parse.</param>
            <param name="options">The options to use for the parsing.</param>
            <returns><see cref="M:Nordril.Functional.Data.Maybe.Just``1(``0)"/> if the parsing was successful, and <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> otherwise.</returns>
        </member>
        <member name="T:Nordril.Functional.TypeClasses.Read">
            <summary>
            Extensions methods for <see cref="T:Nordril.Functional.TypeClasses.IRead`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.TypeClasses.Read.TryParse``1(Nordril.Functional.TypeClasses.IRead{``0,Nordril.Functional.Data.Unit},System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Like <see cref="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)"/>, but without options.
            </summary>
            <typeparam name="T">The type to parse.</typeparam>
            <param name="instance">The instance on which to call <see cref="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)"/>.</param>
            <param name="source">The character-sequences to parse.</param>
        </member>
        <member name="M:Nordril.Functional.TypeClasses.Read.TryParseUnsafe``1(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Calls <see cref="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)"/> without an instance. This is safe to do if the implementor's <see cref="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)"/>-method does not use the this-pointer.
            </summary>
            <typeparam name="T">The type to parse.</typeparam>
            <param name="source">The character-sequences to parse.</param>
        </member>
        <member name="M:Nordril.Functional.TypeClasses.Read.TryParseUnsafe``2(System.Collections.Generic.IEnumerable{System.Char},``1)">
            <summary>
            Calls <see cref="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)"/> without an instance. This is safe to do if the implementor's <see cref="M:Nordril.Functional.TypeClasses.IRead`2.TryParse(System.Collections.Generic.IEnumerable{System.Char},`1)"/>-method does not use the this-pointer.
            </summary>
            <typeparam name="T">The type to parse.</typeparam>
            <typeparam name="TOptions">The type of the options to use.</typeparam>
            <param name="source">The character-sequences to parse.</param>
            <param name="options">The options to use for the parsing.</param>
        </member>
        <member name="T:Nordril.Functional.TypeClasses.Read.ReadProxy">
            <summary>
            A proxy for <c>nameof</c>.
            </summary>
        </member>
    </members>
</doc>
