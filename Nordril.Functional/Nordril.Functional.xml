<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nordril.Functional</name>
    </assembly>
    <members>
        <member name="T:Nordril.Functional.Algebra.Group`1">
            <summary>
            A value-level group.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Group`1.Invert">
            <summary>
            The inversion function.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Group`1.#ctor(`0,System.Func{`0,`0,`0},System.Func{`0,`0})">
            <summary>
            C
            </summary>
            <param name="neutral">The neutral element.</param>
            <param name="op">The binary operation.</param>
            <param name="invert">The inversion function.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Group">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.Monoid`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Group.FromGroupInstance``1(Nordril.Functional.Algebra.IGroup{``0})">
            <summary>
            Reifies a type's <see cref="T:Nordril.Functional.Algebra.IGroup`1"/> instance into its own <see cref="T:Nordril.Functional.Algebra.Group`1"/>-object.
            </summary>
            <typeparam name="T">The type that implements <see cref="T:Nordril.Functional.Algebra.IGroup`1"/>.</typeparam>
            <param name="instance">An object that is an instance of <see cref="T:Nordril.Functional.Algebra.IGroup`1"/>.</param>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.IntAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.FloatAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DoubleAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DecimalAdd">
            <summary>
            The (0,+,negate) group for <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.FloatMult">
            <summary>
            The (1,*,x => 1/x) group for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DoubleMult">
            <summary>
            The (1,*,x => 1/x) group for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Group.DecimalMult">
            <summary>
            The (1,*,x => 1/x) group for <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.ICommutative`1">
            <summary>
            A magma whose binary operation is commutative.
            The binary operation must fulfill the following for all X and Y:
            <code>
                X.Op(Y) == Y.Op(X) (commutativity)
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ICommutativeGroup`1">
            <summary>
            A group which is also commutative.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.IGroup`1">
            <summary>
            A monoid which supports a unary inversion operator with respect to the associative binary operation.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IGroup`1.Inverse">
            <summary>
            Returns the inverse of the object. The inverse must fulfill the following for all X:
            <code>
                X.Inverse.Op(X) == X.Neutral (left-inverse)
                X.Op(X.Inverse) == X.Neutral (right-inverse)
            </code>
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.IMagma`1">
            <summary>
            An algebraic structure supporting a binary operation with no further guaranteed properties.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IMagma`1.Op(`0)">
            <summary>
            The binary operation.
            This operation should not change either operand.
            </summary>
            <param name="that">The second operand.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IMonoid`1">
            <summary>
            A semigroup which has a neutral element with respect to the binary operation.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IMonoid`1.Neutral">
            <summary>
            Returns the neutral element. The neutral element must fulfill the following for any X and Y:
            <code>
                X.Neutral().Op(Y) == Y (left-neutrality)
                X.Op(Y.Neutral()) == X (right-neutrality)
            </code>
            </summary>
        </member>
        <member name="T:Nordril.Functional.Algebra.MonoidExtensions">
            <summary>
            Extensions for monoids.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.MonoidExtensions.Msum``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Sums a list of monoid elements using the monoid operation. If the list is empty, the neutral element is returned. 
            </summary>
            <typeparam name="T">The monoid type.</typeparam>
            <param name="xs">The list of elements to sum.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.MonoidExtensions.Msum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Sums a list of monoid elements using the monoid operation. If the list is empty, the neutral element is returned. 
            </summary>
            <typeparam name="T">The monoid type.</typeparam>
            <param name="xs">The list of elements to sum.</param>
            <param name="empty">The neutral element.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.IPartiallyOrdered`1">
            <summary>
            A type which supports a partial order. A partial order has a "less then or equal" relation (<see cref="M:Nordril.Functional.Algebra.IPartiallyOrdered`1.LeqPartial(`0)"/> with the following properties:
            <list type="table">
                <listheader>
                    <term>Property</term>
                    <description>Definition</description>
                </listheader>
                <item>
                    <term>reflexivity</term>
                    <description>[forall a] a.LeqPartial(a) == Maybe.Just(true)</description>
                </item>
                <item>
                    <term>antisymmetry</term>
                    <description>[forall a,b] if a.LeqPartial(b) == b.LeqPartial(a) == Maybe.Just(true) then a.Equals(b)</description>
                </item>
                <item>
                    <term>transitivity</term>
                    <description>[forall a,b,c] if a.LeqPartial(b) == b.LeqPartial(c) == Maybe.Just(true) then a.LeqPartial(c) == Maybe.Just(true)</description>
                </item>
            </list>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.IPartiallyOrdered`1.LeqPartial(`0)">
            <summary>
            The "less than or equals"-predicate which returns the comparison of two elements or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> if the two elements are incomparable.
            </summary>
            <param name="that">The second element to compare to the first.</param>
            <returns>Maybe.Just(true) iff the first element is less than or equal to the second. Maybe.Nothing if the elements are incomparable.</returns>
        </member>
        <member name="T:Nordril.Functional.Algebra.IRing`1">
            <summary>
            A algebraic ring, which is the combination of a commutative group (<see cref="M:Nordril.Functional.Algebra.IRing`1.Plus(`0)"/>, <see cref="P:Nordril.Functional.Algebra.IRing`1.Zero"/>) and a monoid (<see cref="M:Nordril.Functional.Algebra.IRing`1.Mult(`0)"/>, <see cref="P:Nordril.Functional.Algebra.IRing`1.One"/>), and where the following holds:
            <br />
            <code>
               a.Mult(b.Plus(c)) == a.Mult(b).Plus(a.Mult(c)) (left-distributivity)
               b.Plus(c).Mult(a) == b.Mult(a).Plus(c.Mult(a) (right-distributivity)
            </code>
            <br />
            In standard mathematical notation, with Plus being '+' and Mult being '*':
            <br />
            <code>
               a * (b + c) == (a * b) + (a * c)
               (b + c) * a == (b * a) + (c * a)
            </code>
            <code>
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.IRing`1.Zero">
            <summary>
            The neutral element of <see cref="M:Nordril.Functional.Algebra.IRing`1.Plus(`0)"/>.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Algebra.IRing`1.One">
            <summary>
            The neutral element of <see cref="M:Nordril.Functional.Algebra.IRing`1.Mult(`0)"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.IRing`1.Plus(`0)">
            <summary>
            The addition-operation which forms a commutative group with <see cref="P:Nordril.Functional.Algebra.IRing`1.Zero"/>.
            </summary>
            <param name="that">The second operand.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.IRing`1.Mult(`0)">
            <summary>
            The multiplication-operation which forms a monoid with <see cref="P:Nordril.Functional.Algebra.IRing`1.One"/>.
            </summary>
            <param name="that">The second operand.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.ISemigroup`1">
            <summary>
            A semigroup whose binary operation is associative.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Algebra.ITotallyOrdered`1">
            <summary>
            A type which supports a total order. A total order has a "less then or equal" relation (<see cref="M:Nordril.Functional.Algebra.ITotallyOrdered`1.Leq(`0)"/> with the following properties:
            <list type="table">
                <listheader>
                    <term>Property</term>
                    <description>Definition</description>
                </listheader>
                <item>
                    <term>reflexivity</term>
                    <description>[forall a] a.Leq(a) == true</description>
                </item>
                <item>
                    <term>antisymmetry</term>
                    <description>[forall a,b] if a.Leq(b) == b.Leq(a) == true then a.Equals(b)</description>
                </item>
                <item>
                    <term>transitivity</term>
                    <description>[forall a,b,c] if a.Leq(b) == b.Leq(c) == true then a.Leq(c) == true</description>
                </item>
                <item>
                    <term>agreement</term>
                    <description>[forall a,b, t] if a.Leq(b) == t &lt;==&gt; a.LeqPartial(b) == Maybe.Just(t)</description>
                </item>
            </list>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.ITotallyOrdered`1.Leq(`0)">
            <summary>
            The "less than or equals"-predicate.
            </summary>
            <param name="that">The second element to compare to the first.</param>
            <returns>true iff the first element is less than or equal to the second.</returns>
        </member>
        <member name="T:Nordril.Functional.Algebra.TotallyOrderedExtenions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.ITotallyOrdered`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotallyOrderedExtenions.Le``1(``0,``0)">
            <summary>
            The "strictly less than"-predicate
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotallyOrderedExtenions.Ge``1(``0,``0)">
            <summary>
            The "strictly greater than"-predicate
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotallyOrderedExtenions.Geq``1(``0,``0)">
            <summary>
            The "greater than or equals"-predicate
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Magma`1">
            <summary>
            A value-level structure that offers a binary operation.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Magma`1.Op">
            <summary>
            The binary operation.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Magma`1.#ctor(System.Func{`0,`0,`0})">
            <summary>
            Creates a new magma.
            </summary>
            <param name="f">The binary operation.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid`1">
            <summary>
            A value-level monoid.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.Monoid`1.Neutral">
            <summary>
            The neutral element of the binary operation.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid`1.#ctor(`0,System.Func{`0,`0,`0})">
            <summary>
            Creates a new monoid.
            </summary>
            <param name="neutral">The neutral element.</param>
            <param name="op">The binary operation.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Monoid">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.Monoid`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.FromMonoidInstance``1(Nordril.Functional.Algebra.IMonoid{``0})">
            <summary>
            Reifies a type's <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> instance into its own <see cref="T:Nordril.Functional.Algebra.Monoid`1"/>-object.
            </summary>
            <typeparam name="T">The type that implements <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/>.</typeparam>
            <param name="instance">An object that is an instance of <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/>.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.ListAppend``1">
            <summary>
            The mutating ([],++) monoid for lists.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.ImmutableListAppend``1">
            <summary>
            The non-mutating ([],++) monoid for lists, meaning that the inputs of <see cref="P:Nordril.Functional.Algebra.Magma`1.Op" /> aren't changed.
            </summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.StringAppend">
            <summary>
            The ("",+) monoid for <see cref="T:System.String"/>.
            BEWARE THAT THIS HAS VERY POOR PERFORMANCE.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.StringBuilderAppend">
            <summary>
            The ("",Append) monoid for <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.BoolAnd">
            <summary>
            The (true,&amp;&amp;) monoid for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.BoolOr">
            <summary>
            The (true,||) monoid for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Monoid.IntMult">
            <summary>
            The (0,+) monoid for <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.FirstOrDefault``1(``0)">
            <summary>
            The monoid whose operation always returns the first element and which has a default-value.
            </summary>
            <param name="default">The neutral element of the monoid.</param>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.LastOrDefault``1(``0)">
            <summary>
            The semigroup whose operation always returns the last element.
            </summary>
            <param name="default">The neutral element of the monoid.</param>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.LiftMonoidWithInfinity``1(Nordril.Functional.Algebra.Monoid{``0})">
            <summary>
            Lifts a <see cref="T:Nordril.Functional.Algebra.Monoid`1"/> into one which has positive infinity (<see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>) as a special element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <param name="m">The monoid to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.Monoid.Msum``1(System.Collections.Generic.IEnumerable{``0},Nordril.Functional.Algebra.Monoid{``0})">
            <summary>
            Sums a list of elements using a monoid instance. If the list is empty, the neutral element is returned.
            </summary>
            <typeparam name="T">The type of elements to sum.</typeparam>
            <param name="xs">The list of elements to sum.</param>
            <param name="m">The monoid instance.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.PartialOrder`1">
            <summary>
            A value-level partial order.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.PartialOrder`1.LeqPartial">
            <summary>
            The "less than or equals"-predicate. See <see cref="M:Nordril.Functional.Algebra.IPartiallyOrdered`1.LeqPartial(`0)"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.PartialOrder`1.#ctor(System.Func{`0,`0,Nordril.Functional.Data.Maybe{System.Boolean}})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="leqPartial">The "less than or equals"-predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Semigroup`1">
            <summary>
            A value-level semigroup whose binary operation is associative.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup`1.#ctor(System.Func{`0,`0,`0})">
            <summary>
            Creates a new semigroup.
            </summary>
            <param name="f">The binary operation.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.Semigroup">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.Semigroup`1"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Algebra.Semigroup.BoolXor">
            <summary>
            The (^) semigroup for <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup.First``1">
            <summary>
            The semigroup whose operation always returns the first element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup.Last``1">
            <summary>
            The semigroup whose operation always returns the last element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.Semigroup.LiftSemigroupWithInfinity``1(Nordril.Functional.Algebra.Semigroup{``0})">
            <summary>
            Lifts a <see cref="T:Nordril.Functional.Algebra.Semigroup`1"/> into one which has positive infinity (<see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>) as a special element.
            </summary>
            <typeparam name="T">The type of the element in the structure.</typeparam>
            <param name="m">The monoid to lift.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.TotalOrder`1">
            <summary>
            A value-level total order.
            </summary>
            <typeparam name="T">The type of element in this structure.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Algebra.TotalOrder`1.Leq">
            <summary>
            The "less than or equals"-predicate. See <see cref="M:Nordril.Functional.Algebra.IPartiallyOrdered`1.LeqPartial(`0)"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates a new instance.
            </summary>
            <param name="leq">The "less than or equals"-predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Algebra.TotalOrder">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Algebra.TotalOrder`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Le``1(Nordril.Functional.Algebra.TotalOrder{``0},``0,``0)">
            <summary>
            The "strictly less than"-predicate
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Ge``1(Nordril.Functional.Algebra.TotalOrder{``0},``0,``0)">
            <summary>
            The "strictly greater than"-predicate
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.Geq``1(Nordril.Functional.Algebra.TotalOrder{``0},``0,``0)">
            <summary>
            The "greater than or equals"-predicate
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="order">The total order.</param>
            <param name="x">The first element.</param>
            <param name="y">The second element.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.FromComparable``1">
            <summary>
            Returns the total order on a type <typeparamref name="T"/> which implements <see cref="T:System.IComparable`1"/>.
            </summary>
            <typeparam name="T">The type that implements <see cref="T:System.IComparable`1"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.ToTotalOrder``1(System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns a total order on a type <typeparamref name="T"/> based on a <paramref name="comparer"/>.
            </summary>
            <typeparam name="T">The type for which we have an <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:Nordril.Functional.Algebra.TotalOrder.LiftTotalOrderWithInfinity``1(Nordril.Functional.Algebra.TotalOrder{``0})">
            <summary>
            Lifts a total order into one which supports positive infinity in the form of <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
            <typeparam name="T">The type of elements in this structure.</typeparam>
            <param name="order">The total order to lift.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFunctor`4">
            <summary>
            A value-level functor which can map the contents of a data structure. See <see cref="T:Nordril.Functional.Category.IFunctor`1"/>.
            </summary>
            <typeparam name="TFSource">The type of the source data structure.</typeparam>
            <typeparam name="TFResult">The type of the result data structure.</typeparam>
            <typeparam name="TSource">The type of the contained elements in <typeparamref name="TFSource"/>.</typeparam>
            <typeparam name="TResult">The type of the contained elements in <typeparamref name="TFResult"/>.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFunctor`4.Map(System.Func{`2,`3})">
            <summary>
            Applies a function to each element of a data structure. Implementors must obey the same laws as in <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/>.
            </summary>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IAlternative`1">
            <summary>
            A subset of <see cref="T:Nordril.Functional.Category.IApplicative`1"/> that has a notion of "combining computations". It's up to the implementor to define how this combining works, but implementors should obey the following laws:
            <code>
                x.Empty().Alt(a) == a (left-neutrality of Empty)
                a.Alt(x.Empty()) == a (right-neutrality of Empty)
                a.Alt(b).Alt(c)  == a.Alt(b.Alt(c)) (associativity of Alt)
            </code>
            <see cref="T:Nordril.Functional.Category.IAlternative`1"/> is thus a <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/> on <see cref="T:Nordril.Functional.Category.IApplicative`1"/>.
            Moreover, the implementor should obey
            <code>
                x.Empty().Ap(a) == x.Empty() (guard)
            </code>
            Additionally, if the implementor implements <see cref="T:Nordril.Functional.Category.IMonadPlus`1"/>, it should also obey:
            <code>
                x.Empty().Bind(f) == x.Empty()
            </code>
            </summary>
            <remarks>
            <see cref="T:Nordril.Functional.Category.IAlternative`1"/> serves two purposes: it functions as a monoid on instances of <see cref="T:Nordril.Functional.Category.IApplicative`1"/> and it provides a "guard"-function which can stop a computation if it's not fulfilled. This is done via <see cref="M:Nordril.Functional.Category.IAlternative`1.Empty"/>.
            </remarks>
            <typeparam name="TSource">The data contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IAlternative`1.Empty">
            <summary>
            Returns a computation with zero results. The this-value MUST NOT BE USED by implementors.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.IAlternative`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <summary>
            Combines two computations.
            </summary>
            <param name="x">The other computation.</param>
        </member>
        <member name="T:Nordril.Functional.Category.AlternativeExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.AlternativeExtensions.Guard``1(System.Func{System.Boolean})">
            <summary>
            A guard-function with respect to <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/> and <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>. If the condition is not fulfilled, the computation does not proceed.
            </summary>
            <typeparam name="TResult">The type of the resultant <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.</typeparam>
            <param name="condition">The condition.</param>
            <returns>Either Pure(Unit) or Empty.</returns>
        </member>
        <member name="M:Nordril.Functional.Category.AlternativeExtensions.AltSum``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Aggregates a sequence of <see cref="T:Nordril.Functional.Category.IAlternative`1"/>, combining the element from left to right via <see cref="M:Nordril.Functional.Category.IAlternative`1.Alt(Nordril.Functional.Category.IAlternative{`0})"/>. The accumulator is <see cref="M:Nordril.Functional.Category.IAlternative`1.Empty"/>.
            </summary>
            <typeparam name="TResult">The type of values in the <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.</typeparam>
            <typeparam name="TAlt">The type of the <see cref="T:Nordril.Functional.Category.IAlternative`1"/>.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IApplicative`1">
            <summary>
            An applicative functor which supports applying multi-argument functions to containers.
            Implementations must fulfill the following (assuming that Pure(a) == X.Pure(a) for readability)
            for all a, f, g, h.
            <code>
                Pure(a).Ap(b => b) == Pure(a) (identity)
                Pure(a).Ap(Pure(f)) == Pure(f(a)) (homomorphism)
                Pure(a).Ap(f) == f.Ap(Pure(a => f(a))) (interchange)
                h.Ap(g).Ap(f) == h.Ap(g.Ap(f.Ap(Pure(comp)))) (composition)
                where
                   comp f2 f1 x = f2(f1(x)) 
            </code>
            </summary>
            <typeparam name="TSource">The data contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)">
            <summary>
            Wraps a value into an applicative. The this-value MUST NOT BE USED by implementors.
            </summary>
            <typeparam name="TResult">The type of the value to wrap.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <summary>
            Takes an applicative value and a function wrapped in an applicative value,
            and applies the function to this container.
            </summary>
            <typeparam name="TResult">The result type</typeparam>
            <param name="f">The wrapped function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.ApplicativeExtensions">
            <summary>
            Extensions for <see cref="T:Nordril.Functional.Category.IApplicative`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.ApF``2(Nordril.Functional.Category.IApplicative{System.Func{``0,``1}},Nordril.Functional.Category.IApplicative{``0})">
            <summary>
            <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/> with the arguments reversed,
            meaning that the function is applied to the argument, which reads more natural.
            </summary>
            <typeparam name="TSource">The argument type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="f">The applicative containing the function mapping the source type to the result type.</param>
            <param name="x">The applicative containing the source type.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.Pure``2(``0)">
            <summary>
            Wraps an object in an applicative via <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            </summary>
            <typeparam name="TSource">The type of the object to wrap.</typeparam>
            <typeparam name="TResult">The type of the applicative to return.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.PureUnsafe``2(``0)">
            <summary>
            Wraps an object in an applicative via <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>.
            The applicative in question does not have to posess a parameterless constuctor; instead a call to <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/> with the this-pointer being null is forced.
            If the requested applicative uses the this-pointer in <see cref="M:Nordril.Functional.Category.IApplicative`1.Pure``1(``0)"/>, this will result in a <see cref="T:System.NullReferenceException"/>.
            </summary>
            <typeparam name="TSource">The type of the object to wrap.</typeparam>
            <typeparam name="TResult">The type of the applicative to return.</typeparam>
            <param name="x">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.LiftA``3(System.Func{``0,``1,``2})">
            <summary>
            Lifts a binary function to take two applicative arguments.
            </summary>
            <example>
            <code>
                var x = Maybe.Just(5);
                var y = Maybe.Nothing&lt;int&gt;();
                Func&lt;int,int,int&gt; f = (x,y) => x + y;
                
                //f takes integer arguments, but we can apply it to two maybe-arguments,
                //with automatic unpacking and packing of the results, via liftA*.
                var result = f.LiftA2()(x, y);
            </code>
            </example>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.LiftA``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Lifts a ternary function to take three applicative arguments. See <see cref="M:Nordril.Functional.Category.ApplicativeExtensions.LiftA``3(System.Func{``0,``1,``2})"/>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the second argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.LiftA``5(System.Func{``0,``1,``2,``4})">
            <summary>
            Lifts a quaternary function to take three applicative arguments. See <see cref="M:Nordril.Functional.Category.ApplicativeExtensions.LiftA``3(System.Func{``0,``1,``2})"/>
            </summary>
            <typeparam name="T1">The type of the first argument.</typeparam>
            <typeparam name="T2">The type of the second argument.</typeparam>
            <typeparam name="T3">The type of the second argument.</typeparam>
            <typeparam name="T4">The type of the second argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.WhereAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            An applicative/monadic filter operation which is a generalization of <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>. If the applicative is <see cref="T:Nordril.Functional.Data.Identity`1"/>, this function behaves identically to that in LINQ. The sequence is traversed via <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>.
            </summary>
            <example>
                //Computing the powerset (interpreting a sequence as a set).
                //Using the non-determinism monad of FuncList, every element is non-deterministically
                //both excluded and included, and the result is a FuncList containing as elements all possible
                //subsets of {1,2,3}.
                var new List&lt;int&gt; { 1, 2, 3}.WhereAp(x => new FuncList&lt;bool&gt; {false, true});
            </example>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TPredicate">The applicate-type of the predicate.</typeparam>
            <typeparam name="TResult">The applicative-type of the result. This should agree with <typeparamref name="TPredicate"/>.</typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="f">The filtering predicate. Elements for which it returns true are included, otherwise they're excluded.</param>
            <returns>The sequence, traversed left to right, using the applicative combining operation at each step.</returns>
            <exception cref="T:System.NullReferenceException">If the applicative in question does not implement <see cref="M:Nordril.Functional.Category.ApplicativeExtensions.Pure``2(``0)"/> correctly and uses the this-pointer.</exception>
            <exception cref="T:System.InvalidCastException">If <typeparamref name="TPredicate"/> and <typeparamref name="TResult"/> are incompatible.</exception>
        </member>
        <member name="M:Nordril.Functional.Category.ApplicativeExtensions.SelectAp``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Category.IApplicative{``1}})">
            <summary>
            An applicative/monadic <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/> operation. If the applicative is <see cref="T:Nordril.Functional.Data.Identity`1"/>, this function behaves identically to that in LINQ. The sequence is traversed via <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>.
            </summary>
            <example>
                //Map each element to itself and its negation
                //Using the non-determinism monad of FuncList, every element is non-deterministically
                //mapped to both values, and the result is a FuncList containing as elements all possible
                //combinations.
                var new List&lt;int&gt; { 1, 2, 3}.SelectAp(x => new FuncList&lt;bool&gt; {x, x*(-1)});
                
                //result: [1,2,3], [1,2,-3], [1,-2,3], [1,-2,-3], [-1,2,3], [-1,2,-3], [-1,-2,3], [-1,-2,-3]
            </example>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TResult">The type of the result-elements.</typeparam>
            <typeparam name="TResultList">The applicative-type of the result. This should agree with <typeparamref name="TResult"/></typeparam>
            <param name="xs">The sequence to filter.</param>
            <param name="f">The filtering predicate. Elements for which it returns true are included, otherwise they're excluded.</param>
            <returns>The sequence, traversed left to right, using the applicative combining operation at each step.</returns>
            <exception cref="T:System.NullReferenceException">If the applicative in question does not implement <see cref="M:Nordril.Functional.Category.ApplicativeExtensions.Pure``2(``0)"/> correctly and uses the this-pointer.</exception>
            <exception cref="T:System.InvalidCastException">If <typeparamref name="TResultList"/> and <typeparamref name="TResult"/> are incompatible.</exception>
        </member>
        <member name="T:Nordril.Functional.Category.IBifunctor`2">
            <summary>
            A bifunctor that contains both <typeparamref name="TLeft"/> values and <typeparamref name="TRight"/> values.
            An example is a tuple.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IBifunctor`2.BiMap``2(System.Func{`0,``0},System.Func{`1,``1})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.BiMap(a => a, b => b) == X (identity)
                X.BiMap(x => f(g(x)), x => h(i(x))) == X.BiMap(g, i).BiMap(f, h) (homomorphism)
            </code>
            </summary>
            <typeparam name="TLeftResult">The type of the left result.</typeparam>
            <typeparam name="TRightResult">The type of the right result.</typeparam>
            <param name="f">The left function to apply to the functor.</param>
            <param name="g">The right function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.BifunctorExtensions">
            <summary>
            Extensions for <see cref="T:Nordril.Functional.Category.IBifunctor`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.LeftMap``3(Nordril.Functional.Category.IBifunctor{``0,``1},System.Func{``0,``2})">
            <summary>
            Maps over just the left part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/>.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <typeparam name="TLeftResult">The type of the left result.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.LeftMap``2(Nordril.Functional.Category.IBifunctor{``0,``1},System.Action{``0})">
            <summary>
            Applies an action to the left part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/> and returns it.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.RightMap``3(Nordril.Functional.Category.IBifunctor{``0,``1},System.Func{``1,``2})">
            <summary>
            Maps over just the right part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/>.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <typeparam name="TRightResult">The type of the right result.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.BifunctorExtensions.RightMap``2(Nordril.Functional.Category.IBifunctor{``0,``1},System.Action{``1})">
            <summary>
            Applies an action to the right part of a <see cref="T:Nordril.Functional.Category.IBifunctor`2"/> and returns it.
            </summary>
            <typeparam name="TLeft">The type of the left values.</typeparam>
            <typeparam name="TRight">The type of the right values.</typeparam>
            <param name="this">The bifunctor to apply over.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IComonad`1">
            <summary>
            A comonad, which is the categorical dual of a <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            Whereas monads support the wrapping of values, comonads support their unwrapping.
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IComonad`1.Extract">
            <summary>
            Extracts a new value from the comonad.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.IComonad`1.Extend``1(System.Func{Nordril.Functional.Category.IComonad{`0},``0})">
            <summary>
            Takes a function that extracts values from a comonad and chains it to this comonad by wrapping its result into a comonad.
            Implementros must fulfill the following for all X and f, g:
            <code>
                X.Extend(x => x.Extract()) = id (comonadic left-identity)
                X.Extend(f).Extract() = f (comonadic right-identity)
                X.Extend(g).Extend(f) = X.Extend(x => f(x.Extend(g))) (comonadic associativity)
            </code>
            Alternately, one can state these laws via Cokleisli composition =>=:
            <code>
                f =>= (x => x.Extract() = f (comonadic left-identity*)
                (x => x.Extract()) =>= f = f (comonadic right-identity*)
                (f =>= g) =>= h = f =>= (g =>= h) (comonadic associativity*)
            </code>
            For more detail, see https://hackage.haskell.org/package/comonad.
            </summary>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="f">The function to chain to the comonad.</param>
        </member>
        <member name="T:Nordril.Functional.Category.ComonadExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IComonad`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.ComonadExtensions.Duplicate``1(Nordril.Functional.Category.IComonad{``0})">
            <summary>
            The dual of <see cref="M:Nordril.Functional.Category.MonadExtensions.Join``1(Nordril.Functional.Category.IMonad{Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TSource">The type of values produced by the comonad.</typeparam>
            <param name="m">The comonad to duplicate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IContravariant`1">
            <summary>
            A contravariant functor. A contravariant functor is a functor that <em>needs</em> values of type <typeparamref name="TSource"/>
            instead of containing them.
            </summary>
            <typeparam name="TSource">The of the required values.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IContravariant`1.ContraMap``1(System.Func{``0,`0})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.ContraMap(a => a) == X (identity)
                X.ContraMap(a => g(f(a))) == X.Map(g).Map(f) (contravariant homomorphism)
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IEvaluator`3">
            <summary>
            An evaluator which can run an evaluation on a value of type <typeparamref name="TSource"/> and return a result
            of type <typeparamref name="TResult"/>.
            An example would be an expression tree which is reduced to a value.
            </summary>
            <typeparam name="TSource">The type of objects which this evaluator can evaluate.</typeparam>
            <typeparam name="TResult">The type of the result, if the evaluation is successful.</typeparam>
            <typeparam name="TError">The type of the error, if the evaluation is unsuccessful.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IEvaluator`3.Evaluate(`0)">
            <summary>
            Evaluates a <typeparamref name="TSource"/> and returns a <typeparamref name="TResult"/>.
            The evaluation may fail, and in that case, the method must return a <typeparamref name="TError"/>.
            </summary>
            <param name="arg">The value to evaluate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFilterable`2">
            <summary>
            Filterable data structures. A filterable structure supports a <see cref="M:Nordril.Functional.Category.IFilterable`2.Filter(System.Func{`1,System.Boolean})"/>-method which returns a filtered copy of the structure, with exactly the elements which fulfill a predicate.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TSource">The type of element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFilterable`2.Filter(System.Func{`1,System.Boolean})">
            <summary>
            Filters the container's elements, leaving the original unchanged and returning a version of the container which have the same structure as the original, but only with those elements which fulfill <paramref name="f"/>. What "leaving out elements" means exactly, depends on the implementor.
            </summary>
            <param name="f">The predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.ISemifilterable`2">
            <summary>
            Filterable data structures which do not support the removal of all elements. This is a weaker form of <see cref="T:Nordril.Functional.Category.IFilterable`2"/> which does not support returning empty data structures if all elements have been excluded, but returns <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> instead.
            An example is <see cref="T:Nordril.Functional.Data.Tree`1"/>, which cannot represent empty trees, but which still supports a kind of filtering of its nodes.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TSource">The type of element in the structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.ISemifilterable`2.Semifilter(System.Func{`1,System.Boolean})">
            <summary>
            Filters the container's elements, leaving the original unchanged and returning a version of the container which have the same structure as the original, but only with those elements which fulfill <paramref name="f"/>. What "leaving out elements" means exactly, depends on the implementor.
            If all elements have been excluded by <paramref name="f"/>, <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> is returned.
            </summary>
            <param name="f">The predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFoldable`1">
            <summary>
            Data structures that suppoort folding, i.e. aggregation over their members.
            </summary>
            <typeparam name="TSource">The type of the values contained in the data structure.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFoldable`1.FoldMap``1(Nordril.Functional.Algebra.Monoid{``0},System.Func{`0,``0})">
            <summary>
            Maps each element of the structure to a monoid and then combines the elements
            using the monoid's <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0)"/> operation.
            </summary>
            <param name="monoid">The monoid dictionary that should be used.</param>
            <param name="f">The function that maps an element to a monoid.</param>
        </member>
        <member name="M:Nordril.Functional.Category.IFoldable`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <summary>
            Right-associative fold of the data structure.
            </summary>
            <typeparam name="TResult">The result type of the fold.</typeparam>
            <param name="f">The aggregation function, which takes an element of the structure and the current accumulator value,
            and returns the new accumulator value.</param>
            <param name="accumulator">The initial accumulator value.</param>
        </member>
        <member name="T:Nordril.Functional.Category.FoldableExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IFoldable`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.FoldableExtensions.FoldMap``2(Nordril.Functional.Category.IFoldable{``0},System.Func{``1},System.Func{``0,``1})">
            <summary>
            Maps each element of the structure to a monoid and then combines the elements
            using the monoid's <see cref="M:Nordril.Functional.Algebra.IMagma`1.Op(`0)"/> operation.
            </summary>
            <typeparam name="TSource">The type of elements contained in <paramref name="foldable"/>.</typeparam>
            <typeparam name="TMonoid">The monoid to which to mape the elements.</typeparam>
            <param name="foldable">The object to fold.</param>
            <param name="empty">The neutral element of the monoid.</param>
            <param name="f">The function that maps an element to a monoid.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IFunctor`1">
            <summary>
            A functor. A functor is a container that contains 0 or more instances of <typeparamref name="TSource"/>.
            One can apply functions to functors to change their contained type.
            </summary>
            <typeparam name="TSource">The data contained in the functor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})">
            <summary>
            Applies a function to the functor and returns a new functor without changing the original functor.
            Implementors must fulfill the following for all X and functions f and g:
            <code>
                X.Map(a => a) == X (identity)
                X.Map(a => g(f(a))) == X.Map(f).Map(g) (homomorphism)
            </code>
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.FunctorExtensions">
            <summary>
            Extensions for the <see cref="T:Nordril.Functional.Category.IFunctor`1"/> class.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.FunctorExtensions.Void``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Erases the contents of a functor.
            </summary>
            <typeparam name="TSource">The source type of the functor.</typeparam>
            <param name="f">The functor.</param>
        </member>
        <member name="M:Nordril.Functional.Category.FunctorExtensions.Map``1(Nordril.Functional.Category.IFunctor{``0},System.Action{``0})">
            <summary>
            Applies an action to a functor and returns it.
            The action is presumable mutating.
            </summary>
            <typeparam name="TSource">The source type of the functor.</typeparam>
            <param name="f">The functor.</param>
            <param name="a">The action to apply to the values in the functor.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonad`1">
            <summary>
            A monad. Monads, in addition to wrapping values (via <see cref="T:Nordril.Functional.Category.IApplicative`1"/>
            and mapping over their contained values (via <see cref="T:Nordril.Functional.Category.IFunctor`1"/> support temporarily
            unpacking their contained values and re-packing them via the <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>
            operator. Unlike <see cref="M:Nordril.Functional.Category.IApplicative`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>,
            this allows dynamically controlling the computational path at runtime, instead of just applying a fixed
            function over one of more wrapped arguments.
            </summary>
            <typeparam name="TSource">The type of the values contained in the monad.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <summary>
            Unpacks the value(s) contained in this monad and applies a function to them.
            Bind corresponds to chaining functions, with the addition of the monadic context.
            Implementors must fulfill the following laws:
            <code>
                Pure(a).Bind(f) == f(a) (left identity of pure)
                f.Bind(x => g(x).Bind(h)) == f.Bind(g).Bind(h) (associativity)
            </code>
            These laws are identical to the laws of <see cref="T:Nordril.Functional.Algebra.IMonoid`1"/>, except for the
            type variable in <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.MonadExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Category.IMonad`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Then``2(Nordril.Functional.Category.IMonad{``0},System.Func{``0,Nordril.Functional.Category.IMonad{``1}})">
            <summary>
            A more readable alias to <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="a">The value containing the source.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.ThenM``3(System.Func{``0,Nordril.Functional.Category.IMonad{``1}},System.Func{``1,Nordril.Functional.Category.IMonad{``2}})">
            <summary>
            Chains two monad-producing functions by executing the first, then the second, gluing them together using
            <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>. The monadic equivalent of
            <see cref="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})"/>.
            </summary>
            <typeparam name="TSource">The input of the first function.</typeparam>
            <typeparam name="TResult1">The output of the first function (wrapped in a monad) and the input of the second.</typeparam>
            <typeparam name="TResult2">The output of the second function (wrapped in a monad).</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.AfterM``3(System.Func{``1,Nordril.Functional.Category.IMonad{``2}},System.Func{``0,Nordril.Functional.Category.IMonad{``1}})">
            <summary>
            Chains two monad-producing functions by executing the second, then the first, gluing them together using
            <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>. The monadic equivalent of
            <see cref="M:Nordril.Functional.F.After``3(System.Func{``1,``2},System.Func{``0,``1})"/>.
            </summary>
            <typeparam name="TSource">The input of the second function.</typeparam>
            <typeparam name="TResult1">The output of the first function (wrapped in a monad) and the input of the second.</typeparam>
            <typeparam name="TResult2">The output of the second function (wrapped in a monad).</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Then``2(Nordril.Functional.Category.IMonad{``0},Nordril.Functional.Category.IMonad{``1})">
            <summary>
            Extracts the value(s) from the source and replaces it with another one, ignoring the values of the source.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="a">The value containing the source.</param>
            <param name="b">The value containing the result.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Comp``3(System.Func{``0,Nordril.Functional.Category.IMonad{``1}},System.Func{``1,Nordril.Functional.Category.IMonad{``2}})">
            <summary>
            Concatenates two monad-functions.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TResult1">The intermediate result type.</typeparam>
            <typeparam name="TResult2">The funal result type.</typeparam>
            <param name="f">The first monad function.</param>
            <param name="g">The second monad function.</param>
        </member>
        <member name="M:Nordril.Functional.Category.MonadExtensions.Join``1(Nordril.Functional.Category.IMonad{Nordril.Functional.Category.IMonad{``0}})">
            <summary>
            Flattens the structure of a monad. The following holds for all X and f, given a correctly implemented
            <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/> and
            <see cref="M:Nordril.Functional.Category.IMonad`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>:
            <code>
                X.Map(x => x.Join()).Join() = X.Join().Join()
                X.Map(x => x.Pure()).Join() = X.Pure().Join() = id
                X.Map(x => x.Map(f)).Join() = X.Join().Map(f)
            </code>
            </summary>
            <typeparam name="T">The type in the monad.</typeparam>
            <param name="a">The monad to flatten.</param>
            <returns></returns>
        </member>
        <member name="T:Nordril.Functional.Category.IMonadPlus`1">
            <summary>
            Monads that support choice (see <see cref="M:Nordril.Functional.Category.IMonadPlus`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})"/>) in addition to failure (see <see cref="M:Nordril.Functional.Category.IMonadZero`1.Mzero"/>).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadPlus`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <summary>
            Adds two monad values. Implementors must fulfill the following for all X and a, b, c, and k:
            <code>
                X.Mzero.Mplus(a) = a (left identity)
                a.Mplus(X.mzero) = a (right identity)
                a.Mplus(b).Mplus(c) = a.Mplus(b.Mplus(c)) (associativity)
                a.Mplus(b).Bind(k) = a.Bind(k).Mplus(b.Bind(k)) (left-distribution)
            </code>
            </summary>
            <param name="that">The second argument.</param>
        </member>
        <member name="T:Nordril.Functional.Category.IMonadZero`1">
            <summary>
            A monad with a zero, which corresponds to the zero of an algebraic ring,
            being, in essence, a "fail"-element.
            </summary>
            <typeparam name="T">The type of value contained in the monad.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonadZero`1.Mzero">
            <summary>
            The zero of the monad. The zero must fulfill the following for any X:
            <code>
                X.Bind(X.MZero) == X.MZero (left zero)
            </code>
            </summary>
        </member>
        <member name="T:Nordril.Functional.Category.IMonoFunctor`2">
            <summary>
            Monofunctors. Monofunctors are like functors (see <see cref="T:Nordril.Functional.Category.IFunctor`1"/>), but
            they only support one specific type of element. An example would be a string, which is a monofunctor
            over char.
            Implementations have to obey the same laws as those of <see cref="T:Nordril.Functional.Category.IFunctor`1"/> (for all X and f,g):
            <code>
                X.Map(a => a) == X (identity)
                X.Map(a => g(f(a))) == X.Map(f).Map(g) (homomorphism)
            </code>
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
            <typeparam name="TElem">The type of element contained in the monofunctor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IMonoFunctor`2.MonoMap(System.Func{`1,`1})">
            <summary>
            Applies a function to the values contained within the monofunctor
            and returns the result, without modifying the original object.
            </summary>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.Functional.Category.INaturalTransformation">
            <summary>
            A natural transformation which transforms one functor into another.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.INaturalTransformation.Transform``3(``1)">
            <summary>
            Transforms one functor into another. If the implementor can't transform between
            the requested source and target functors, it should return Nothing.
            </summary>
            <typeparam name="TSource">The type of the source elements.</typeparam>
            <typeparam name="TFSource">The type of the source functor.</typeparam>
            <typeparam name="TFTarget">The type of the target functor.</typeparam>
            <param name="s">The source functor.</param>
            <returns></returns>
        </member>
        <member name="T:Nordril.Functional.Category.IPhantomFunctor`1">
            <summary>
            A phantom-functor which is both a functor and a contravariant functor.
            Since a (covariant) functor and a contravariant functor to "the opposite things",
            one containing and one consuming values of type <typeparamref name="T"/>, the only
            way for any class to implement both is to not contain <typeparamref name="T"/> at all - 
            hence, <typeparamref name="T"/> is only a <em>phantom.</em>
            </summary>
            <typeparam name="T">The type of the values in the functor.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Category.IProfunctor`2">
            <summary>
            A functor that is contravariant in one type argument (meaning it needs values of that type)
            and covariant in its second type argument (meaning it contains values of that type).
            Implementors must fulfill the following for all X and f,g:
            <code>
                X.Promap(f, x => x) = X.Contramap(f)
                X.Promap(x => x, f) = X.Map(f)
            </code>
            </summary>
            <typeparam name="TNeed">The type of values the functor needs.</typeparam>
            <typeparam name="THave">The type of values the functor contains.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Category.IProfunctor`2.Promap``2(System.Func{``0,`0},System.Func{`1,``1})">
            <summary>
            Applies a function to the contravariant part of the functor and another over its covariant one.
            If the profunctor taks A and produces B, then we apply two functions:
            one from NewA to A, and one from B to NewB. The result is a profunctor that takes NewA and produces NewB.
            </summary>
            <typeparam name="TNeedResult">The type of the new values the profunctor will need.</typeparam>
            <typeparam name="THaveResult">The type of the new values the profunctor will contain.</typeparam>
            <param name="in">The function to apply to the contravariant values.</param>
            <param name="out">The function to apply to the covariant values.</param>
        </member>
        <member name="T:Nordril.Functional.Category.NaturalTransformations.MaybeToList">
            <summary>
            A natural transformation from <see cref="T:Nordril.Functional.Data.Maybe`1"/> to <see cref="T:Nordril.Functional.Data.FuncList`1"/> which creates a 0-element list for <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/> and a 1-element list containing <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> for <see cref="M:Nordril.Functional.Data.Maybe`1.Just(`0)"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Category.NaturalTransformations.MaybeToList.Transform``3(``1)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.CollectionExtensions">
            <summary>
            Extension methods for collections.
            </summary>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Aggregate2``3(System.Collections.Generic.IEnumerable{``0},``2,System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``2,``0,``1,``2})">
            <summary>
            Performs two nested aggregations: the outer one traverses <paramref name="xs"/>, the inner one traverses the result of <paramref name="selector"/> for each element of <paramref name="xs"/>. Thus, this function is the equivalent of running two nested loops, with <paramref name="selector"/> generating the elements for the inner loop. The accumulator is forwarded across each step.
            </summary>
            <typeparam name="T1">The type of element in the outer sequence.</typeparam>
            <typeparam name="T2">The type of element in the inner sequence.</typeparam>
            <typeparam name="TAcc">The type of the accumulator/result.</typeparam>
            <param name="xs">The sequence to traverse.</param>
            <param name="acc">The initial accumulator.</param>
            <param name="selector">The selector which generates the inner sequence for each element of <paramref name="xs"/>.</param>
            <param name="f">The combining function for the accumulator and the current element of the outer sequence, as well as the current element of th e inner list.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AggregateRight``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``1},``1)">
            <summary>
            Performs a right-fold on a sequence. For associative combining functions <paramref name="f"/>, <see cref="M:Nordril.Functional.CollectionExtensions.AggregateRight``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,``1},``1)"/> returns the same result as <see cref="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})"/>, though it will use heap memory linear in the length of <paramref name="xs"/>. The definition is:
            <code>
                {x1,x2,...,xn}.AggregateRight(acc, f) = f(x1, f(x2, ... f(xn, acc)...)
                for instance
                {1, 2, 3, 4}.AggregateRight(0, (x, acc) =&gt; x + acc = 1 + (2 + (3 + (4 + 0)))
            </code>
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <typeparam name="TResult">The type of the result/accumulator.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="acc">The accumulator.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.All(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Returns true iff all elements of <paramref name="xs"/> equal true.
            </summary>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.AnyTrue(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Returns true iff at least one element of <paramref name="xs"/> equals true.
            </summary>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Concat``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Concatenates a sequence of sequences.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence whose elements to concatenate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ConcatStrings(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Efficiently concatenates the elements of a sequence of strings into a single strings. An alias for <see cref="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})"/>.
            </summary>
            <param name="xs">The sequence whose elements to concatenate.</param>
            <param name="separator">The separator to put between each two elements.</param>
            <param name="prefix">The optional prefix to apply to the resultant string.</param>
            <param name="postfix">The optional postfix to apply to the resultant string.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Empty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns true iff the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.FirstMaybe``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of the sequence if it exists, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to check.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.FirstMaybe``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element of the sequence which fulfills a predicate if it exists, or <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to check.</param>
            <param name="predicate">The predicate the element has to fulfill.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach(System.Collections.IEnumerable,System.Action{System.Object})">
            <summary>
            Performs an action <paramref name="action"/> on each element of a sequence.
            </summary>
            <param name="xs">The list to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs an action <paramref name="action"/> on each element of a sequence.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1})">
            <summary>
            Performs an action <paramref name="action"/> on each element of two sequences which are traversed in parallel, until the end of the shorter one..
            </summary>
            <typeparam name="T1">The type of elements in the first sequencde.</typeparam>
            <typeparam name="T2">The type of elements in the second sequencde.</typeparam>
            <param name="xs">The first sequence to traverse.</param>
            <param name="ys">The second sequence to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Action{``0,``1,``2})">
            <summary>
            Performs an action <paramref name="action"/> on each element of three sequences which are traversed in parallel, until the end of the shorter one..
            </summary>
            <typeparam name="T1">The type of elements in the first sequencde.</typeparam>
            <typeparam name="T2">The type of elements in the second sequencde.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <param name="xs">The first sequence to traverse.</param>
            <param name="ys">The second secquence to traverse.</param>
            <param name="zs">The third sequence to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ForEach``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Action{``0,``1,``2,``3})">
            <summary>
            Performs an action <paramref name="action"/> on each element of four sequences which are traversed in parallel, until the end of the shorter one..
            </summary>
            <typeparam name="T1">The type of elements in the first sequencde.</typeparam>
            <typeparam name="T2">The type of elements in the second sequencde.</typeparam>
            <typeparam name="T3">The type of elements in the third sequence.</typeparam>
            <typeparam name="T4">The type of elements in the fourth sequence.</typeparam>
            <param name="xs">The first sequence to traverse.</param>
            <param name="ys">The second secquence to traverse.</param>
            <param name="us">The third sequence to traverse.</param>
            <param name="zs">The fourth sequence to traverse.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the index of the first occurrence of an element <paramref name="elem"/> in a sequence, or null.
            The search is linear and the runtime O(n).
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to check.</param>
            <param name="elem">The element to search for.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Intercalate``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersperses a sequence <paramref name="separator"/> between each two elements of a sequence <paramref name="xs"/>.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <param name="xs">The sequence to intersperse.</param>
            <param name="separator">The separator to intersperse between each two elements of <paramref name="xs"/>.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Intersperse``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Intersperses an element <paramref name="separator"/> between each two elements of a sequence.
            </summary>
            <typeparam name="T">The type of element in the sequence.</typeparam>
            <param name="xs">The sequence to intersperse.</param>
            <param name="separator">The separator to intersperse between each two elements of <paramref name="xs"/>.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.MergeAdjacent``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,Nordril.Functional.Data.Maybe{``0}})">
            <summary>
            Iterates through a sequence and merges any two adjacent elements for which the function <paramref name="mergeIf"/> returns a value. Multiple adjacent elements are merges as well, with the return value of <paramref name="mergeIf"/> functioning as an accumulator.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="xs">The list to merge.</param>
            <param name="mergeIf">The merging function. If two elements shouldn't be merged, it should return no value.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Partitions a list into two lists based on a predicate <paramref name="putInFirst"/>. All elements which fulfill <paramref name="putInFirst"/> are put into the first list, and all others are put into the second.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="xs">The source list to split.</param>
            <param name="putInFirst">The splitting predicate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to aggregate.</param>
            <param name="selector">The value selector.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Product(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Calculates the product of the elements of a sequence, returning 1 if the sequence is empty. null-values are ignored.
            </summary>
            <param name="xs">The sequence to aggregate.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.SelectAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``0})">
            <summary>
            Applies a function at a specific, 0-based index at a sequence and returns the original elements of the sequence at all others. This method takes O(n) time.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The list to search.</param>
            <param name="point">The point at which to apply the function.</param>
            <param name="f">The function to apply at index <paramref name="point"/>.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.SelectKeyValue``3(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a dictionary of key-value-pairs into a new form.
            </summary>
            <typeparam name="TKey">The type of the keys.</typeparam>
            <typeparam name="TValue">The type of the values.</typeparam>
            <typeparam name="TResult">The type of the results.</typeparam>
            <param name="xs">The sequence to traverse.</param>
            <param name="f">The function to apply to each element.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.SelectMaybe``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Nordril.Functional.Data.Maybe{``1}})">
            <summary>
            Applies a function which produces a <see cref="T:Nordril.Functional.Data.Maybe`1"/> to each element of a sequence and returns a sequence of those resultant elements for which <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true. This is useful for appliying a function which may not have a results and filtering it for results in one go.
            <br />
            Semantically, the following holds for all xs:
            <code>
               xs.SelectMaybe(f) == xs.Select(f).Where(x =&lt; x.HasValue).Select(x =&gt; x.Value());
            </code>
            </summary>
            <example>
            We compute the square roots of all elements in the sequence and return only those which were computed from positive numbers:
            <code>
            var xs = new [] {9, -10, -5, 25, 16, -144};
            
            var ys = xs.SelectMaybe(x =&gt; Maybe.JustIf(x &gt;= 0, () =&gt; Math.Sqrt(x)));
            //ys = [3, 5, 4]
            </code>
            </example>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <typeparam name="TResult">The type of elements ot generate.</typeparam>
            <param name="xs">The sequence to whose elements to apply the function.</param>
            <param name="f">The function to apply to each element of the sequence.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ToFuncList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an <see cref="T:Nordril.Functional.Data.IFuncList`1"/> out of a sequence of elements.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="xs">The sequence to turn into a list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unfold``2(``0,System.Func{``0,Nordril.Functional.Data.Maybe{System.ValueTuple{``0,``1}}})">
            <summary>
            Generates a (potentially infinite) sequence from a seed value <paramref name="seed"/> and a function to generate the next seed and element <paramref name="next"/>.
            </summary>
            <typeparam name="TSeed">The type of the seed value.</typeparam>
            <typeparam name="TResult">The type of elements to generate.</typeparam>
            <param name="seed">The initial seed value.</param>
            <param name="next">The function to generate the next seed, and the next element to yield. If the return value is <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>, the sequence-generation stops.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.ValueTuple{``1,``2}})">
            <summary>
            The oppostive of <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})"/>, in that it takes a list <paramref name="xs"/> and splits it into two lists of the same size via a function <paramref name="f"/>.
            </summary>
            <typeparam name="T">The type of elements in the source list.</typeparam>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <param name="f">The splitting function.</param>
            <returns>Two lists of the same size as <paramref name="xs"/>, with <paramref name="f"/> having been applied to the element of <paramref name="xs"/> in order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            The oppostive of <see cref="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})"/>, in that it takes a list <paramref name="xs"/> and splits it into two lists of the same size.
            </summary>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <returns>Two lists of the same size as <paramref name="xs"/>, with the same element order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``3(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2}})">
            <summary>
            The oppostive of <see cref="M:Nordril.Functional.CollectionExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})"/>, in that it takes a list <paramref name="xs"/> and splits it into three lists of the same size.
            </summary>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <typeparam name="T3">The type of elements in the third result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <returns>Three lists of the same size as <paramref name="xs"/>, with the same element order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Unzip``4(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3}})">
            <summary>
            The oppostive of <see cref="M:Nordril.Functional.CollectionExtensions.Zip``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})"/>, in that it takes a list <paramref name="xs"/> and splits it into fource lists of the same size.
            </summary>
            <typeparam name="T1">The type of elements in the first result list.</typeparam>
            <typeparam name="T2">The type of elements in the second result list.</typeparam>
            <typeparam name="T3">The type of elements in the third result list.</typeparam>
            <typeparam name="T4">The type of elements in the fourth result list.</typeparam>
            <param name="xs">The source list to split.</param>
            <returns>Three lists of the same size as <paramref name="xs"/>, with the same element order.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Zips two sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Zips three sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Zips three sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <summary>
            Zips four sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <typeparam name="T4">The type of elements in the fourth list.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
            <param name="us">The fourth list.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Zips four sequences together, creating a sequence of tuples.
            </summary>
            <typeparam name="T1">The type of elements in the first list.</typeparam>
            <typeparam name="T2">The type of elements in the second list.</typeparam>
            <typeparam name="T3">The type of elements in the third list.</typeparam>
            <typeparam name="T4">The type of elements in the fourth list.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="xs">The first list.</param>
            <param name="ys">The second list.</param>
            <param name="zs">The third list.</param>
            <param name="us">The fourth list.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Func{System.Collections.Generic.IList{``0},``1})">
            <summary>
            Zips a sequence of sequences together, iterating through all sequences in parallel, until the end of the longest one, omitting those sequences whose end has been reached from the input of <paramref name="f"/>. For each i, the list of elements at index i is combined into one result via <paramref name="f"/>.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="xs">The sequences to zip.</param>
            <param name="f">The combining function.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.Zip``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Zips a sequence of sequences together, iterating through all sequences in parallel, until the end of the shortest one. For each i, the list of elements at index i is combined into one result list.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
            <param name="xs">The sequences to zip.</param>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.ZipWithStream``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``1})">
            <summary>
            Zips a list with a stream. A steam is an infinite series comprising an initial element <paramref name="start"/> and a "next element"-function <paramref name="next"/>.
            </summary>
            <typeparam name="T1">The type of elements in the list.</typeparam>
            <typeparam name="T2">The type of elements in the stream.</typeparam>
            <param name="xs">The list.</param>
            <param name="start">The initial element of the stream.</param>
            <param name="next">The "next element"-function.</param>
            <returns>The elements of the first list, together with the created elements of the stream.</returns>
        </member>
        <member name="M:Nordril.Functional.CollectionExtensions.HashElements``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a hash value for a collection of elements by hashing the contained elements
            and adding them to a seed a multiplier. The hash code is computed by the formula:
            <code>
               collection.foldl(487, (acc, cur) => acc*31 + cur.GetHashCode())
            </code>
            Users should NOT rely on this implementation detail.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
            <param name="collection">The collection to hash.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Const`1">
            <summary>
            A const-functor that does not actually contain any values.
            </summary>
            <typeparam name="T">The type of value by which to tag the functor. No values are actually present.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.ContraMap``1(System.Func{``0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.op_Equality(Nordril.Functional.Data.Const{`0},Nordril.Functional.Data.Const{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.op_Inequality(Nordril.Functional.Data.Const{`0},Nordril.Functional.Data.Const{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`1.Equals(Nordril.Functional.Data.Const{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Const`2">
            <summary>
            A const-functor that contains a "real" value, but which is a functor according to a
            second value which is does not actually contain.
            This is analogous to <see cref="T:Nordril.Functional.Data.Const`1"/>, with the difference that we have a "hidden" value
            that does not influence the functor-instance.
            </summary>
            <typeparam name="TReal">The actual value contained in the functor.</typeparam>
            <typeparam name="TPhantom">The value which is only present as a phantom.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Const`2.RealValue">
            <summary>
            The value contained in the functor.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.#ctor(`0)">
            <summary>
            Creates a new const-instance with a value.
            </summary>
            <param name="realValue">The value to store in the functor.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.ContraMap``1(System.Func{``0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Equals(System.Object)">
            <summary>
            Determines equality based on <see cref="P:Nordril.Functional.Data.Const`2.RealValue"/>.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.op_Equality(Nordril.Functional.Data.Const{`0,`1},Nordril.Functional.Data.Const{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.op_Inequality(Nordril.Functional.Data.Const{`0,`1},Nordril.Functional.Data.Const{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Const`2.Equals(Nordril.Functional.Data.Const{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Const">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Const`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Const.ToConst``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Const`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Const.ToConst``1(Nordril.Functional.Category.IContravariant{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IContravariant`1"/> to a <see cref="T:Nordril.Functional.Data.Const`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Either`2">
            <summary>
            A sum type that can either be a left or a right, but not both. While left and right have no special semantics, per convention,
            the left is regarded as the "error-case", and the right is regarded as the "ok-case", if the either is used to model failure.
            </summary>
            <typeparam name="TLeft">The type of the left value in the either.</typeparam>
            <typeparam name="TRight">The type of the right value in the either.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.IsLeft">
            <summary>
            Returns true iff the either contains a left value.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Either`2.IsRight">
            <summary>
            Returns true iff the either contains a right value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Left">
            <summary>
            Tries to get the left value in an either and throws an <see cref="T:Nordril.Functional.PatternMatchException"/> if the either is a right.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Right">
            <summary>
            Tries to get the right value in an either and throws an <see cref="T:Nordril.Functional.PatternMatchException"/> if the either is a left.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.#ctor(`0,Nordril.Functional.Data.TagLeft)">
            <summary>
            Creates a new left-<see cref="T:Nordril.Functional.Data.Either`2"/> from a value. The type-level tag is required to disambiguate between constructors.
            </summary>
            <param name="value">The value to store in the either.</param>
            <param name="discriminator">The discriminator tag.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.#ctor(`1,Nordril.Functional.Data.TagRight)">
            <summary>
            Creates a new right-<see cref="T:Nordril.Functional.Data.Either`2"/> from a value. The type-level tag is required to disambiguate between constructors.
            </summary>
            <param name="value">The value to store in the either.</param>
            <param name="discriminator">The discriminator tag.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.FromLeft(`0)">
            <summary>
            Creates a left-either from a value.
            </summary>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.FromRight(`1)">
            <summary>
            Creates a right-either from a value.
            </summary>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.SetLeft(`0)">
            <summary>
            Sets the either to a left, clearing the right, if present.
            </summary>
            <param name="left">The value to put into the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.SetRight(`1)">
            <summary>
            Sets the either to a right, clearing the left, if present.
            </summary>
            <param name="right">The value to put into the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Swap">
            <summary>
            Turns a left-either into a right-either and vice versa.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.LeftOr(`0)">
            <summary>
            A safe way to get a either's left value. If <see cref="P:Nordril.Functional.Data.Either`2.IsLeft"/> is true, <see cref="M:Nordril.Functional.Data.Either`2.Left"/>
            is returned, otherwise, <paramref name="alternative"/> is returned.
            </summary>
            <param name="alternative">The value to return if the either is right.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.RightOr(`1)">
            <summary>
            A safe way to get a either's right value. If <see cref="P:Nordril.Functional.Data.Either`2.IsRight"/> is true, <see cref="M:Nordril.Functional.Data.Either`2.Right"/>
            is returned, otherwise, <paramref name="alternative"/> is returned.
            </summary>
            <param name="alternative">The value to return if the either is left.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Coalesce``1(System.Func{`0,``0},System.Func{`1,``0})">
            <summary>
            Coalesces an either to a single value. If the either is a left, the first function is applied. If it is a right,
            the second function is applied.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="f">The function to apply if the either is a left.</param>
            <param name="g">The function to apply if the either is a right.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Either`2"/>-objects based on their underlying values. This method returns true if both objects are left-eithers/right-eithers and if <see cref="M:System.Object.Equals(System.Object)"/> returns true for the underlying <see cref="M:Nordril.Functional.Data.Either`2.Left"/> or <see cref="M:Nordril.Functional.Data.Either`2.Right"/>, respectively.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.op_Equality(Nordril.Functional.Data.Either{`0,`1},Nordril.Functional.Data.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.op_Inequality(Nordril.Functional.Data.Either{`0,`1},Nordril.Functional.Data.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Equals(Nordril.Functional.Data.Either{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.BiMap``2(System.Func{`0,``0},System.Func{`1,``1})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Either`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Either">
            <summary>
            Static methods for <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Either.FromLeft``2(``0)">
            <summary>
            Creates a left-either from a value.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.FromRight``2(``1)">
            <summary>
            Creates a right-either from a value.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="value">The value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.EitherIf``2(System.Boolean,System.Func{``0},System.Func{``1})">
            <summary>
            Creates a right-either from a value.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="isRight">If true, an <see cref="M:Nordril.Functional.Data.Either.FromRight``2(``1)"/> will be created, and if false, an <see cref="M:Nordril.Functional.Data.Either.FromLeft``2(``0)"/>.</param>
            <param name="leftFactory">The left-value to store in the either.</param>
            <param name="rightFactory">The right-value to store in the either.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Either.ToEither``2(Nordril.Functional.Category.IBifunctor{``0,``1})">
            <summary>
            Tries to cast a generic bifunctor to an either via an explicit cast. Provided for convenience.
            </summary>
            <typeparam name="TLeft">The type of the left-value.</typeparam>
            <typeparam name="TRight">The type of the right-value.</typeparam>
            <param name="f">The bifunctor.</param>
        </member>
        <member name="T:Nordril.Functional.Data.EitherTag">
            <summary>
            A tag indicating the state of an <see cref="T:Nordril.Functional.Data.Either`2"/>.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.EitherTag.Left">
            <summary>
            Indicates that the either is a left.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.EitherTag.Right">
            <summary>
            Indicates that the either is a right.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.TagLeftRight">
            <summary>
            A type-level tag indicating "left" or "right".
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.TagLeftRight.#ctor">
            <summary>
            Empty, protected constructor.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.TagLeft">
            <summary>
            A type-level tag indicating "left" (as opposed to "right").
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TagLeft.Value">
            <summary>
            The tag's singleton value.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.TagRight">
            <summary>
            A type-level tag indicating "right" (as opposed to "left").
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TagRight.Value">
            <summary>
            The tag's singleton value.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.FuncList`1">
            <summary>
            A functional list. This class is a wrapper for <see cref="T:System.Collections.Generic.List`1"/> which implements various functional interfaces.
            </summary>
            <remarks>
            Because an <see cref="T:System.Collections.Generic.IEnumerable`1"/>-implementation is all we need for the operations of <see cref="T:Nordril.Functional.Category.IApplicative`1"/>, <see cref="T:Nordril.Functional.Category.IMonad`1"/>, etc. (thanks to LINQ), these operations have correspondingly relaxed constraints, and instead of <see cref="T:Nordril.Functional.Data.FuncList`1"/> as their parameter, they only require <see cref="T:System.Collections.Generic.IEnumerable`1"/>. This applies to <see cref="M:Nordril.Functional.Data.FuncList`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>, <see cref="M:Nordril.Functional.Data.FuncList`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>, and <see cref="M:Nordril.Functional.Data.FuncList`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})"/>.
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncList`1"/> from the elements of <paramref name="xs"/>.
            </summary>
            <param name="xs">The elements to store in the list.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncList`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncList`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Mzero">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.FoldMap``1(Nordril.Functional.Algebra.Monoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Filter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Empty">
            <summary>
            Returns an empty list.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <summary>
            Concatenates two lists. <paramref name="x"/> only has to be an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, not a <see cref="T:Nordril.Functional.Data.IFuncList`1"/>.
            </summary>
            <param name="x">The other sequence.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Equals(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetComparer``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncList`1.Copy">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.FuncList">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.FuncList`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.Make``1(``0[])">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncList`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
            <param name="elements">The list of elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncList.ToFuncList``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.IFuncList`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.FuncSet`1">
            <summary>
            A functional set. This class is a wrapper for <see cref="T:System.Collections.Generic.HashSet`1"/> which implements various functional interfaces.
            </summary>
            <remarks>
            Because an <see cref="T:System.Collections.Generic.IEnumerable`1"/>-implementation is all we need for the operations of <see cref="T:Nordril.Functional.Category.IApplicative`1"/>, <see cref="T:Nordril.Functional.Category.IMonad`1"/>, etc. (thanks to LINQ), these operations have correspondingly relaxed constraints, and instead of <see cref="T:Nordril.Functional.Data.FuncList`1"/> as their parameter, they only require <see cref="T:System.Collections.Generic.IEnumerable`1"/>. This applies to <see cref="M:Nordril.Functional.Data.FuncSet`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})"/>, <see cref="M:Nordril.Functional.Data.FuncSet`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})"/>.
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.FuncSet`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.FuncSet`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncSet`1"/> from the elements of <paramref name="xs"/>.
            </summary>
            <param name="xs">The elements to store in the list.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.AddPure(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.DifferencePure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Equals(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Equals(Nordril.Functional.Data.IFuncSet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Filter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.FoldMap``1(Nordril.Functional.Algebra.Monoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IntersectionPure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.RemovePure(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.SymmetricDifferencePure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.UnionPure(System.Collections.Generic.ISet{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.GetComparer``1">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet`1.Copy">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.FuncSet">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.FuncSet`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.Make``1(``0[])">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.FuncSet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
            <param name="elements">The set of elements.</param>
        </member>
        <member name="M:Nordril.Functional.Data.FuncSet.ToFuncSet``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.IFuncSet`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Identity`1">
            <summary>
            The identity functor which does nothing but wrap a value.
            </summary>
            <typeparam name="T">The type of the value being wrapped.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Identity`1.Value">
            <summary>
            Gets or sets the wrapped value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.#ctor(`0)">
            <summary>
            Creates a new identity.
            </summary>
            <param name="value">The value to wrap.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Equals(System.Object)">
            <summary>
            Determines equality based on the underlying <see cref="P:Nordril.Functional.Data.Identity`1.Value"/>.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.op_Equality(Nordril.Functional.Data.Identity{`0},Nordril.Functional.Data.Identity{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.op_Inequality(Nordril.Functional.Data.Identity{`0},Nordril.Functional.Data.Identity{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Identity`1.Equals(Nordril.Functional.Data.Identity{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Identity">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Identity`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Identity.ToPredicate``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to an <see cref="T:Nordril.Functional.Data.Identity`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.IFuncList`1">
            <summary>
            A "functional list" which, in addition to supporting the operations <see cref="T:System.Collections.Generic.IList`1"/>, implements <see cref="T:Nordril.Functional.Category.IMonadPlus`1"/> (and parent interfaces), <see cref="T:Nordril.Functional.Category.IAlternative`1"/>, and <see cref="T:Nordril.Functional.Category.IFoldable`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncList`1.GetComparer``1">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IComparer`1"/> for <see cref="T:System.Collections.Generic.IList`1"/>s if the contained elements of type <typeparamref name="T1"/> are comparable.
            </summary>
            <typeparam name="T1">The of element in the <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.IFuncSet`1">
            <summary>
            A "functional set" which, in addition to supporting the operations <see cref="T:System.Collections.Generic.ISet`1"/>, implements <see cref="T:Nordril.Functional.Category.IMonad`1"/> (and parent interfaces).
            </summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.AddPure(`0)">
            <summary>
            Returns a new set to which <paramref name="elem"/> has been added, while leaving this set unchanged.
            </summary>
            <param name="elem">The element to add.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.RemovePure(`0)">
            <summary>
            Returns a new set from which <paramref name="elem"/> has been removed, while leaving this set unchanged.
            </summary>
            <param name="elem">The element to remove.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.UnionPure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns the union of this set and <paramref name="elem"/>, while leaving this set unchanged.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.IntersectionPure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns the intersection of this set and <paramref name="elem"/>, while leaving this set unchanged.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.DifferencePure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns the difference between this set and <paramref name="elem"/>, while leaving this set unchanged.
            The difference is set the of those elements which are contained in this set but not in <paramref name="elem"/>.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.SymmetricDifferencePure(System.Collections.Generic.ISet{`0})">
            <summary>
            Returns a new set which is the symmetric difference of this set and <paramref name="elem"/>, while leaving this set unchanged.
            The symmetric differnce is the set of those elements which are in one set but not both.
            </summary>
            <param name="elem">The second set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.IFuncSet`1.GetComparer``1">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IComparer`1"/> for <see cref="T:System.Collections.Generic.ISet`1"/>s if the contained elements of type <typeparamref name="T1"/> are comparable.
            </summary>
            <typeparam name="T1">The of element in the <see cref="T:System.Collections.Generic.ISet`1"/>.</typeparam>
        </member>
        <member name="T:Nordril.Functional.Data.Maybe`1">
            <summary>
            An optional type that works for both reference and value types.
            Also known as "Option".
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Value">
            <summary>
            Returns the value, if it exists. Otherwise, a <see cref="T:Nordril.Functional.PatternMatchException"/> is thrown.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Maybe`1.HasValue">
            <summary>
            Returns true iff the maybe has a value.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Maybe`1.IsNothing">
            <summary>
            Returns true iff the maybe does not have a value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ClearValue">
            <summary>
            Clears the value in-place. <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> will be false.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.SetValue(`0)">
            <summary>
            Sets the value in-place. <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> will be true.
            </summary>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOr(`0)">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>
            is returned, otherwise, <paramref name="alternative"/> is returned.
            </summary>
            <param name="alternative">The value to return if the maybe has no value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOr``1(System.Func{`0,``0},``0)">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, the function <paramref name="f"/> is applied to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> and returned, otherwise <paramref name="alternative"/> is returned.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="f">The function to apply to the value, if present.</param>
            <param name="alternative">The value to return if the maybe has no value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOrLazy(System.Func{`0})">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>
            is returned, otherwise, <paramref name="alternative"/> is returned. This version allows lazy evaluation of <paramref name="alternative"/>.
            </summary>
            <param name="alternative">The value to return if the maybe has no value. Wrapped in a lambda to permit lazy evaluation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.ValueOrLazy``1(System.Func{`0,``0},System.Func{``0})">
            <summary>
            A safe way to get a maybe's value. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, the function <paramref name="f"/> is applied to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> and returned, otherwise, <paramref name="alternative"/> is returned. This version allows lazy evaluation of <paramref name="alternative"/>.
            </summary>
            <param name="f">The function to apply to the value, if present.</param>
            <param name="alternative">The value to return if the maybe has no value. Wrapped in a lambda to permit lazy evaluation.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.TryGetValue(`0,`0@)">
            <summary>
            A safe way to get a maybe's value. The return value is <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/>. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <paramref name="result"/> will be set to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>, otherwise, it will be set to <paramref name="alternative"/>.
            </summary>
            <param name="alternative">The value to return if the maybe has no value.</param>
            <param name="result"><see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> if <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, and <paramref name="alternative"/> otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.TryGetValueLazy(System.Func{`0},`0@)">
            <summary>
            A safe way to get a maybe's value. The return value is <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/>. If <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, <paramref name="result"/> will be set to <see cref="M:Nordril.Functional.Data.Maybe`1.Value"/>, otherwise, it will be set to <paramref name="alternativeFactory"/>. This version allows lazy evaluation.
            </summary>
            <param name="alternativeFactory">The value to return if the maybe has no value. Wrapped in a lambda to permit lazy evaluation.</param>
            <param name="result"><see cref="M:Nordril.Functional.Data.Maybe`1.Value"/> if <see cref="P:Nordril.Functional.Data.Maybe`1.HasValue"/> is true, and <paramref name="alternativeFactory"/> otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Nothing">
            <summary>
            Returns a new maybe containing new value.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Just(`0)">
            <summary>
            Returns a new maybe containing a value.
            </summary>
            <param name="value">The value to store in the maybe.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Mzero">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Mplus(Nordril.Functional.Category.IMonadPlus{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Bind``1(System.Func{`0,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`0,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Empty">
            <summary>
            Returns <see cref="M:Nordril.Functional.Data.Maybe.Nothing``1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Alt(Nordril.Functional.Category.IAlternative{`0})">
            <summary>
            Returns a copy of this, if it has a value, or a copy of <paramref name="x"/>.
            </summary>
            <param name="x">The other value.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:Nordril.Functional.Data.Maybe`1"/>-objects based on their values, if present. The comparison returns true if both values lack a value or if both have one and the values are equal based on their <see cref="M:System.Object.Equals(System.Object)"/>-method.
            </summary>
            <param name="obj">The other object.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.op_Equality(Nordril.Functional.Data.Maybe{`0},Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.op_Inequality(Nordril.Functional.Data.Maybe{`0},Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Maybe`1.Equals(Nordril.Functional.Data.Maybe{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Maybe">
            <summary>
            Static methods and extension for <see cref="T:Nordril.Functional.Data.Maybe`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.JustIf``1(System.Boolean,System.Func{``0})">
            <summary>
            Creates a new maybe which contains a value if <paramref name="isJust"/> is true,
            and Nothing otherwise.
            Useful as a shorthand case distinction.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="isJust">The test.</param>
            <param name="factory">The function to create a value. This wrapper is there to ensure that the
            value isn't evaluated if it isn't needed.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Just``1(``0)">
            <summary>
            Returns a new maybe containing a value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="value">The value to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.Nothing``1">
            <summary>
            Returns a new maybe containing no value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.ToMaybe``1(Nordril.Functional.Category.IFunctor{``0})">
            <summary>
            Tries to cast a <see cref="T:Nordril.Functional.Category.IFunctor`1"/> to a <see cref="T:Nordril.Functional.Data.Maybe`1"/> via an explicit cast.
            Convenience method.
            </summary>
            <typeparam name="T">The type of the value contained in the functor.</typeparam>
            <param name="f">The functor to cast to a maybe.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Maybe.ValueOr``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1,``2},``2)">
            <summary>
            Tries to get a value from a dictionary and applies a function if present, or returns an alternative value if not.
            This does not change the dictionary. The semantics are the same as <see cref="M:Nordril.Functional.Data.Maybe`1.ValueOr``1(System.Func{`0,``0},``0)"/>.
            </summary>
            <typeparam name="TKey">The type of the dictionary's key.</typeparam>
            <typeparam name="TValue">The type of the dictionary's value.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="dict">The dictionary from which to get the value.</param>
            <param name="key">The key whose corresponding value to get.</param>
            <param name="f">The function to apply to the key's value if the key is present.</param>
            <param name="alternative">The alternative value to return if the key is not present.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Pred`1">
            <summary>
            A predicate which wraps a function that takes a <typeparamref name="T"/> and returns true or false.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Pred`1.Func">
            <summary>
            The predicate function.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Pred`1.Neutral">
            <summary>
            The neutral element w.r.t the predicate's monoid. Creates a predicate that always returns true.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            Creates a new predicate from a function.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.Run(`0)">
            <summary>
            Runs the predicate with an argument.
            </summary>
            <param name="arg">The argument.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.ContraMap``1(System.Func{``0,`0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Pred`1.Op(Nordril.Functional.Data.Pred{`0})">
            <summary>
            Combines two predicates via logical AND.
            </summary>
            <param name="that">The other predicate.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Pred">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Pred`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Pred.Create``1(System.Func{``0,System.Boolean})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Data.Pred`1"/> from a function <paramref name="f"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="f">The predicate function.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Pred.ToPredicate``1(Nordril.Functional.Category.IContravariant{``0})">
            <summary>
            Unsafely casts an <see cref="T:Nordril.Functional.Category.IContravariant`1"/> to a <see cref="T:Nordril.Functional.Data.Pred`1"/>.
            </summary>
            <typeparam name="T">The type of the input parameter.</typeparam>
            <param name="x">The object to cast.</param>
        </member>
        <member name="T:Nordril.Functional.Data.State`2">
            <summary>
            The state-monad, which maintains a state <typeparamref name="TState"/> and produces a result
            <typeparamref name="TValue"/>. Composing multiple state-actions is like composing
            simple functions, except that an implicit variable of type <typeparamref name="TState"/>
            is being passed around.
            As such, state is a more well-behaved replacement to modifying some global variable.
            </summary>
            <typeparam name="TState">The type of the state</typeparam>
            <typeparam name="TValue">The type of the value produced.</typeparam>
        </member>
        <member name="F:Nordril.Functional.Data.State`2.runState">
            <summary>
            The state-function which takes an initial state and produces
            both a new state and a result.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.State`2.#ctor(System.Func{`0,System.ValueTuple{`1,`0}})">
            <summary>
            Creates a new state from a function that takes an initial state
            and produces a new state, plus a result.
            </summary>
            <param name="runState">The state-function to put into the state monad.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Run(`0)">
            <summary>
            Runs the state function with an initial state and returns the result, plus the actual result.
            </summary>
            <param name="initialState">The initial state (the starting point of the computation).</param>
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.State`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.State">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.State`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.State.Get``1">
            <summary>
            Returns the current state.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.State.Put``1(``0)">
            <summary>
            Replaces the current state with a new one.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="value">The new state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.Modify``1(System.Func{``0,``0})">
            <summary>
            Modifies the current state by running a function on it.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <param name="f">The function to apply to the state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.State.RunForResult``2(Nordril.Functional.Data.State{``0,``1},``0)">
            <summary>
            Runs the state function with an initial state and returns the result, discarding the final state.
            </summary>
            <param name="s">The state to run.</param>
            <param name="initialState">The initial state (the starting point of the computation).</param>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.State.RunForState``2(Nordril.Functional.Data.State{``0,``1},``0)">
            <summary>
            Runs the state function with an initial state and returns the final state, discarding the result.
            </summary>
            <param name="s">The state to run.</param>
            <param name="initialState">The initial state (the starting point of the computation).</param>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Data.State.RunStringBuilder``1(Nordril.Functional.Data.State{System.Text.StringBuilder,``0})">
            <summary>
            Runs the state function on a newly created <see cref="T:System.Text.StringBuilder"/> and returns the final string. This is a convenience method if one uses <see cref="T:Nordril.Functional.Data.State`2"/> to efficiently build up strings.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="s">The state to run.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Store`2">
            <summary>
            A store-monad which starts with an initial store and allows repeated extraction of values,
            but not change to the store itself.
            Store is the opposite/dual of <see cref="T:Nordril.Functional.Data.State`2"/>, which requires an initial state
            and can produce new states.
            </summary>
            <typeparam name="TStore">The type of the state.</typeparam>
            <typeparam name="TValue">The type value to be extracted.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Store`2.RunStore">
            <summary>
            Runs the store.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Store`2.InitialStore">
            <summary>
            The initial store which can be used to run the store.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.#ctor(System.Func{`0,`1},`0)">
            <summary>
            Creates a new store out for an extraction function and an initial state.
            </summary>
            <param name="runStore">The function to extract a value from the store.</param>
            <param name="initialStore">The initial state.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.Extend``1(System.Func{Nordril.Functional.Category.IComonad{`1},``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.Extract">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Store`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Store">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Store`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Store.GetStore``2(Nordril.Functional.Data.Store{``0,``1})">
            <summary>
            Extracts the store as a value.
            </summary>
            <typeparam name="TStore">The type type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation whose store to extract.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.SetStore``2(Nordril.Functional.Data.Store{``0,``1},``0)">
            <summary>
            Replaces the initial store with a new one.
            Note that this does not mean replacing a state on the fly; rather, this function
            replaces the starting point of the compuation.
            </summary>
            <typeparam name="TStore">The type type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation whose initial store to replace.</param>
            <param name="newStore">The new initial store.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Store.ModifyStore``2(Nordril.Functional.Data.Store{``0,``1},System.Func{``0,``0})">
            <summary>
            Replaces the initial store with a new one by modifiying it with a function.
            Note that this does not mean replacing a state on the fly; rather, this function
            replaces the starting point of the compuation.
            </summary>
            <typeparam name="TStore">The type type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation whose initial store to replace.</param>
            <param name="f">The function to apply to the store.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Data.Store.WhatIfStore``2(Nordril.Functional.Data.Store{``0,``1},``0)">
            <summary>
            Returns the extracted value, if the initial store would be <paramref name="hypothetical"/>,
            without changing the store.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation to run.</param>
            <param name="hypothetical">The hypothetical initial store to use.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.WhatIfFunc``2(Nordril.Functional.Data.Store{``0,``1},System.Func{``0,``0})">
            <summary>
            Returns the extracted value, if <paramref name="f"/> would be applied to the initial store,
            without changing the store.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation to run.</param>
            <param name="f">The function to apply to the initial store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Store.WhatIfF``2(Nordril.Functional.Data.Store{``0,``1},System.Func{``0,Nordril.Functional.Category.IFunctor{``0}})">
            <summary>
            Returns the extracted value, if <paramref name="f"/> would be applied to the initial store. The
            <see cref="P:Nordril.Functional.Data.Store`2.RunStore"/> function is applied via
            <see cref="M:Nordril.Functional.Category.IFunctor`1.Map``1(System.Func{`0,``0})"/> to the functor-valued result.
            </summary>
            <typeparam name="TStore">The type of the store.</typeparam>
            <typeparam name="TValue">The type of the value extracted.</typeparam>
            <param name="s">The computation to run.</param>
            <param name="f">The functor-valued function to apply to the initial store.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Tree`1">
            <summary>
            A rose tree, wherein each node has a single key and a list of children.
            </summary>
            <typeparam name="T">The type of the key.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.Key">
            <summary>
            The node's key.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.Children">
            <summary>
            The list of the node's children, if the node is an inner node.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.IsLeaf">
            <summary>
            Whether the node is a leaf. A leaf can have no children, though a node without children is not necessarily a leaf
            (an example being a directory without files in it).
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Tree`1.IsInner">
            <summary>
            Whether the node is an inner node. This is the opposite of <see cref="P:Nordril.Functional.Data.Tree`1.IsLeaf"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.SetToLeaf">
            <summary>
            Sets the type of the node to a leaf.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.SetToInner(System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Tree{`0}})">
            <summary>
            Sets the type of the node to an inner node and optionally gives it children.
            </summary>
            <param name="children">The children of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.AddParent(`0)">
            <summary>
            Returns a new tree with <paramref name="newParent"/> as its root
            and this being its only child. The tree is not copied.
            </summary>
            <param name="newParent">The key that should be the new root of the tree.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.MakeInner(`0,System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Tree{`0}})">
            <summary>
            Creates an inner node.
            </summary>
            <param name="key">The key of the node.</param>
            <param name="children">The children of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.MakeLeaf(`0)">
            <summary>
            Creates a leaf.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Traverse(Nordril.Functional.Data.TreeTraversal,System.Action{Nordril.Functional.Data.Tree{`0}},System.Action{Nordril.Functional.Data.Tree{`0},System.Int32},System.Action{Nordril.Functional.Data.Tree{`0}})">
            <summary>
            Traverses the tree in a certain order and yields the nodes.
            Uses the visitor pattern.
            </summary>
            <param name="traversal">The type of the traversal.</param>
            <param name="visit">The action to execute at each node, if any.</param>
            <param name="down">The action to execute when entering a node's children. The arguments are the current node and the index of the child node.</param>
            <param name="up">The action to execute when leaving a node. The argument is the node being left.</param>
            <returns>The nodes of the tree, and whether each node is a leaf.</returns>
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Map``1(System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.FoldMap``1(Nordril.Functional.Algebra.Monoid{``0},System.Func{`0,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Foldr``1(System.Func{`0,``0,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Semifilter(System.Func{`0,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Tree`1.Equals(Nordril.Functional.Data.Tree{`0})">
            <summary>
            Compares two trees structurally. Two trees are structurally equal if:
            <br />
            <list type="number">
                <item><see cref="P:Nordril.Functional.Data.Tree`1.IsLeaf"/> has the same value for both,</item>,
                <item>The keys are equal according to <see cref="M:System.Object.Equals(System.Object)"/>.</item>
                <item><see cref="P:Nordril.Functional.Data.Tree`1.Children"/>, if <see cref="P:Nordril.Functional.Data.Tree`1.IsInner"/> is true, are of the same number and are pairwise equal according to <see cref="M:Nordril.Functional.Data.Tree`1.Equals(Nordril.Functional.Data.Tree{`0})"/>.</item>
            </list>
            </summary>
            <param name="other">The other tree.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Tree">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Tree`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.MakeInner``1(``0,System.Collections.Generic.IEnumerable{Nordril.Functional.Data.Tree{``0}})">
            <summary>
            Creates an inner node.
            </summary>
            <typeparam name="T">The type of the keys.</typeparam>
            <param name="key">The key of the node.</param>
            <param name="children">The children of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.MakeLeaf``1(``0)">
            <summary>
            Creates a leaf.
            </summary>
            <typeparam name="T">The type of the keys.</typeparam>
            <param name="key">The key of the node.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Tree.RetrieveDirectoryStructure(System.String,Nordril.Functional.Data.PathNameUsage,System.Func{System.String,System.Boolean})">
            <summary>
            Takes a directory and returns a tree representing that directory as its root and the sub-directories and files as child-nodes, recursively. An <see cref="M:Nordril.Functional.Data.Either.FromLeft``2(``0)"/> represents a directory and will always be an inner-node, and an <see cref="M:Nordril.Functional.Data.Either.FromRight``2(``1)"/> represents a file. No file will have a directory as a child.
            <br />
            This method uses direct recursion and thus required O(n) stack space, where n is the maximum depth of the directory structure. Symlinks are not traversed. As there are no filesystem-level locks, this method may fail if a file or directory is deleted partway through the computation.
            </summary>
            <param name="directory">The path to the directory.</param>
            <param name="fullName">Where to use the full names of filesystem-entries.</param>
            <param name="predicate">The optional predicate to which a path (except for the root-node) has to conform to be included as a node. The argument is always the full path of the filesystem-entry.</param>
            <exception cref="T:System.InvalidOperationException">If the directory <paramref name="directory"/> does not exist.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">A directory path is invalid, such as referring to an unmapped drive or having been deleted.</exception>
            <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or combined exceed the system-defined maximum length.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
            <exception cref="T:System.StackOverflowException">If the maximum stack size has been exceeded.</exception>
        </member>
        <member name="T:Nordril.Functional.Data.TreeTraversal">
            <summary>
            A type of tree traversal.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TreeTraversal.PreOrder">
            <summary>
            First the node, then its children.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.TreeTraversal.PostOrder">
            <summary>
            First the children, then the node.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.PathNameUsage">
            <summary>
            Where the full names of filesystem-entries should be used.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.PathNameUsage.Always">
            <summary>
            The full name should always be used.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.PathNameUsage.RootOnly">
            <summary>
            The full name should only be used at the root.
            </summary>
        </member>
        <member name="F:Nordril.Functional.Data.PathNameUsage.Never">
            <summary>
            The full name should be used nowhere.
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Unit">
            <summary>
            A unit-type containing no values and having just one instance.
            Forms the trivial, one-element commutative group and is a 0-tuple.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Inverse">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Neutral">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_Equality(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_Inequality(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns false.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_LessThan(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns false.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_GreaterThan(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns false.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_LessThanOrEqual(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.op_GreaterThanOrEqual(Nordril.Functional.Data.Unit,Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="a">The first unit.</param>
            <param name="b">The second unit</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Equals(System.Object)">
            <summary>
            Returns true iff the other object is a <see cref="T:Nordril.Functional.Data.Unit"/>.
            </summary>
            <param name="obj">The object to which to compare this.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.GetHashCode">
            <summary>
            Gets a hash code for a <see cref="T:Nordril.Functional.Data.Unit"/>. A constant.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Op(Nordril.Functional.Data.Unit)">
            <inheritdoc />
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Length">
            <summary>
            Always returns 0.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Unit.Item(System.Int32)">
            <summary>
            Always throws an <see cref="T:System.IndexOutOfRangeException"/>, since <see cref="T:Nordril.Functional.Data.Unit"/> is a 0-tuple.
            </summary>
            <param name="index">The index of the element to get.</param>
            <exception cref="T:System.IndexOutOfRangeException">Always thrown when this indexer is called.</exception>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.CompareTo(Nordril.Functional.Data.Unit)">
            <summary>
            Always returns 0.
            </summary>
            <param name="other">The other unit.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Unit.Equals(Nordril.Functional.Data.Unit)">
            <summary>
            Always returns true.
            </summary>
            <param name="other">The other unit.</param>
        </member>
        <member name="T:Nordril.Functional.Data.Void">
            <summary>
            A void-type that cannot be constructed.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Void.#ctor">
            <summary>
            Constructs the void type (but you can't touch this).
            </summary>
        </member>
        <member name="T:Nordril.Functional.Data.Writer`2">
            <summary>
            The writer-monad, which provides write-only access to output, in addition to producing a result.
            The output can then be later extracted, but not by the computations within the writer-monad themselves.
            </summary>
            <typeparam name="TState">The type of the output.</typeparam>
            <typeparam name="TValue">The type of the result.</typeparam>
        </member>
        <member name="P:Nordril.Functional.Data.Writer`2.Output">
            <summary>
            The write-only output of the computation.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Writer`2.Result">
            <summary>
            The result of the computation.
            </summary>
        </member>
        <member name="P:Nordril.Functional.Data.Writer`2.OutputMonoid">
            <summary>
            The monoid to use when combining outputs.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.#ctor(`0,`1,Nordril.Functional.Algebra.Monoid{`0})">
            <summary>
            Creates a new writer from a result, an initial output, and a monoid to combine successive outputs.
            </summary>
            <param name="output">The initial output.</param>
            <param name="result">The result to produce.</param>
            <param name="outputMonoid">The monoid to use to combine outputs.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.#ctor(`1,Nordril.Functional.Algebra.Monoid{`0})">
            <summary>
            Creates a new writer from a result and a monoid to combine successive outputs.
            The neutral element of the monoid will be used as the initial output.
            </summary>
            <param name="result">The result to produce.</param>
            <param name="outputMonoid">The monoid to use to combine outputs.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.Tell(`0)">
            <summary>
            Stores a new ouput in this <see cref="T:Nordril.Functional.Data.Writer`2"/>, mutating it.
            <c>this</c> is returned.
            </summary>
            <param name="output">The new output to store.</param>
            <returns>This object.</returns>
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.Ap``1(Nordril.Functional.Category.IApplicative{System.Func{`1,``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.Bind``1(System.Func{`1,Nordril.Functional.Category.IMonad{``0}})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.Map``1(System.Func{`1,``0})">
            <inheritdoc />
        </member>
        <member name="M:Nordril.Functional.Data.Writer`2.Pure``1(``0)">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.Data.Writer">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.Data.Writer`2"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Tell``1(``0)">
            <summary>
            Stores a new output in the writer and returns no result.
            The <see cref="T:Nordril.Functional.Category.IMonad`1"/> instance of the output is used
            to combine the new output with the existing ones.
            </summary>
            <typeparam name="TState">The type of the output.</typeparam>
            <param name="output">The output to store.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Tell``1(``0,Nordril.Functional.Algebra.Monoid{``0})">
            <summary>
            Stores a new output in the writer and returns no result.
            The caller can specify how to combine the new piece of output with
            the existing ones.
            </summary>
            <typeparam name="TState">The type of the output.</typeparam>
            <param name="output">The output to store.</param>
            <param name="monoid">The monoid to use when combining outputs.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Listen``1(``0)">
            <summary>
            Stores a new output and returns it.
            The <see cref="T:Nordril.Functional.Category.IMonad`1"/> instance of the output is used
            to combine the new output with the existing ones.
            </summary>
            <typeparam name="TState">The type of the output.</typeparam>
            <param name="output">The output to store and return.</param>
        </member>
        <member name="M:Nordril.Functional.Data.Writer.Listen``1(``0,Nordril.Functional.Algebra.Monoid{``0})">
            <summary>
            Stores a new output and returns it.
            The <see cref="T:Nordril.Functional.Category.IMonad`1"/> instance of the output is used
            to combine the new output with the existing ones.
            </summary>
            <typeparam name="TState">The type of the output.</typeparam>
            <param name="output">The output to store and return.</param>
            <param name="monoid">The monoid to use when combining outputs.</param>
        </member>
        <member name="T:Nordril.Functional.EnumExtensions">
            <summary>
            Extension methods for <see cref="T:System.Enum"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.EnumExtensions.To``1(``0,``0)">
            <summary>
            Returns all values of <typeparamref name="T"/> which fall into the open interval bounded by <paramref name="from"/> and <paramref name="to"/>. O(n) in the number of all values in <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the enum.</typeparam>
            <param name="from">The first element to return.</param>
            <param name="to">The last element to return.</param>
        </member>
        <member name="T:Nordril.Functional.F">
            <summary>
            Functional extension methods for functions.
            </summary>
        </member>
        <member name="M:Nordril.Functional.F.Id``1">
            <summary>
            Returns the identity function for a given type.
            </summary>
            <typeparam name="T">The type of the identity function.</typeparam>
        </member>
        <member name="M:Nordril.Functional.F.Then``3(System.Func{``0,``1},System.Func{``1,``2})">
            <summary>
            Composes two functions. The second function is run with the result of the first.
            </summary>
            <typeparam name="TA">The input of the first function.</typeparam>
            <typeparam name="TB">The output of the first function and input of the second function.</typeparam>
            <typeparam name="TC">The output of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.F.After``3(System.Func{``1,``2},System.Func{``0,``1})">
            <summary>
            Composes two functions. The first function is run with the result of the first.
            This is "traditional" function chaining.
            </summary>
            <typeparam name="TA">The input of the second function.</typeparam>
            <typeparam name="TB">The output of the first function and input of the second function.</typeparam>
            <typeparam name="TC">The output of the first function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Curry``3(System.Func{``0,``1,``2})">
            <summary>
            Curries a binary function, allowing it to take its arguments one by one.
            </summary>
            <typeparam name="TIn1">The first argument of the function.</typeparam>
            <typeparam name="TIn2">The second argument of the function.</typeparam>
            <typeparam name="TOut">The output of the function.</typeparam>
            <param name="f">The function to curry.</param>
        </member>
        <member name="M:Nordril.Functional.F.Curry3``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Curries a ternary function, allowing it to take its arguments one by one.
            </summary>
            <typeparam name="TIn1">The first argument of the function.</typeparam>
            <typeparam name="TIn2">The second argument of the function.</typeparam>
            <typeparam name="TIn3">The third argument of the function.</typeparam>
            <typeparam name="TOut">The output of the function.</typeparam>
            <param name="f">The function to curry.</param>
        </member>
        <member name="M:Nordril.Functional.F.Curry4``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Curries a quaternary function, allowing it to take its arguments one by one.
            </summary>
            <typeparam name="TIn1">The first argument of the function.</typeparam>
            <typeparam name="TIn2">The second argument of the function.</typeparam>
            <typeparam name="TIn3">The third argument of the function.</typeparam>
            <typeparam name="TIn4">The fourth argument of the function.</typeparam>
            <typeparam name="TOut">The output of the function.</typeparam>
            <param name="f">The function to curry.</param>
        </member>
        <member name="M:Nordril.Functional.F.Uncurry``3(System.Func{``0,System.Func{``1,``2}})">
            <summary>
            Uncurries a binary function, requiring it to take its arguments all at once.
            The inverse of <see cref="M:Nordril.Functional.F.Curry``3(System.Func{``0,``1,``2})"/>.
            </summary>
            <typeparam name="TIn1">The first argument of the function.</typeparam>
            <typeparam name="TIn2">The second argument of the function.</typeparam>
            <typeparam name="TOut">The output of the function.</typeparam>
            <param name="f">The curried function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Uncurry3``4(System.Func{``0,System.Func{``1,System.Func{``2,``3}}})">
            <summary>
            Uncurries a ternary function, requiring it to take its arguments all at once.
            The inverse of <see cref="M:Nordril.Functional.F.Curry3``4(System.Func{``0,``1,``2,``3})"/>.
            </summary>
            <typeparam name="TIn1">The first argument of the function.</typeparam>
            <typeparam name="TIn2">The second argument of the function.</typeparam>
            <typeparam name="TIn3">The third argument of the function.</typeparam>
            <typeparam name="TOut">The output of the function.</typeparam>
            <param name="f">The curried function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Uncurry4``5(System.Func{``0,System.Func{``1,System.Func{``2,System.Func{``3,``4}}}})">
            <summary>
            Uncurries a quaternary function, requiring it to take its arguments all at once.
            The inverse of <see cref="M:Nordril.Functional.F.Curry4``5(System.Func{``0,``1,``2,``3,``4})"/>.
            </summary>
            <typeparam name="TIn1">The first argument of the function.</typeparam>
            <typeparam name="TIn2">The second argument of the function.</typeparam>
            <typeparam name="TIn3">The third argument of the function.</typeparam>
            <typeparam name="TIn4">The fourth argument of the function.</typeparam>
            <typeparam name="TOut">The output of the function.</typeparam>
            <param name="f">The curried function.</param>
        </member>
        <member name="M:Nordril.Functional.F.Set``1(``0,System.Action{``0})">
            <summary>
            Applies an action to an object and returns the object.
            Mostly a convenience method for executing setters.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="obj">The object to modify.</param>
            <param name="a">The action to apply.</param>
        </member>
        <member name="M:Nordril.Functional.F.Apply``2(``0,System.Func{``0,``1})">
            <summary>
            Applies a function to an object postfix.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">The object.</param>
            <param name="f">The function to apply to the object.</param>
        </member>
        <member name="T:Nordril.Functional.FuncComparer`1">
            <summary>
            A comparer that uses a binary function to compare two objects.
            </summary>
            <typeparam name="T">The type of objects that this comparer can test for equality.</typeparam>
        </member>
        <member name="M:Nordril.Functional.FuncComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1"/> out of a binary function.
            </summary>
            <param name="f">The binary function to lift.</param>
        </member>
        <member name="M:Nordril.Functional.FuncComparer`1.Compare(`0,`0)">
            <summary>
            Uses the supplied binary function to compare two objects.
            </summary>
            <param name="x">The first object.</param>
            <param name="y">The second object.</param>
        </member>
        <member name="T:Nordril.Functional.FuncEqualityComparer`1">
            <summary>
            An equality comparer that uses a binary predicate to compare two objects for equality.
            </summary>
            <typeparam name="T">The type of objects that this comparer can test for equality.</typeparam>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> out of a binary predicate.
            </summary>
            <param name="f">The binary predicate to lift.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Uses the supplied binary predicate to compare two objects for equality.
            </summary>
            <param name="x">The first object.</param>
            <param name="y">The second object.</param>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Uses the object's <see cref="M:System.Object.GetHashCode"/> function to return a hash code.
            </summary>
            <param name="obj">The object to hash.</param>
        </member>
        <member name="T:Nordril.Functional.FuncEqualityComparerExtensions">
            <summary>
            Extension methods for <see cref="T:Nordril.Functional.FuncEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.FuncEqualityComparerExtensions.ToEqualityComparer``1(System.Func{``0,``0,System.Boolean})">
            <summary>
            Turns a binary predicate into a <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="T">The type of objects to compare.</typeparam>
            <param name="f">The comparison function.</param>
        </member>
        <member name="T:Nordril.Functional.ICopyable`1">
            <summary>
            A typed version of <see cref="T:System.ICloneable"/> which creates a deep copy of the object.
            </summary>
            <typeparam name="T">The type of the implementor.</typeparam>
        </member>
        <member name="M:Nordril.Functional.ICopyable`1.Copy">
            <summary>
            Creates a deep copy of the object that can be modified independently of the original.
            </summary>
        </member>
        <member name="T:Nordril.Functional.LexicographicalComparer`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which lexicographically compares two sequences of elements. If the elements in the shorter sequence are all equal according to the comparison, the longer sequence counts as the greater one.
            </summary>
            <typeparam name="T">The type of elements in the sequences.</typeparam>
        </member>
        <member name="F:Nordril.Functional.LexicographicalComparer`1.elementComparer">
            <summary>
            The underlying elementwise comparer.
            </summary>
        </member>
        <member name="M:Nordril.Functional.LexicographicalComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Creates a new comparer.
            </summary>
            <param name="elementComparer">The comparison function for two elements of the sequences.</param>
        </member>
        <member name="M:Nordril.Functional.LexicographicalComparer`1.Compare(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.ObjectExtensions">
            <summary>
            Extension methods for <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.DefaultHash(System.Object,System.Object[])">
            <summary>
            A default hashing function which hashes all given fields, plus the full name of the object's type.
            <see cref="T:System.String"/>-fields are hashed with the option <see cref="F:System.StringComparison.InvariantCulture"/>.
            This hashing function is well-suited to hashing according to structural equality in complex objects like trees and dictionaries.
            </summary>
            <param name="obj">The object for which to get the hash.</param>
            <param name="fields">The fields of the object.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.DefaultHash``1(System.Object,System.Object[])">
            <summary>
            A default hashing function which hashes all given fields, plus the full name of the object's type.
            <see cref="T:System.String"/>-fields are hashed with the option <see cref="F:System.StringComparison.InvariantCulture"/>.
            This hashing function is well-suited to hashing according to structural equality in complex objects like trees and dictionaries.
            </summary>
            <typeparam name="T">The type to incorporate into the hash.</typeparam>
            <param name="obj">The object for which to get the hash.</param>
            <param name="fields">The fields of the object.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.GetBaseName(System.Type)">
            <summary>
            Gets the type's base name, i.e. its name without any generic parameters.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.GetBaseFullName(System.Type)">
            <summary>
            Gets the type's base full name, i.e. its full name (namespace-qualified) name without any generic parameters.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Nordril.Functional.ObjectExtensions.GetGenericName(System.Type,System.Boolean)">
            <summary>
            Gets the type's generic name, which is equal to its base name for non-generic types,
            and equal to the angle-bracket-syntax in C#.
            </summary>
            <param name="type">The type.</param>
            <param name="useFullName">If true, the type's full (namespace-qualified) name will be used, otherwise the type's name.</param>
        </member>
        <member name="T:Nordril.Functional.Pattern">
            <summary>
            A constructor for a first-class pattern.
            </summary>
            <remarks>
            Using a <see cref="T:Nordril.Functional.Pattern"/> consists of two stages:
            <list type="number">
                <item>Constructing a list of cases which are checked in-order, and</item>
                <item>running the pattern against an input object.</item>
            </list>
            Constructing a case-list is a safe operation in that none of the cases are evaluated, though be advised that the <see cref="T:Nordril.Functional.Pattern`2"/>-object is not thread-safe and <see cref="M:Nordril.Functional.ICopyable`1.Copy"/> should be used prior to sharing it across threads. Each case consists of a predicate which has to evaluate to true if the case is to apply, and an action which is run on the input object if the case applies.
            <br />
            Cases can be added via a fluent-API, all at once or at different times. <see cref="T:Nordril.Functional.Pattern`2"/>s, being first-class objects, can be passed in as arguments or be returned by functions.
            <br />
            The second stage is the exection: via <see cref="M:Nordril.Functional.Pattern`2.Run(`0)"/>, and input-object is passed in and the previously registered cases are evaluated in order of their addition. The first case which evaluates to true is applied and result of its action returned; if no cases applies, the default pattern is applied, which can be set via <see cref="M:Nordril.Functional.Pattern`2.WithDefault(System.Func{`0,`1})"/>. If no default pattern was set and no case applies, a <see cref="T:Nordril.Functional.PatternMatchException"/> is thrown.
            <br />
            It is considered good form to always specify a default pattern unless one is absolutely sure that the disjunction of the registered cases all possible values of the input object.
            </remarks>
            <example>
            Below we create a sign-pattern which returns 1 for postive numbers, -1 for negative ones, and 0 for 0. The <see cref="T:System.Int32"/> type annotation in the first case disambiguates the type of the input object.
            <code>
            var pat = Pattern
               .Match((int x) => x &gt; 0, _ =&gt; 1)
               .Match(x => x &lt; 0, =&gt; -1)
               .WithDefault(_ =&gt; 0);
               
            var sign = pat.Run(5); //1
            sign = pat.Run(-4); //-1
            sign = pat.Run(0); //0
            </code>
            We can also create recursive patterns. Below we have an implementation of the Collatz "algorithm" which does the following:
            <list type="number">
                <item>If a number is even, divide it by two and repeat, or</item>
                <item>if a number is odd, multiply by three and add 1, and repeat.</item>
            </list>
            The local function <c>go</c> is used to create the recursion. We first declare it to have the name available in the <c>collatz</c>-<see cref="T:Nordril.Functional.Pattern`2"/>, then we tie the know by running the pattern in <c>go</c>. Note that we insert the terminating pattern (<c>&lt;=1</c>) as the first, to avoid infinite recursion.
            <br />
            Per the Collatz-conjecture, every number eventually reaches one.
            <code>
            public int Collatz(int num)
            {
               //Create the referancable name "go".
               Func&lt;int, int&gt; go(int x) = null;
               
               //Create the pattern (only once).
               var collatz = Pattern
                  .Match((int x) => x &lt; 1, x => 1)
                  .Match(x => x % 2 == 0, x => go(x/2))
                  .WithDefault(x => go(x*3 + 1));
                  
               //Tie the know but instantiating "go" with running the pattern.
               go = x => collatz.Run(x);
               
               //Run the pattern. We either return 1 or we don't terminate.
               return go(num);
            }
            </code>
            One can also carry state in patterns through the input-object. For instance, we can calculate the factorial tail-recursively thus:
            <code>
            var n = 15;
            var fac = Pattern
               .Match(((int n, long sum) x) =&gt; x.n &lt;= 1, x =&gt; x.sum)
               .MatchTailRec(x =&gt; x.n &gt; 1, x =&gt; (x.n-1, (x.n* x.sum)))
               .Run((n, 1));
            </code>
            Here, we pass a tuple consisting of the current number (n) and the sum so far (sum) into the pattern-match, and in the second case, we decrement n while multiplying the previous sum with n. We get the final number instead of the tuple because the terminating, first case discards the tuple and just returns the sum.
            </example>
        </member>
        <member name="M:Nordril.Functional.Pattern.Match``2(System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Creates a pattern-match on an input object <typeparamref name="TIn"/>, starting with a single case.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern.MatchMany``2(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Func{``0,System.Boolean},System.Func{``0,``1}}})">
            <summary>
            Creates a pattern-match on an input object <typeparamref name="TIn"/>, starting with a list of cases.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
            <param name="cases">The list of cases, consisting of predicates and functions to be applied to the input if the case applies.</param>
        </member>
        <member name="T:Nordril.Functional.Pattern`2">
            <summary>
            A list of cases which is checked top-down when the pattern is run.
            </summary>
            <typeparam name="TIn">The type of the input object.</typeparam>
            <typeparam name="TOut">The type of the output object.</typeparam>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.#ctor(System.Collections.Generic.IEnumerable{System.Func{`0,System.Boolean}},System.Collections.Generic.IEnumerable{System.Func{`0,`1}},System.Collections.Generic.IEnumerable{System.Func{`0,`0}},System.Func{`0,`1})">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.Pattern`2"/> out of a list of predicates an actions. The caller must ensure that both lists have the same number of elements.
            </summary>
            <param name="predicates">The list of predicates for the cases.</param>
            <param name="actions">The list of actions for the cases.</param>
            <param name="tailRecActions">The list of tail-recursive actions. This list must have the same number of entries as <paramref name="actions"/>, but with the values at the indexes of the non-tail-recursive actions being null.</param>
            <param name="defaultPattern">The default pattern. If null is passed, the default pattern which throws a <see cref="T:System.NullReferenceException"/> will be used.</param>
            <exception cref="T:System.ArgumentException">If the lengths of <paramref name="predicates"/>, <paramref name="actions"/>, and <paramref name="tailRecActions"/> do not agree.</exception>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.StartMatch(System.Func{`0,System.Boolean},System.Func{`0,`1})">
            <summary>
            Creates a <see cref="T:Nordril.Functional.Pattern`2"/> out of a single case.
            </summary>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.StartMatch(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Func{`0,System.Boolean},System.Func{`0,`1}}})">
            <summary>
            Creates a <see cref="T:Nordril.Functional.Pattern`2"/> out of a sequence of cases.
            </summary>
            <param name="cases">The list of cases, consisting of predicates and functions to be applied to the input if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Match(System.Func{`0,System.Boolean},System.Func{`0,`1})">
            <summary>
            Appends a new case to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            </summary>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Match(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Func{`0,System.Boolean},System.Func{`0,`1}}})">
            <summary>
            Appends a list of new cases to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            </summary>
            <param name="cases">The list of cases, consisting of predicates and functions to be applied to the input if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.MatchTailRec(System.Func{`0,System.Boolean},System.Func{`0,`0})">
            <summary>
            Appends a new, tail-recursive case to the end of a <see cref="T:Nordril.Functional.Pattern`2"/>. The calling object will be modified and <c>this</c> will be returned.
            Note that a tail-recursive case <em>cannot</em> be a terminating case and if the input-object always matches a tail-recursive case, <see cref="M:Nordril.Functional.Pattern`2.Run(`0)"/> will not terminate.
            <br />
            Instead of <paramref name="action"/> returning an output, it returns an <typeparamref name="TIn"/>-object with which the pattern-match will be called tail-recursively. This means that no new stack-frame will be allocated for the recursive call. Think of this like running a pattern-match in a loop. For general recursion (which runs the risk of stack overflows), see the examples in <see cref="T:Nordril.Functional.Pattern`2"/>.
            </summary>
            <remarks>
            If tail-recursion is all you need, using <see cref="M:Nordril.Functional.Pattern`2.MatchTailRec(System.Func{`0,System.Boolean},System.Func{`0,`0})"/> is actually superior to a native <c>switch</c>-expression with a recursive call in it (w.r.t. the consumption of stack-memory) because the C# runtime does not support tail-recursion. Of course, any tail-recursive <c>switch</c>-expression can be easily transformed into one which does not run into a stack overflow (becsause of the recursion alone) by floating out the recursion into a loop around the the <c>switch</c>.</remarks>
            <param name="predicate">The predicate which returns true if the case applies.</param>
            <param name="action">The function that should be applied to the input object if the case applies.</param>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.WithDefault(System.Func{`0,`1})">
            <summary>
            Sets the default pattern which always applies after all other cases. This call overwrites any previously set default pattern, except if null is passed in <paramref name="defaultPattern"/>, in which case nothing is done.
            </summary>
            <param name="defaultPattern"></param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Run(`0)">
            <summary>
            Runs a pattern against an input object <paramref name="arg"/> and returns the result of the first case that applies, or the result of the default pattern is none applies.
            </summary>
            <param name="arg">The input object.</param>
            <returns>The result of the first case which applies to the input object, with that case's action run against the input object.</returns>
            <exception cref="T:Nordril.Functional.PatternMatchException">If no case applies and no alternative default pattern was set via <see cref="M:Nordril.Functional.Pattern`2.WithDefault(System.Func{`0,`1})"/>.</exception>
        </member>
        <member name="M:Nordril.Functional.Pattern`2.Copy">
            <inheritdoc />
        </member>
        <member name="T:Nordril.Functional.PatternMatchException">
            <summary>
            The object didn't correspond to the asked-for pattern. An example would be <see cref="T:Nordril.Functional.Data.Maybe`1"/> whose value
            was requested but which contained nothing.
            </summary>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/> with a standard message.
            </summary>
            <param name="requested">The requested member.</param>
            <param name="className">The name of the class.</param>
            <param name="actualPattern">The pattern that was actually present. This should be the name of a member whose call would've succeeded.</param>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/> with a custom message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Nordril.Functional.PatternMatchException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new <see cref="T:Nordril.Functional.PatternMatchException"/> with a custom message an an inner exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Nordril.Functional.TupleExtensions">
            <summary>
            Extension methods for <see cref="T:System.ValueTuple"/>.
            </summary>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``2(System.ValueTuple{``0},System.Func{``0,``1})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``3(System.ValueTuple{``0,``1},System.Func{``0,``2})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``4(System.ValueTuple{``0,``1,``2},System.Func{``0,``3})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``0,``4})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``0,``5})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``0,``6})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``0,``7})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.First``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``0,``8})">
            <summary>
            Applies a function to the first element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``3(System.ValueTuple{``0,``1},System.Func{``1,``2})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``4(System.ValueTuple{``0,``1,``2},System.Func{``1,``3})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``1,``4})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``1,``5})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``1,``6})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``1,``7})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Second``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``1,``8})">
            <summary>
            Applies a function to the second element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``4(System.ValueTuple{``0,``1,``2},System.Func{``2,``3})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``2,``4})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``2,``5})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``2,``6})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``2,``7})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Third``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``2,``8})">
            <summary>
            Applies a function to the third element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``3,``4})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``3,``5})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``3,``6})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``3,``7})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fourth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``3,``8})">
            <summary>
            Applies a function to the fourth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``4,``5})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``4,``6})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``4,``7})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Fifth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``4,``8})">
            <summary>
            Applies a function to the fifth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Sixth``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``5,``6})">
            <summary>
            Applies a function to the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Sixth``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``5,``7})">
            <summary>
            Applies a function to the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Sixth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``5,``8})">
            <summary>
            Applies a function to the sixth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Seventh``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``6,``7})">
            <summary>
            Applies a function to the seventh element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Seventh``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``6,``8})">
            <summary>
            Applies a function to the seventh element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Eighth``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``7,``8})">
            <summary>
            Applies a function to the eigth element of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TR">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.Both``4(System.ValueTuple{``0,``1},System.Func{``0,``2},System.Func{``1,``3})">
            <summary>
            Applies two functions to the two elements of the tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TResult1">The result of the first function.</typeparam>
            <typeparam name="TResult2">The result of the second function.</typeparam>
            <param name="t">The tuple to which to apply the functions.</param>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
            <returns></returns>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``3(System.ValueTuple{``0,``1},System.Func{``0,``1,``2})">
            <summary>
            Applies a binary function to the two elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``4(System.ValueTuple{``0,``1,``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Applies a ternary function to the three elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``5(System.ValueTuple{``0,``1,``2,``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Applies a quaternary function to the four elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``6(System.ValueTuple{``0,``1,``2,``3,``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Applies a quinary function to the five elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The five element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``7(System.ValueTuple{``0,``1,``2,``3,``4,``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Applies a senary function to the six elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>
            Applies a septenary function to the seven elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="M:Nordril.Functional.TupleExtensions.ApplyToTuple``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>
            Applies a octonary function to the seven elements of a tuple.
            </summary>
            <typeparam name="T1">The first element.</typeparam>
            <typeparam name="T2">The second element.</typeparam>
            <typeparam name="T3">The third element.</typeparam>
            <typeparam name="T4">The fourth element.</typeparam>
            <typeparam name="T5">The fifth element.</typeparam>
            <typeparam name="T6">The sixth element.</typeparam>
            <typeparam name="T7">The seventh element.</typeparam>
            <typeparam name="T8">The eighth element.</typeparam>
            <typeparam name="TResult">The result of the function.</typeparam>
            <param name="t">The tuple to which to apply the function.</param>
            <param name="f">The function to apply.</param>
        </member>
        <member name="T:Nordril.HedgingEngine.Logic.Mapping.IIsomorphism`2">
            <summary>
            A type which can convert objects of type <typeparamref name="TFrom"/> to objects of type <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
        </member>
        <member name="M:Nordril.HedgingEngine.Logic.Mapping.IIsomorphism`2.ConvertBack(`1)">
            <summary>
            Converts an object back from <typeparamref name="TTo"/> to <typeparamref name="TFrom"/>.
            The following holds for all <c>x</c>:
            <code>
                ConvertBack(Convert(x)) == x
            </code>
            </summary>
            <param name="from">The object to convert.</param>
        </member>
        <member name="T:Nordril.HedgingEngine.Logic.Mapping.IMorphism`2">
            <summary>
            A type which can convert objects of type <typeparamref name="TFrom"/> to objects of type <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">The from-type.</typeparam>
            <typeparam name="TTo">The to-type.</typeparam>
        </member>
        <member name="M:Nordril.HedgingEngine.Logic.Mapping.IMorphism`2.Convert(`0)">
            <summary>
            Converts an object.
            </summary>
            <param name="from">The object to convert.</param>
        </member>
    </members>
</doc>
