using Nordril.Functional.Algebra;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace Nordril.Functional.Data
{
    #pragma warning disable 1591
    public static partial class MaybeT
    {
        //I wish this was autogenerated...

        //Const{T}

        public static MaybeT<Const<TResult>, Const<Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TSource, TMiddle, TResult>
            (this MaybeT<Const<TSource>, Const<Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Const<TMiddle>, Const<Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<Const<TResult>, Const<Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Const<TResult>, Const<Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Either
        public static MaybeT<Either<TLeft, TResult>, Either<TLeft, Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TLeft, TSource, TMiddle, TResult>
            (this MaybeT<Either<TLeft, TSource>, Either<TLeft, Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Either<TLeft, TMiddle>, Either<TLeft, Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<Either<TLeft, TResult>, Either<TLeft, Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Either<TLeft, TResult>, Either<TLeft, Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //FuncList
        public static MaybeT<FuncList<TResult>, FuncList<Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TSource, TMiddle, TResult>
            (this MaybeT<FuncList<TSource>, FuncList<Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<FuncList<TMiddle>, FuncList<Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<FuncList<TResult>, FuncList<Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<FuncList<TResult>, FuncList<Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //FuncSet

        public static MaybeT<FuncSet<TResult>, FuncSet<Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TSource, TMiddle, TResult>
            (this MaybeT<FuncSet<TSource>, FuncSet<Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<FuncSet<TMiddle>, FuncSet<Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<FuncSet<TResult>, FuncSet<Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<FuncSet<TResult>, FuncSet<Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Identity
        public static MaybeT<Identity<TResult>, Identity<Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TSource, TMiddle, TResult>
            (this MaybeT<Identity<TSource>, Identity<Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Identity<TMiddle>, Identity<Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<Identity<TResult>, Identity<Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Identity<TResult>, Identity<Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Io
        public static MaybeT<Io<TResult>, Io<Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TSource, TMiddle, TResult>
            (this MaybeT<Io<TSource>, Io<Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Io<TMiddle>, Io<Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<Io<TResult>, Io<Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Io<TResult>, Io<Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Random
        public static MaybeT<Random<TRng, TResult>, Random<TRng, Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TRng, TSource, TMiddle, TResult>
            (this MaybeT<Random<TRng, TSource>, Random<TRng, Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Random<TRng, TMiddle>, Random<TRng, Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<Random<TRng, TResult>, Random<TRng, Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Random<TRng, TResult>, Random<TRng, Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Reader
        public static MaybeT<Reader<TEnvironment, TResult>, Reader<TEnvironment, Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TEnvironment, TSource, TMiddle, TResult>
            (this MaybeT<Reader<TEnvironment, TSource>, Reader<TEnvironment, Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Reader<TEnvironment, TMiddle>, Reader<TEnvironment, Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<Reader<TEnvironment, TResult>, Reader<TEnvironment, Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Reader<TEnvironment, TResult>, Reader<TEnvironment, Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Rws

        public static MaybeT<Rws<TEnvironment, TOutput, TMonoid, TState, TResult>, Rws<TEnvironment, TOutput, TMonoid, TState, Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TEnvironment, TOutput, TMonoid, TState, TSource, TMiddle, TResult>
            (this MaybeT<Rws<TEnvironment, TOutput, TMonoid, TState, TSource>, Rws<TEnvironment, TOutput, TMonoid, TState, Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Rws<TEnvironment, TOutput, TMonoid, TState, TMiddle>, Rws<TEnvironment, TOutput, TMonoid, TState, Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
            where TMonoid : IMonoid<TOutput>
        {
            return (MaybeT<Rws<TEnvironment, TOutput, TMonoid, TState, TResult>, Rws<TEnvironment, TOutput, TMonoid, TState, Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Rws<TEnvironment, TOutput, TMonoid, TState, TResult>, Rws<TEnvironment, TOutput, TMonoid, TState, Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //State
        public static MaybeT<State<TState, TResult>, State<TState, Maybe<TResult>>, Maybe<TResult>, TResult> SelectMany<TState, TSource, TMiddle, TResult>
            (this MaybeT<State<TState, TSource>, State<TState, Maybe<TSource>>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<State<TState, TMiddle>, State<TState, Maybe<TMiddle>>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
        {
            return (MaybeT<State<TState, TResult>, State<TState, Maybe<TResult>>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<State<TState, TResult>, State<TState, Maybe<TResult>>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }

        //Writer
        public static MaybeT<Writer<TOutput, TResult, TMonoid>, Writer<TOutput, Maybe<TResult>, TMonoid>, Maybe<TResult>, TResult> SelectMany<TOutput, TMonoid, TSource, TMiddle, TResult>
            (this MaybeT<Writer<TOutput, TSource, TMonoid>, Writer<TOutput, Maybe<TSource>, TMonoid>, Maybe<TSource>, TSource> source,
             Func<TSource, MaybeT<Writer<TOutput, TMiddle, TMonoid>, Writer<TOutput, Maybe<TMiddle>, TMonoid>, Maybe<TMiddle>, TMiddle>> f,
             Func<TSource, TMiddle, TResult> resultSelector)
            where TMonoid : IMonoid<TOutput>
        {
            return (MaybeT<Writer<TOutput, TResult, TMonoid>, Writer<TOutput, Maybe<TResult>, TMonoid>, Maybe<TResult>, TResult>)
                source.BindT(x => f(x).MapT<Writer<TOutput, TResult, TMonoid>, Writer<TOutput, Maybe<TResult>, TMonoid>, Maybe<TResult>, TResult>(y => resultSelector(x, y)));
        }
    }
#pragma warning restore 1591
}
